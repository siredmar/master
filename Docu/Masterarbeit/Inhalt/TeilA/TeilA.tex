\chapter{Teil A}
\label{cha:TeilA}
Im Folgenden wird die Ansteuerung von TFT-Displays über den 8080-Bus auf Basis des \code{Gnublin Linuxboards} realisiert. Hierzu werden verschieden große LCD-Displays mit unterschiedlichen Controllern unter Verwendung des 8080-Interface untersucht. 

\section{Untersuchte Displays mit 8080-Interface}
Dieser Abschnitt beschreibt die drei untersuchten Displays. Der Fokus bei der Beschaffung lag vor allem darauf, dass die Pinbelegung der jeweiligen Displays übereinstimmt. So ist die Entwicklung von nur einer Adapterplatine zwischen \code{Gnublin Extended} und Display nötig. Alle verwendeten Displays werden im 16 Bit Farbmodus betrieben. Dieser entspricht einer resultierenden Farbtiefe von 65.535 Farben\newline % \footnote{2^16 = 65.536}.
Alle verwendeten Displays arbeiten dahingehend gleich, dass sie Kommandos und Daten auf dem Datenbus anlegen, diese jedoch durch eine gesonderte Leitung unterschieden werden. Soll dem Display also etwas mitgeteilt werden, so muss zuerst ein entsprechendes Kommando und im Anschluss die Nutzdaten gesendet werden. Um Pixeldaten an das Display zu senden, hat sich die Vorgehensweise etabliert, eine durch vier Eckpunkte definierte Region im RAM des Displays zu reservieren (siehe \refa{fig:ram_window}). Werden im Anschluss Pixeldaten gesendet, inkrementiert der Controller die Adresse und springt bei einem Zeilenumbruch automatisch an die richtige Stelle im RAM. Der verfügbare Speicher im Controller beschränkt dabei die maximale Auflösung der ansteuerbaren TFT-Panel. Trotz der Tatsache, dass sich die Displays auf elektrischer Seite nicht unterscheiden, müssen diese allerdings softwareseitig, aufgrund unterschiedlicher Displaycontroller, speziell behandelt werden.
\begin{figure}[h]
	\centering
\fbox{	\includegraphics[width=0.5\textwidth]{TeilA/ram_window.png}}
	\caption{Fensterreservierung im Display-RAM}
	\label{fig:ram_window}
\end{figure}
\subsection{4.3 / 5 Zoll mit SSD1963}
Die Wahl des Controllers \code{SSD1963} von Solomon Systech liegt nahe, da dieser bereits mit einem 4.3 Zoll  Panel in einer vorausgehenden Arbeit (siehe \cite{Schlegel2013a}) verwendet wird. Dort ist das Display mittels GPIO-Pins am Raspberry Pi angeschlossen. Die Software bezüglich der reinen Displayansteuerung ist somit bereits vorhanden. Aufgrund eines Problems, das in Abschnitt \ref{teila_knownbugs} näher beschrieben ist, ist ein weiteres Display mit 5 Zoll Panel aber demselben Controller untersucht. 
\refa{fig:8080_pinout} zeigt das Pinout der verwendeten Displays (Quelle: \cite{Coldtears2014}).
\begin{figure}[h]
	\centering
\fbox{	\includegraphics[width=0.5\textwidth]{TeilA/display_pinout.png}}
	\caption{8080-Display Pinout}
	\label{fig:8080_pinout}
\end{figure}
Die Displays haben bei 4.3 Zoll eine Auflösung von 480x272 beziehungsweise bei 5 Zoll 800x480 Pixel. Neben den für die Initialisierung nötigen Kommandos besitzt der Controller folgende wichtige Kommandos (siehe \reft{tab:Kommandos_SSD1963}, Quelle: \cite{SSD2008}). Die Initialisierungsbefehle sind nicht erläutert, da diese aus dem Datenblatt entnehmbar sind.
\begin{table}[h]
\begin{tabular}{|p{4cm}|p{1cm}|p{8cm}|}\hline
\rowcolor{TableBackgroundColor} 
   \textbf{Kommando} & \textbf{Hex-Code} & \textbf{Kommentar}\\ \hline
   Set Column Address & 0x2A & Eckpunkte des RAM-Fensters in X-Richtung \\ \hline
   Set Page Address & 0x2B & Eckpunkte des RAM-Fensters in Y-Richtung \\ \hline
   Write Memory Start & 0x2C & Alle Folgenden Pixeldaten werden im RAM-Fenster platziert \\ \hline
\end{tabular}
\caption{Relevante Kommandos des SSD1963}
\label{tab:Kommandos_SSD1963}
\end{table}
\subsection{3.2 Zoll mit SSD1289}
Das 3.2 Zoll Display von Sainsmart wird mit einen \code{SSD1289} von Solomon Systech betrieben. Dieses Display hat eine Auflösung von 320x240 Farbpunkten. Das Pinout ist dasselbe, das in \refa{fig:8080_pinout} zu sehen ist. Analog zu den Kommandos des \code{SSD1963} in \reft{tab:Kommandos_SSD1963} besitzt der \code{SSD1289} ähnlich Befehle. Diese sind in  \reft{tab:Kommandos_SSD1289} erläutert (siehe \cite{SSD2007}). Die zur Initialisierung notwendigen Kommandos sind hier nicht näher beschrieben, da diese wie zuvor aus dem Datenblatt entnehmbar sind.
\begin{table}[h]
\begin{tabular}{|p{4cm}|p{1cm}|p{8cm}|}\hline
\rowcolor{TableBackgroundColor}
   \textbf{Kommando} & \textbf{Hex-Code} & \textbf{Kommentar}\\ \hline
   Horizontal RAM address position & 0x44 & Eckpunkte des RAM-Fensters in X-Richtung \\ \hline
   Vertical RAM address start position & 0x45 & Startpunkt des RAM-Fensters in Y-Richtung \\ \hline
   Horizontal RAM address stop position & 0x46 & Endpunkt des  RAM-Fensters in Y-Richtung \\ \hline
   Set GDDRAM X address counter & 0x4E & Zeiger im  RAM-Fenster in X-Richtung \\ \hline
   Set GDDRAM Y address counter & 0x4F & Zeiger im RAM-Fenster in Y-Richtung \\ \hline
   RAM Write  Register & 0x22 & Alle Folgenden Pixeldaten werden im RAM-Fenster platziert \\ \hline
\end{tabular}
\caption{Relevante Kommandos des SSD1289}
\label{tab:Kommandos_SSD1289}
\end{table}


\subsection{5 Zoll mit CPLD}
Als drittes Display mit 8080-Interface kommt eine 5 Zoll Display mit einer Auflösung von 800x480 Bildpunkten zum Einsatz. Anstelle eines universell einsetzbaren Controllers für variable Panels, verwendet dieses Display ein CPLD\footnote{CPLD: Complex Programmable Logic Device} mit zugeschnittenen Timings für das verwendete TFT-Displays. Der Vorteil eines solchen Displays ist, dass keine Initialisierungsroutine benötigt wird, um die Timings für das Panel einzustellen. Ein Reset setzt das Display betriebsbereit. Nachteilig ist dabei, dass nur TFT-Panels exakter Größe und mit exakten Timings verwendet werden können. Für diese Arbeit ist die Verwendung von anderen Panels belanglos. Auch hier ist das Pinout des Displays analog zu \refa{fig:8080_pinout}.\newline
Wichtige Kommandos zum Betrieb des Displays sind in \reft{tab:Kommandos_MD050SD} einsehbar (siehe \cite{ITEAD2013}). Dieses Display trägt die Bezeichnung MD050SD.

\begin{table}[h]
\begin{tabular}{|p{4cm}|p{1cm}|p{8cm}|}\hline
\rowcolor{TableBackgroundColor}
   \textbf{Kommando} & \textbf{Hex-Code} & \textbf{Kommentar}\\ \hline
   Beginning Row Address & 0x02 & Startpunkt des RAM-Fensters in X-Richtung \\ \hline
   Ending Row Address& 0x06 & Endpunkt des RAM-Fensters in X-Richtung \\ \hline
   Beginning Column Address & 0x03 & Startpunkt des RAM-Fensters in Y-Richtung \\ \hline
   Ending Column Address& 0x07 & Endpunkt des RAM-Fensters in Y-Richtung \\ \hline
   Writing Page Register & 0x05 & Alle Folgenden Pixeldaten werden im RAM-Fenster platziert \\ \hline
\end{tabular}
\caption{Relevante Kommandos des MD050SD}
\label{tab:Kommandos_MD050SD}
\end{table}

% \input{Inhalt/TeilA/8080GPIO}
\input{Inhalt/TeilA/8080SRAM}

% \section{Vor- und Nachteile}
\input{Inhalt/TeilA/TeilAKnownBugs}

\input{Inhalt/TeilA/TeilAZusammenfassung}

