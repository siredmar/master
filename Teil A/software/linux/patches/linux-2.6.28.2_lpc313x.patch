diff -purN linux-2.6.28.2/arch/arm/configs/ea313x_defconfig work_2.6.28.2/arch/arm/configs/ea313x_defconfig
--- linux-2.6.28.2/arch/arm/configs/ea313x_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/configs/ea313x_defconfig	2010-03-25 11:31:33.000000000 -0700
@@ -0,0 +1,1208 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28.2
+# Thu Mar 25 11:23:51 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_CLASSIC_RCU=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_LPC313X=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# LPC313x Implementations
+#
+CONFIG_MACH_EA313X=y
+# CONFIG_MACH_EA3152 is not set
+# CONFIG_MACH_VAL3153 is not set
+# CONFIG_MACH_VAL3154 is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_SCHED_HRTICK is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_VERBOSE=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_UNIX is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_ARPD=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_DEBUG_DRIVER=y
+CONFIG_DEBUG_DEVRES=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+# CONFIG_MTD_DATAFLASH_OTP is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_LPC313X=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+CONFIG_DM9000=y
+CONFIG_DM9000_DEBUGLEVEL=4
+# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_LPC31XX_SERIAL_DMA_SUPPORT is not set
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+CONFIG_I2C_DEBUG_BUS=y
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_LPC313X=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_LPC313X_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+# CONFIG_SND_USB is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_LPC313X_SOC=y
+CONFIG_SND_LPC313X_SOC_I2S=y
+CONFIG_SND_LPC313X_SOC_I2S_UDA1380=y
+CONFIG_SND_USE_EA3131=y
+CONFIG_SND_I2C1_CHANNEL_UDA1380=y
+# CONFIG_SND_I2S_RX0_MASTER is not set
+CONFIG_SND_I2S_RX1_MASTER=y
+# CONFIG_SND_I2S_RX0_SLAVE is not set
+# CONFIG_SND_I2S_RX1_SLAVE is not set
+# CONFIG_SND_I2S_TX0_MASTER is not set
+CONFIG_SND_I2S_TX1_MASTER=y
+CONFIG_SND_CODEC_FS256=y
+# CONFIG_SND_CODEC_FS384 is not set
+# CONFIG_SND_CODEC_FS512 is not set
+# CONFIG_SND_CODEC_FS768 is not set
+# CONFIG_SND_CODEC_FS1024 is not set
+# CONFIG_SND_CODEC_NO_FS256_NEEDED is not set
+CONFIG_SND_USE_DMA_LINKLIST=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_UDA1380=y
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_EHSET is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_LPC=y
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+CONFIG_USB_GADGET_FSL_USB2=y
+CONFIG_USB_FSL_USB2=m
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_LPC313x=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -purN linux-2.6.28.2/arch/arm/configs/ea3152_defconfig work_2.6.28.2/arch/arm/configs/ea3152_defconfig
--- linux-2.6.28.2/arch/arm/configs/ea3152_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/configs/ea3152_defconfig	2010-03-16 11:24:33.000000000 -0700
@@ -0,0 +1,1177 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28.2
+# Tue Mar 16 11:24:28 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_CLASSIC_RCU=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_LPC313X=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# LPC313x Implementations
+#
+# CONFIG_MACH_EA313X is not set
+CONFIG_MACH_EA3152=y
+# CONFIG_MACH_VAL3153 is not set
+# CONFIG_MACH_VAL3154 is not set
+CONFIG_LPC3152_AD=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_SCHED_HRTICK is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_VERBOSE=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_UNIX is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_ARPD=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_DEBUG_DRIVER=y
+CONFIG_DEBUG_DEVRES=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+# CONFIG_MTD_DATAFLASH_OTP is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_LPC313X=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+CONFIG_DM9000=y
+CONFIG_DM9000_DEBUGLEVEL=4
+# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_LPC31XX_SERIAL_DMA_SUPPORT is not set
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+CONFIG_I2C_DEBUG_BUS=y
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_LPC313X=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_LPC313X_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_SND_I2S_RX0_MASTER is not set
+# CONFIG_SND_I2S_RX1_MASTER is not set
+# CONFIG_SND_I2S_RX0_SLAVE is not set
+# CONFIG_SND_I2S_RX1_SLAVE is not set
+# CONFIG_SND_I2S_TX0_MASTER is not set
+# CONFIG_SND_I2S_TX1_MASTER is not set
+# CONFIG_SND_CODEC_FS256 is not set
+# CONFIG_SND_CODEC_FS384 is not set
+# CONFIG_SND_CODEC_FS512 is not set
+# CONFIG_SND_CODEC_FS768 is not set
+# CONFIG_SND_CODEC_FS1024 is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_EHSET is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_LPC=y
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+CONFIG_USB_GADGET_FSL_USB2=y
+CONFIG_USB_FSL_USB2=m
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_LPC313x=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -purN linux-2.6.28.2/arch/arm/configs/val3153_defconfig work_2.6.28.2/arch/arm/configs/val3153_defconfig
--- linux-2.6.28.2/arch/arm/configs/val3153_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/configs/val3153_defconfig	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,1210 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28.2
+# Tue Jun 16 14:44:56 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_LPC313X=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# LPC313x Implementations
+#
+# CONFIG_MACH_EA313X is not set
+CONFIG_MACH_VAL3153=y
+# CONFIG_MACH_VAL3154 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_DEBUG_DRIVER=y
+CONFIG_DEBUG_DEVRES=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_PARTITIONS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_PLATFORM=y
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_LPC313x=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+CONFIG_CS89x0=y
+CONFIG_CS89x0_NONISA_IRQ=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+CONFIG_I2C_DEBUG_CHIP=y
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_LPC313x=y
+CONFIG_USB_LPC313x=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=y
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_LPC313x=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+CONFIG_DYNAMIC_PRINTK_DEBUG=y
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -purN linux-2.6.28.2/arch/arm/configs/val3154_defconfig work_2.6.28.2/arch/arm/configs/val3154_defconfig
--- linux-2.6.28.2/arch/arm/configs/val3154_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/configs/val3154_defconfig	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,849 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28.2
+# Mon May  4 13:58:33 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_LPC313X=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# LPC313x Implementations
+#
+# CONFIG_MACH_EA313X is not set
+# CONFIG_MACH_VAL3153 is not set
+CONFIG_MACH_VAL3154=y
+CONFIG_LPC3152_AD=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_DEBUG_DRIVER=y
+CONFIG_DEBUG_DEVRES=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+CONFIG_I2C_DEBUG_CHIP=y
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_LPC=y
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_LPC313x=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -purN linux-2.6.28.2/arch/arm/Kconfig work_2.6.28.2/arch/arm/Kconfig
--- linux-2.6.28.2/arch/arm/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/arch/arm/Kconfig	2010-03-15 16:58:23.000000000 -0700
@@ -549,6 +549,15 @@ config ARCH_MSM
 	  interface to the ARM9 modem processor which runs the baseband stack
 	  and controls some vital subsystems (clock and power control, etc).
 
+config ARCH_LPC313X
+	bool "NXP LPC313X series"
+	select CPU_ARM926T
+	help
+	  Say Y here for systems based on one of the NXP LPC313x & LPC315x
+	  System on a Chip processors.  These CPUs include an ARM926EJS
+	  core with a wide array of integrated devices for
+	  hand-held and low-power applications.
+
 endchoice
 
 source "arch/arm/mach-clps711x/Kconfig"
@@ -627,6 +636,8 @@ source "arch/arm/mach-ks8695/Kconfig"
 
 source "arch/arm/mach-msm/Kconfig"
 
+source "arch/arm/mach-lpc313x/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -876,7 +887,7 @@ config LEDS
 		   ARCH_OMAP || ARCH_P720T || ARCH_PXA_IDP || \
 		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE || \
 		   ARCH_AT91 || ARCH_DAVINCI || \
-		   ARCH_KS8695 || MACH_RD88F5182
+		   ARCH_KS8695 || MACH_RD88F5182 || ARCH_LPC313X
 	help
 	  If you say Y here, the LEDs on your machine will be used
 	  to provide useful information about your current system status.
@@ -891,7 +902,7 @@ config LEDS
 config LEDS_TIMER
 	bool "Timer LED" if (!ARCH_CDB89712 && !ARCH_OMAP) || \
 			    OMAP_OSK_MISTRAL || MACH_OMAP_H2 \
-			    || MACH_OMAP_PERSEUS2
+			    || MACH_OMAP_PERSEUS2 || ARCH_LPC313X
 	depends on LEDS
 	depends on !GENERIC_CLOCKEVENTS
 	default y if ARCH_EBSA110
@@ -910,7 +921,7 @@ config LEDS_CPU
 	bool "CPU usage LED" if (!ARCH_CDB89712 && !ARCH_EBSA110 && \
 			!ARCH_OMAP) \
 			|| OMAP_OSK_MISTRAL || MACH_OMAP_H2 \
-			|| MACH_OMAP_PERSEUS2
+			|| MACH_OMAP_PERSEUS2 || ARCH_LPC313X
 	depends on LEDS
 	help
 	  If you say Y here, the red LED will be used to give a good real
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/cgu.c work_2.6.28.2/arch/arm/mach-lpc313x/cgu.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/cgu.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/cgu.c	2010-03-25 10:59:58.000000000 -0700
@@ -0,0 +1,787 @@
+/*  arch/arm/mach-lpc313x/cgu.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  CGU driver for LPC313x & LPC315x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/cpufreq.h>
+#include <mach/hardware.h>
+#include <linux/err.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <mach/cgu.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+
+/***********************************************************************
+* CGU driver package data
+***********************************************************************/
+static u32 g_clkin_freq[CGU_FIN_SELECT_MAX];
+
+/***********************************************************************
+* CGU driver private functions
+**********************************************************************/
+/***********************************************************************
+* calculate int(log2(i))+1
+*
+* Processing:
+*     This algorithm is used to calculate the above said formula.
+*     This is used to calculate the madd and msub width in frac div
+*     registers.Reasonably fast.
+**********************************************************************/
+static u32 cgu_fdiv_num_bits(unsigned int i)
+{
+	u32 x = 0, y = 16;
+
+	for (; y > 0; y = y >> 1) {
+		if (i >> y) {
+			x += y;
+			i = i >> y;
+		}
+	}
+
+	if (i)
+		x++;
+
+	return x;
+}
+
+static inline u32 f_mult_m_div_n(u32 f_in, u32 m, u32 n)
+{
+	u32 temp;
+	union {
+		unsigned long word[2];
+		unsigned long long longword;
+	} work;
+
+	/* extract low 16 bits ,multiply */
+	work.word[0]=(f_in & 0xFFFF) * m;
+	/* extract high 16 bits ,multiply */
+	work.word[1]=(f_in >> 16)    * m;
+	/* low half of base_clk[1] add to high half of base_clk[0] */
+	temp = (work.word[1] &0xFFFF) << 16;
+	work.word[0] += temp;
+	/* put high half of base_clk[1] in low half */
+	work.word[1] >>= 16; 
+
+	/* detect and correct  overflow from adding bottom 16 bits of high word to top of low word */
+	if (work.word[0] < temp) {
+		work.word[1] ++;
+	}
+	/* do division ignoring remainder */
+	do_div(work.longword, n);
+	return work.word[0];
+}
+
+/***********************************************************************
+*     Decode m value from mdec reg value.
+**********************************************************************/
+static unsigned int pl550_m(int x)
+{
+	int m = 1;
+
+	if ((x<0) || (x>0x40000))
+		return 0;
+	if (x == 0x18003)
+		return 1;
+	if (x == 0x10003)
+		return 2;
+
+	while (x!=0x4000) {
+		int new = (x & 1)^((x >> 1) & 1);
+		x = (x >> 1) | (new << 14);
+		m++;
+		if (m > 0x8000) 
+			return 0;
+	}
+	return m+1;
+}
+
+/***********************************************************************
+*     Decode n value from ndec reg value.
+**********************************************************************/
+static unsigned int pl550_n( int x)
+{
+	int n = 1;
+
+	if ((x<0) || (x>0x400)) 
+		return 0;
+	if ( x == 0x302)
+		return 1;
+	if ( x == 0x202)
+		return 2;
+
+	while (x != 0x80) {
+		int new = (((x&1) ^ ((x>>2)&1)) ^ ((x>>3)&1)) ^ ((x>>4)&1);
+		x = (x>>1) | (new<<7);
+		n++;
+		if (n > 255)
+			return 0;
+	}
+
+	return n+1;
+}
+
+/***********************************************************************
+*     Decode p value from pdec reg value.
+**********************************************************************/
+static unsigned int pl550_p(int x)
+{
+	int p = 1;
+
+	if ((x<0) || (x>0x62))
+		return 0;
+	if (x==0x62)
+		return 1;
+	if (x==0x42)
+		return 2;
+
+	while (x!=0x10) {
+		int new = (x&1)^((x>>2)&1);
+		x = (x>>1)|(new<<4);
+		p++;
+		if (p>31)
+			return 0;
+	}
+
+	return p+1;
+}
+
+/***********************************************************************
+*     Finds ESR index corresponding to the requested clock Id.
+**********************************************************************/
+u32 cgu_clkid2esrid(CGU_CLOCK_ID_T clkid)
+{
+	u32 esrIndex = (u32)clkid;
+
+	switch (clkid)
+	{
+	case CGU_SB_I2SRX_BCK0_ID:
+	case CGU_SB_I2SRX_BCK1_ID:
+	case CGU_SB_SYSCLK_O_ID:
+		/* invalid esr index. No ESR register for these clocks */
+		esrIndex = CGU_INVALID_ID;
+		break;
+
+	case CGU_SB_SPI_CLK_ID:
+	case CGU_SB_SPI_CLK_GATED_ID:
+		esrIndex = esrIndex - 2;
+		break;
+	default:
+		/* do nothing */
+		break;
+	}
+
+	return esrIndex;
+}
+/***********************************************************************
+*     Finds BCR index corresponding to the requested domain Id.
+**********************************************************************/
+u32 cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid)
+{
+	u32 bcridx = CGU_INVALID_ID;
+	switch (domainid)
+	{
+	case CGU_SB_SYS_BASE_ID:
+	case CGU_SB_AHB0_APB0_BASE_ID:
+	case CGU_SB_AHB0_APB1_BASE_ID:
+	case CGU_SB_AHB0_APB2_BASE_ID:
+		bcridx = domainid;
+		break;
+	case CGU_SB_CLK1024FS_BASE_ID:
+		bcridx = CGU_SB_NR_BCR - 1;
+		break;
+	default:
+		bcridx = CGU_INVALID_ID;
+		break;
+	}
+	return bcridx;
+}
+/***********************************************************************
+*     Finds domain index and fractional divider index for the requested
+*	   clock.
+**********************************************************************/
+void cgu_ClkId2DomainId(CGU_CLOCK_ID_T clkid, CGU_DOMAIN_ID_T* pDomainId,
+                        u32* pSubdomainId)
+{
+	u32 esrIndex, esrReg;
+	u32 fracdiv_base = CGU_INVALID_ID;
+
+	/*    1. Get the domain ID */
+
+	if (clkid <= CGU_SYS_LAST) {
+		*pDomainId = CGU_SB_SYS_BASE_ID;
+		fracdiv_base = CGU_SB_BASE0_FDIV_LOW_ID;
+
+	} else if (clkid <= CGU_AHB0APB0_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB0_BASE_ID;
+		fracdiv_base = CGU_SB_BASE1_FDIV_LOW_ID;
+
+	} else 	if (clkid <= CGU_AHB0APB1_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB1_BASE_ID;
+		fracdiv_base = CGU_SB_BASE2_FDIV_LOW_ID;
+
+	} else 	if (clkid <= CGU_AHB0APB2_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB2_BASE_ID;
+		fracdiv_base = CGU_SB_BASE3_FDIV_LOW_ID;
+
+	} else 	if (clkid <= CGU_AHB0APB3_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB3_BASE_ID;
+		fracdiv_base = CGU_SB_BASE4_FDIV_LOW_ID;
+
+	} else 	if (clkid == CGU_PCM_LAST) {
+		*pDomainId = CGU_SB_IPINT_BASE_ID;
+		fracdiv_base = CGU_SB_BASE5_FDIV_LOW_ID;
+
+	} else 	if (clkid == CGU_UART_LAST) {
+		*pDomainId = CGU_SB_UARTCLK_BASE_ID;
+		fracdiv_base = CGU_SB_BASE6_FDIV_LOW_ID;
+
+	} else 	if (clkid <= CGU_CLK1024FS_LAST) {
+		*pDomainId = CGU_SB_CLK1024FS_BASE_ID;
+		fracdiv_base = CGU_SB_BASE7_FDIV_LOW_ID;
+
+	} else 	if (clkid == CGU_I2SRX_BCK0_LAST) {
+		*pDomainId = CGU_SB_I2SRX_BCK0_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+
+	} else 	if (clkid == CGU_I2SRX_BCK1_LAST) {
+		*pDomainId = CGU_SB_I2SRX_BCK1_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+
+	} else 	if (clkid <= CGU_SPI_LAST) {
+		*pDomainId = CGU_SB_SPI_CLK_BASE_ID;
+		fracdiv_base = CGU_SB_BASE10_FDIV_LOW_ID;
+
+	} else {
+		*pDomainId = CGU_SB_SYSCLK_O_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+	}
+
+	*pSubdomainId = CGU_INVALID_ID;
+
+	/* read the clocks ESR to get the fractional divider */
+	esrIndex = cgu_clkid2esrid(clkid);
+
+	if (CGU_INVALID_ID != esrIndex) {
+		/* read the clocks ESR to get the fractional divider */
+		esrReg = CGU_SB->clk_esr[esrIndex];
+
+		/* A clock may not be connected to any sub-domain and it might be
+		connected directly to domain. This is also a valid combination. So,
+		errror should not be returned */
+		if (esrReg & CGU_SB_ESR_ENABLE) {
+			*pSubdomainId = CGU_SB_ESR_SEL_GET(esrReg) + fracdiv_base;
+		}
+	}
+
+}
+
+/***********************************************************************
+* Configure the selected fractional divider
+*********************************************************************/
+/* frac divider config function */
+u32 cgu_fdiv_config(u32 fdId, CGU_FDIV_SETUP_T fdivCfg, u32 enable)
+{
+	u32 conf, maddw, msubw, maxw, fdWidth;
+	int madd, msub;
+
+	/* calculating program values to see if they fit in fractional divider*/
+	madd = fdivCfg.m - fdivCfg.n;
+	msub = -fdivCfg.n;
+
+	/* Find required bit width of madd & msub:*/
+	maddw = cgu_fdiv_num_bits((u32)madd);
+	msubw = cgu_fdiv_num_bits((u32)fdivCfg.n);
+	maxw = (maddw > msubw) ? maddw : msubw;
+	fdWidth = CGU_SB_BASE0_FDIV0_W;
+
+	if (fdId == CGU_SB_BASE7_FDIV_LOW_ID) {
+		/* for Frac divider 17 the bit width is 13 */
+		fdWidth = CGU_SB_BASE7_FDIV0_W;
+	}
+
+	/* Calculate Configure parameter:*/
+	conf = ((((1 << fdWidth) - 1) &
+		(msub << (fdWidth - maxw))) <<
+		(fdWidth + CGU_SB_FDC_MADD_POS)) |
+		(madd << (fdWidth - maxw + CGU_SB_FDC_MADD_POS));
+
+	/* check whther 50% duty cycle is needed for this divider*/
+	if (fdivCfg.stretch)
+		conf |= CGU_SB_FDC_STRETCH;
+	/* check whehter to enable the divider immediately */
+	if (enable)
+		conf |= CGU_SB_FDC_RUN;
+
+	/* finally configure the divider*/
+	CGU_SB->base_fdc[fdId] = conf;
+
+	return conf;
+}
+
+/***********************************************************************
+* CGU driver public functions
+***********************************************************************/
+
+
+
+/***********************************************************************
+* Get frequency of requested base domain clock.
+**********************************************************************/
+u32 cgu_get_base_freq(CGU_DOMAIN_ID_T baseid)
+{
+	/* get base frequency for the domain */
+	return g_clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[baseid])];
+}
+
+/***********************************************************************
+* Set frequency of requested base domain.
+**********************************************************************/
+void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel)
+{
+	u32 baseSCR;
+
+	/* Switch configuration register*/
+	baseSCR = CGU_SB->base_scr[baseid] & ~CGU_SB_SCR_FS_MASK;
+	/* If fs1 is currently enabled set refId to fs2 and enable fs2*/
+	if (CGU_SB->base_ssr[baseid] & CGU_SB_SCR_EN1) {
+		/* check if the selcted frequency is same as requested. If not switch.*/
+		if (CGU_SB->base_fs1[baseid] != fin_sel) {
+			CGU_SB->base_fs2[baseid] = fin_sel;
+
+			/* Don't touch stop bit in SCR register*/
+			CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN2;
+		}
+	} else {
+		/* check if the selcted frequency is same as requested. If not switch.*/
+		if (CGU_SB->base_fs2[baseid] != fin_sel) {
+			CGU_SB->base_fs1[baseid] = fin_sel;
+
+			/* Don't touch stop bit in SCR register*/
+			CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN1;
+		}
+	}
+}
+
+/***********************************************************************
+* Configure the selected HPLL
+* CGU_FIN_SELECT_HPPLL0 : Is used as Audio PLL
+* CGU_FIN_SELECT_HPPLL1 : Is used as System PLL
+**********************************************************************/
+void cgu_hpll_config(CGU_HPLL_ID_T pllid, CGU_HPLL_SETUP_T* pllsetup)
+{
+	CGU_HP_CFG_REGS* hppll;
+	u32 switched_domains = 0;
+	CGU_DOMAIN_ID_T domainId;
+
+	/**********************************************************
+	* switch domains connected to HPLL to FFAST automatically
+	***********************************************************/
+	for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++) {
+		if (CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]) ==
+			(CGU_FIN_SELECT_HPPLL0 + pllid)) {
+			/* switch reference clock in to FFAST */
+			cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+			/* store the domain id to switch back to HPLL */
+			switched_domains |= _BIT(domainId);
+		}
+	}
+
+	/* get PLL regs */
+	hppll = &CGU_CFG->hp[pllid];
+
+	/* disable clock, disable skew enable, power down pll,
+	* (dis/en)able post divider, (dis/en)able pre-divider,
+	* disable free running mode, disable bandsel,
+	* enable up limmiter, disable bypass
+	*/
+	hppll->mode = CGU_HPLL_MODE_PD;
+
+	/* check if pllsetup is valid if not just switch off pll */
+	if (pllsetup != NULL) {
+
+		/* Select fin */
+		hppll->fin_select = pllsetup->fin_select;
+
+		/* M divider */
+		hppll->mdec = pllsetup->mdec & CGU_HPLL_MDEC_MASK;
+
+		/* N divider */
+		hppll->ndec = pllsetup->ndec & CGU_HPLL_NDEC_MSK;
+
+		/* P divider */
+		hppll->pdec = pllsetup->pdec & CGU_HPLL_PDEC_MSK;
+
+		/* Set bandwidth */
+		hppll->selr = pllsetup->selr;
+		hppll->seli = pllsetup->seli;
+		hppll->selp = pllsetup->selp;
+
+		/* Power up pll */
+		hppll->mode = (pllsetup->mode & ~CGU_HPLL_MODE_PD) | CGU_HPLL_MODE_CLKEN;
+
+		/* store the estimated freq in driver data for future clk calcs */
+		g_clkin_freq[CGU_FIN_SELECT_HPPLL0 + pllid] = pllsetup->freq;
+
+		/* wait for PLL to lock */
+		while ((hppll->status & CGU_HPLL_STATUS_LOCK) == 0);
+
+		/**********************************************************
+		* switch domains back to HPLL
+		***********************************************************/
+		for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++) {
+			if (switched_domains & _BIT(domainId)) {
+				/* switch reference clock in to HPLL */
+				cgu_set_base_freq(domainId, CGU_FIN_SELECT_HPPLL0 + pllid);
+			}
+		}
+	}
+
+}
+
+/***********************************************************************
+* Set external enable feature for the requested clock
+**********************************************************************/
+void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable)
+{
+	switch (clkid)
+	{
+	case CGU_SB_OTP_PCLK_ID:
+	case CGU_SB_PCM_APB_PCLK_ID:
+	case CGU_SB_EVENT_ROUTER_PCLK_ID:
+	case CGU_SB_ADC_PCLK_ID:
+	case CGU_SB_IOCONF_PCLK_ID:
+	case CGU_SB_CGU_PCLK_ID:
+	case CGU_SB_SYSCREG_PCLK_ID:
+	case CGU_SB_DMA_CLK_GATED_ID:
+	case CGU_SB_SPI_PCLK_GATED_ID:
+	case CGU_SB_SPI_CLK_GATED_ID:
+	case CGU_SB_PCM_CLK_IP_ID:
+	case CGU_SB_PWM_PCLK_REGS_ID:
+		if (enable)
+			CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_EXTEN_EN;
+		else
+			CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+		break;
+		/* force disable for the following clocks */
+	case CGU_SB_I2C0_PCLK_ID:
+	case CGU_SB_I2C1_PCLK_ID:
+	case CGU_SB_WDOG_PCLK_ID:
+	case CGU_SB_UART_APB_CLK_ID:
+	case CGU_SB_LCD_PCLK_ID:
+		CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+		break;
+	default:
+		break;
+	}
+}
+
+/***********************************************************************
+*
+* Function: cgu_get_clk_freq
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+u32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid)
+{
+	u32 freq = 0;
+	CGU_DOMAIN_ID_T domainId;
+	u32 subDomainId;
+	int n, m;
+	u32 fdcVal;
+
+	/* get domain and frac div info for the clock */
+	cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+
+	/* get base frequency for the domain */
+	freq = g_clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId])];
+
+	/* direct connection  has no fraction divider*/
+	if (subDomainId == CGU_INVALID_ID)
+		return freq;
+
+	/* read frac div control register value */
+	fdcVal = CGU_SB->base_fdc[subDomainId];
+
+	if (fdcVal & CGU_SB_FDC_RUN)  { /* Is the fracdiv enabled ?*/
+		/* Yes, so reverse calculation of madd and msub */
+		int msub, madd;
+
+		if (subDomainId != CGU_SB_BASE7_FDIV_LOW_ID) {
+			msub = CGU_SB_FDC_MSUB_GET(fdcVal);
+			madd = CGU_SB_FDC_MADD_GET(fdcVal);
+		} else {
+			msub = CGU_SB_FDC17_MSUB_GET(fdcVal);
+			madd = CGU_SB_FDC17_MADD_GET(fdcVal);
+		}
+
+		/* remove trailing zeros */
+		while (!(msub & 1)  && !(madd & 1)) {
+			madd = madd >> 1;
+			msub = msub >> 1;
+		}
+		/* compute m and n values */
+		n = - msub;
+		m = madd + n;
+		/* check m and n are non-zero values */
+		if ((n == 0) || (m == 0)) {
+			return 0;
+		}
+		/* calculate the frequency based on m and n values */
+		freq = (freq * n) / m ;
+	}
+	/* else There is no fractional divider in the clocks path */
+
+	//printk(KERN_INFO "CGU: Get clock id:%d freq:%d\n", clkid, freq);
+
+	return  freq;
+}
+
+/***********************************************************************
+* Get frequency of requested clock.
+**********************************************************************/
+void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg)
+{
+	CGU_DOMAIN_ID_T domainId;
+	u32 subDomainId, base_freq, bcrId;
+
+	/* get domain and frac div info for the clock */
+	cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+
+	/* direct connection  has no fraction divider*/
+	if (subDomainId != CGU_INVALID_ID) {
+		/* store base freq */
+		base_freq = CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]);
+		/* switch domain to FFAST */
+		cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+		/* check if the domain has a BCR*/
+		bcrId = cgu_DomainId2bcrid(domainId);
+		/* disable all BCRs */
+		if (bcrId != CGU_INVALID_ID) {
+			CGU_SB->base_bcr[bcrId] = 0;
+		}
+		/* change fractional divider */
+		cgu_fdiv_config(subDomainId, fdiv_cfg, 1);
+		/* enable BCRs */
+		if (bcrId != CGU_INVALID_ID) {
+			CGU_SB->base_bcr[bcrId] = CGU_SB_BCR_FD_RUN;
+		}
+		/* switch domain to original base frequency */
+		cgu_set_base_freq(domainId, base_freq);
+	}
+}
+
+/***********************************************************************
+* Get frequency of requested PLL clock.
+**********************************************************************/
+u32 cgu_get_pll_freq(CGU_HPLL_ID_T pll_id, u32 infreq)
+{
+	u32 mdec;     /* 17 bits */
+	u32 ndec;     /* 10 bits */
+	u32 pdec;     /*  7 bits */
+	u32 mode;
+	u32 M = 0;
+	u32 N = 0;
+	u32 P = 0;
+	u32 ofreq = 0;
+
+
+	mdec = CGU_CFG->hp[pll_id].mdec;  /* dec val feedback divider */
+	ndec = CGU_CFG->hp[pll_id].ndec;  /* dec val pre-divider */
+	pdec = CGU_CFG->hp[pll_id].pdec;  /* dec val post-divider */
+	mode = CGU_CFG->hp[pll_id].mode;
+
+	/* calculate clock setting */
+	M = pl550_m( mdec);
+	N = pl550_n( ndec);
+	P = pl550_p( pdec);
+
+	//printk(KERN_INFO "%s decode pll%d m/n/p values\n  (0x%x,0x%x,0x%x decoded to 0x%x,0x%x,0x%x)\n",
+	//	__FUNCTION__, pll_id, mdec, ndec, pdec, M, N, P);
+
+	switch (mode) {
+
+	case 0x01: /* 1d */
+		if ((M==0)||(N==0)||(P==0)) {
+			return 0;
+		}
+
+		ofreq = f_mult_m_div_n(infreq,M,N*P); // (P * N)/M = out
+		break;
+
+	case 0x09: /* 1c */
+		if ((M == 0) || (N == 0)) {
+			printk(KERN_WARNING "%s: decode pll bad m/n values\n",__FUNCTION__);
+			return -1;
+		}
+
+		ofreq = f_mult_m_div_n(infreq,2*M,N);// N/(2*M)  =out
+		break;
+
+	case 0x11: /* 1b */
+		if ((M == 0)||(P == 0)) {
+			printk(KERN_WARNING "%s: decode pll bad m/p values\n",__FUNCTION__);
+			return -1;
+		}
+
+		ofreq = f_mult_m_div_n(infreq,M,P); // P/M  =out
+		break;
+
+	case 0x19: /* 1a */
+		if (M==0) {
+			printk(KERN_WARNING "%s: decode pll bad m value\n",__FUNCTION__);
+			return -1;
+		}
+
+		ofreq = 2 * infreq * M;		//  1/(2*M) =out
+		break;
+
+
+
+	default:
+		if(mode & 4) /* if this bit is set then the PLL is powered down */
+			return 0;
+		else {
+			printk(KERN_WARNING "%s: decode pll unknown mode %x\n",__FUNCTION__, mode);
+			return -1;
+		}
+	}
+
+	return ofreq;
+}
+
+#if defined (CONFIG_DEBUG_FS)
+/*
+ * The debugfs stuff below is mostly optimized away when
+ * CONFIG_DEBUG_FS is not set.
+ */
+static int lpc313x_cgu_clocks_show(struct seq_file *s, void *v)
+{
+	u32 clk_id = CGU_SYS_FIRST;
+	u32 end_id = (CGU_SYSCLK_O_LAST + 1);
+	char* str[2] = { "OFF", " ON"}; 
+
+	while (clk_id < end_id) {
+		seq_printf (s, "clock[%02d] %s(PSR)/%s(PCR) : %d\r\n", clk_id, 
+			str[(CGU_SB->clk_psr[clk_id] & 0x1)], 
+			str[(CGU_SB->clk_pcr[clk_id] & 0x1)], 
+			cgu_get_clk_freq(clk_id));
+		clk_id++;
+	}
+
+	return 0;
+}
+
+static int lpc313x_cgu_clocks_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lpc313x_cgu_clocks_show, inode->i_private);
+}
+
+static const struct file_operations lpc313x_cgu_clocks_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lpc313x_cgu_clocks_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void lpc313x_cgu_init_debugfs(void)
+{
+	struct dentry		*node;
+
+	node = debugfs_create_file("cgu_clks", S_IRUSR, NULL, NULL,
+			&lpc313x_cgu_clocks_fops);
+	if (IS_ERR(node))
+		printk("cgu_init: failed to initialize debugfs for CGU\n");
+
+	return;
+}
+#else
+static void lpc313x_cgu_init_debugfs(void) {}
+#endif
+/***********************************************************************
+* Initialize CGU data structure with PLL frequency passed by the boot 
+* loader.
+**********************************************************************/
+int __init cgu_init(char *str)
+{
+	int i, j;
+	u32 flags;
+	/* disable all non-essential clocks, enabel main clocks and wakeup
+	 * enables.
+	 */
+	for(i = 0; i < CGU_SB_NR_CLK; i++) {
+
+		if (i < 32) {
+			flags = CGU_WKE_CLKS_0_31;
+			j = 0;
+		} else	if (i < 64) {
+			flags = CGU_WKE_CLKS_32_63;
+			j = 32;
+		} else if (i < 96) {
+			flags = CGU_WKE_CLKS_64_92;
+			j = 64;
+		}
+
+		if (flags & _BIT((i - j))) {
+			CGU_SB->clk_pcr[i] |= CGU_SB_PCR_WAKE_EN |
+					CGU_SB_PCR_RUN | CGU_SB_PCR_AUTO;
+		} else {
+			CGU_SB->clk_pcr[i] &= ~(CGU_SB_PCR_WAKE_EN | CGU_SB_PCR_RUN);
+		}
+	}
+	g_clkin_freq[0] = FFAST_CLOCK;
+	g_clkin_freq[1] = 0;
+	g_clkin_freq[2] = 0;
+	g_clkin_freq[3] = 0;
+	g_clkin_freq[4] = 0;
+	g_clkin_freq[5] = cgu_get_pll_freq(CGU_HPLL0_ID, FFAST_CLOCK);
+	g_clkin_freq[6] = cgu_get_pll_freq(CGU_HPLL1_ID, FFAST_CLOCK);
+ 	printk(/*KERN_INFO*/ "cgu_init pll set at %d\n", g_clkin_freq[6]);
+	
+	lpc313x_cgu_init_debugfs();
+
+	return 0;
+}
+
+
+EXPORT_SYMBOL(cgu_get_base_freq);
+EXPORT_SYMBOL(cgu_set_base_freq);
+EXPORT_SYMBOL(cgu_get_clk_freq);
+EXPORT_SYMBOL(cgu_get_pll_freq);
+EXPORT_SYMBOL(cgu_set_subdomain_freq);
+EXPORT_SYMBOL(cgu_hpll_config);
+//EXPORT_SYMBOL(cgu_clk_set_exten);
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/dma.c work_2.6.28.2/arch/arm/mach-lpc313x/dma.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/dma.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/dma.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,550 @@
+/*  arch/arm/mach-lpc313x/dma.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  DMA driver for machines with LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <mach/cgu.h>
+#include <mach/dma.h>
+
+
+static spinlock_t driver_lock = SPIN_LOCK_UNLOCKED; /* to guard state variables */
+
+static inline void lpc313x_dma_lock(void)
+{
+	spin_lock(&driver_lock);
+}
+
+static inline void lpc313x_dma_unlock(void)
+{
+	spin_unlock(&driver_lock);
+}
+
+static struct dma_channel {
+	char *name;
+	dma_cb_t callback_handler;
+	void *data;
+} dma_channels[DMA_MAX_CHANNELS];
+
+static unsigned int     dma_irq_mask = 0xFFFFFFFF;
+static int sg_higher_channel[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static int softirqmask[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static int softirqen = 0;
+
+static int dma_channels_requested = 0;
+
+static inline void dma_increment_usage(void)
+{
+	if (!dma_channels_requested++) {
+		cgu_clk_en_dis(CGU_SB_DMA_CLK_GATED_ID, 1);
+		cgu_clk_en_dis(CGU_SB_DMA_PCLK_ID, 1);
+	}
+}
+static inline void dma_decrement_usage(void)
+{
+	if (!--dma_channels_requested) {
+		cgu_clk_en_dis(CGU_SB_DMA_CLK_GATED_ID, 0);
+		cgu_clk_en_dis(CGU_SB_DMA_PCLK_ID, 0);
+	}
+}
+
+static inline int dma_valid_config(const dma_setup_t *dma_setup)
+{
+	if (!dma_setup)
+		return -EINVAL;
+
+	if (DMA_CFG_GET_RD_SLV_NR(dma_setup->cfg) > DMA_SLV_SDMMC   ||
+	    DMA_CFG_GET_WR_SLV_NR(dma_setup->cfg) > DMA_SLV_SDMMC    ||
+	    DMA_CFG_GET_CMP_CH_NR(dma_setup->cfg) >= DMA_MAX_CHANNELS)
+		return -EINVAL;
+
+	return 0;
+}
+
+int dma_prog_channel (unsigned int chn, dma_setup_t *dma_setup)
+{
+	if ((chn >= DMA_MAX_CHANNELS) || !dma_channels[chn].name ||
+		dma_valid_config(dma_setup) )
+		return -EINVAL;
+	
+	DMACH_SRC_ADDR(chn) = dma_setup->src_address;
+	DMACH_DST_ADDR(chn) = dma_setup->dest_address;
+	DMACH_LEN(chn) = dma_setup->trans_length;
+	DMACH_CFG(chn) = dma_setup->cfg;
+
+	return 0;
+}
+
+int dma_request_channel (char *name, dma_cb_t cb, void *data)
+{
+	unsigned int mask;
+	unsigned int chn;
+	unsigned long flags;
+	dma_setup_t  dma_setup;
+
+	if (!name)
+		return -EINVAL;
+
+	lpc313x_dma_lock();
+
+	memset(&dma_setup, 0, sizeof(dma_setup));
+
+	for (chn = 0, mask = 1; chn < DMA_MAX_CHANNELS; chn++) 
+	{
+		if (!dma_channels[chn].name) 
+		{
+			dma_increment_usage();
+			dma_channels[chn].name = name;
+			if (cb) {
+				dma_channels[chn].callback_handler = cb;
+				dma_channels[chn].data = data;
+			}
+			dma_prog_channel (chn, &dma_setup);
+			local_irq_save(flags);
+		        dma_irq_mask &= ~mask;  /* enable the IRQ: dafault behavior */
+			DMACH_IRQ_MASK = dma_irq_mask;
+			local_irq_restore(flags);
+			lpc313x_dma_unlock();
+			return chn;
+		}
+		mask = mask << 2;
+	}
+	lpc313x_dma_unlock();
+	return -EBUSY;
+}
+
+
+int dma_request_specific_channel (int chn, char *name, void (*cb)(int, dma_irq_type_t, void *), void *data)
+{
+	unsigned long flags;
+	dma_setup_t  dma_setup;
+
+	if (chn >= DMA_MAX_CHANNELS || !name)
+		return -EINVAL;
+
+	if (dma_channels[chn].name) 
+		return -EBUSY;
+
+	lpc313x_dma_lock();
+
+	memset(&dma_setup, 0, sizeof(dma_setup));
+
+	dma_increment_usage();
+	dma_channels[chn].name = name;
+	if (cb) {
+		dma_channels[chn].callback_handler = cb;
+		dma_channels[chn].data = data;
+	}
+	dma_prog_channel (chn, &dma_setup);
+	local_irq_save(flags);
+	dma_irq_mask &= ~(1 << (2 * chn));  /* enable the IRQ: dafault behavior */
+	DMACH_IRQ_MASK = dma_irq_mask;
+	local_irq_restore(flags);
+	lpc313x_dma_unlock();
+	return chn;
+}
+
+
+int dma_set_irq_mask(unsigned int chn, int half_int, int fin_int)
+{
+	unsigned long flags;
+
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	lpc313x_dma_lock();
+	local_irq_save(flags);
+
+	if (fin_int)
+		dma_irq_mask |= (1 << (chn * 2));
+	else
+		dma_irq_mask &= ~(1 << (chn * 2));
+
+	if  (half_int)
+		dma_irq_mask |= (1 << (chn * 2 + 1));
+	else
+		dma_irq_mask &= ~(1 << (chn * 2 + 1));
+
+	DMACH_IRQ_MASK = dma_irq_mask;
+
+	local_irq_restore(flags);
+	lpc313x_dma_unlock();
+
+	return 0;
+}
+
+int dma_start_channel (unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	DMACH_EN(chn) = 1;
+	return 0;
+}
+
+int dma_stop_channel (unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	DMACH_EN(chn) = 0;
+	return 0;
+}
+
+int dma_stop_channel_sg (unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	/* Disable the companion channel only */
+	DMACH_EN(chn - 1) = 0;
+	return 0;
+}
+
+int dma_release_channel (unsigned int chn)
+{
+	unsigned int mask = (0x3 << (chn * 2));
+	unsigned long flags;
+
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	lpc313x_dma_lock();
+	
+	local_irq_save(flags);
+
+	/* Otherwise an unexpected interrupt can occur when the channel is reallocated for another purpose */
+	DMACH_IRQ_STATUS = mask;
+	dma_irq_mask |= mask;
+	DMACH_IRQ_MASK = dma_irq_mask;
+	/* reset counter */
+	DMACH_TCNT(chn) = 0;
+	local_irq_restore(flags);
+
+	dma_channels[chn].name = NULL;
+	dma_channels[chn].callback_handler = NULL;
+	dma_channels[chn].data = NULL;
+
+	lpc313x_dma_unlock();
+	dma_decrement_usage();
+	
+	return 0;
+}
+
+static irqreturn_t dma_irq_handler (int irq, void *dev_id)
+{
+	unsigned int mask;
+	unsigned int chn;
+	unsigned int dma_irq_status;
+
+	dma_irq_status = DMACH_IRQ_STATUS;
+	dma_irq_status &= ~dma_irq_mask;
+
+	for (chn = 0, mask = 1; chn < DMA_MAX_CHANNELS; chn++) {
+		if (dma_irq_status & mask) {
+			DMACH_IRQ_STATUS = mask;
+			if (dma_channels[chn].callback_handler)
+				(dma_channels[chn].callback_handler) 
+					(chn, DMA_IRQ_FINISHED, dma_channels[chn].data);
+		}
+		mask = mask << 1;
+		if (dma_irq_status & mask) {
+			DMACH_IRQ_STATUS = mask;
+			if (dma_channels[chn].callback_handler)
+				(dma_channels[chn].callback_handler) 
+					(chn, DMA_IRQ_HALFWAY, dma_channels[chn].data);
+		}
+		mask = mask << 1;
+	}
+
+	if (dma_irq_status & DMA_IRQS_SOFT) { /* Soft int */ 
+		DMACH_IRQ_STATUS = DMA_IRQS_SOFT;
+		for (chn = 0; chn < DMA_MAX_CHANNELS; chn++) {
+			if (sg_higher_channel[chn] && softirqmask[chn] &&
+				dma_channels[sg_higher_channel[chn]].callback_handler)
+			(dma_channels[sg_higher_channel[chn]].callback_handler)
+				(sg_higher_channel[chn], DMA_IRQ_SOFTINT,
+				dma_channels[sg_higher_channel[chn]].data);
+		}
+	}
+
+	if (dma_irq_status & DMA_IRQS_ABORT) { /* DMA abort */
+		printk(KERN_WARNING "DMA abort signalled\n");
+		DMACH_IRQ_STATUS = DMA_IRQS_ABORT;
+		for (chn = 0; chn < DMA_MAX_CHANNELS; chn++)
+			if (dma_channels[chn].callback_handler)
+				(dma_channels[chn].callback_handler) 
+					(chn, DMA_IRQ_DMAABORT, dma_channels[chn].data);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int dma_read_counter (unsigned int chn, unsigned int * pcnt)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+	*pcnt = DMACH_TCNT(chn);
+	return 0;
+}
+
+int dma_write_counter (unsigned int chn, u32 cnt)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+	DMACH_TCNT(chn) = cnt;
+	return 0;
+}
+
+
+int dma_current_state (unsigned int   chn,
+                        unsigned int * psrc,
+                        unsigned int * pdst,
+                        unsigned int * plen,
+                        unsigned int * pcfg,
+                        unsigned int * pena,
+                        unsigned int * pcnt)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	*psrc = DMACH_SRC_ADDR(chn);
+	*pdst = DMACH_DST_ADDR(chn);
+	*plen  = DMACH_LEN(chn);
+	*pcfg = DMACH_CFG(chn);
+	*pena = DMACH_EN(chn);
+	*pcnt  = DMACH_TCNT(chn);
+	return 0;
+}
+
+int dma_request_sg_channel (char *name, dma_cb_t cb, void *data, int usesoftirq)
+{
+	unsigned int chn;
+	unsigned long flags;
+	dma_setup_t  dma_setup;
+
+	if (!name)
+		return -EINVAL;
+
+	if (softirqen & usesoftirq)
+		return -EBUSY;
+
+	lpc313x_dma_lock();
+
+	for (chn = 0; chn < DMA_MAX_CHANNELS - 1; chn++) 
+		if (!dma_channels[chn].name && !dma_channels[chn + 1].name) {
+			sg_higher_channel[chn] = chn + 1;
+			break;
+		}
+
+	if (!sg_higher_channel[chn]) {
+		lpc313x_dma_unlock();
+		return -EBUSY;
+	}
+
+	memset(&dma_setup, 0, sizeof(dma_setup));
+
+	dma_increment_usage();
+	dma_channels[sg_higher_channel[chn]].name = name;
+	dma_channels[sg_higher_channel[chn] - 1].name = name;
+
+	if (cb) {
+		dma_channels[sg_higher_channel[chn]].callback_handler = cb;
+		dma_channels[sg_higher_channel[chn]].data = data;
+	}
+	dma_prog_channel (sg_higher_channel[chn], &dma_setup);
+
+	if (usesoftirq) {
+		local_irq_save(flags);
+		softirqen = 1;
+		softirqmask[chn] = 1;
+		dma_irq_mask &= ~DMA_IRQS_SOFT;  /* enable the soft IRQ */
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
+	}
+
+	lpc313x_dma_unlock();
+
+	return sg_higher_channel[chn];
+}
+
+int dma_request_specific_sg_channel (int chn, char *name, dma_cb_t cb, void *data, int usesoftirq)
+{
+	unsigned long flags;
+	dma_setup_t  dma_setup;
+
+	if (!name)
+		return -EINVAL;
+
+	if (softirqen & usesoftirq)
+		return -EBUSY;
+
+	if (sg_higher_channel[chn] || dma_channels[chn].name || dma_channels[chn - 1].name)
+		return -EBUSY;
+
+	lpc313x_dma_lock();
+	
+	sg_higher_channel[chn] = chn;
+
+	memset(&dma_setup, 0, sizeof(dma_setup));
+
+	dma_increment_usage();
+	dma_channels[sg_higher_channel[chn]].name = name;
+	dma_channels[sg_higher_channel[chn] - 1].name = name;
+
+	if (cb) {
+		dma_channels[sg_higher_channel[chn]].callback_handler = cb;
+		dma_channels[sg_higher_channel[chn]].data = data;
+	}
+	dma_prog_channel (sg_higher_channel[chn], &dma_setup);
+
+	if (usesoftirq) {
+		local_irq_save(flags);
+		softirqen = 1;
+		softirqmask[chn] = 1;
+		dma_irq_mask &= ~DMA_IRQS_SOFT;  /* enable the soft IRQ */
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
+	}
+
+	return sg_higher_channel[chn];
+}
+
+int dma_prog_sg_channel(int chn, u32 dma_sg_list)
+{
+	u32 dma_config;
+
+	if (chn >= DMA_MAX_CHANNELS)
+		return -EINVAL;
+
+	dma_config = DMA_CFG_CMP_CH_EN | DMA_CFG_CMP_CH_NR(chn - 1);
+
+	lpc313x_dma_lock();
+	DMACH_SRC_ADDR(chn) = dma_sg_list;
+	DMACH_DST_ADDR(chn) = DMACH_ALT_PHYS(chn - 1);
+	DMACH_LEN(chn) = 0x4;
+	DMACH_CFG(chn) = dma_config;
+	lpc313x_dma_unlock();
+
+	return 0;
+}
+
+int dma_channel_enabled(unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	return (DMACH_EN(chn) & 1);
+}
+
+static int __init lpc313x_dma_init (void)
+{
+	int ret = 0;
+
+	memset(dma_channels, 0, sizeof(struct dma_channel) * DMA_MAX_CHANNELS);
+
+	dma_irq_mask = 0xFFFFFFFF;
+	DMACH_IRQ_MASK = dma_irq_mask;
+	ret = request_irq (IRQ_DMA, dma_irq_handler, 0, "DMAC", NULL);
+	if (ret)
+		printk (KERN_ERR "request_irq() returned error %d\n", ret);
+
+	return ret;
+}
+
+int dma_release_sg_channel (unsigned int chn)
+{
+	unsigned long flags;
+
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	lpc313x_dma_lock();
+
+	if (softirqmask[chn] != 0) {
+		local_irq_save(flags);
+		softirqen = 0;
+		softirqmask[chn] = 0;
+		dma_irq_mask |= DMA_IRQS_SOFT;
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
+	}
+	
+	dma_channels[chn].name = NULL;
+	dma_channels[chn].callback_handler = NULL;
+	dma_channels[chn].data = NULL;
+	
+	chn--;
+	dma_channels[chn].name = NULL;
+	dma_channels[chn].callback_handler = NULL;
+	dma_channels[chn].data = NULL;
+	
+	sg_higher_channel[chn] = 0;
+
+	lpc313x_dma_unlock();
+	dma_decrement_usage();
+	return 0;
+}
+int dma_prepare_sg_list(int n, dma_sg_ll_t * sg)
+{
+    /* fixed me: not yet implement */
+    return 0;
+}
+
+device_initcall(lpc313x_dma_init);
+
+
+EXPORT_SYMBOL(dma_prog_channel);
+EXPORT_SYMBOL(dma_request_channel);
+EXPORT_SYMBOL(dma_request_specific_channel);
+EXPORT_SYMBOL(dma_start_channel);
+EXPORT_SYMBOL(dma_stop_channel);
+EXPORT_SYMBOL(dma_release_channel);
+EXPORT_SYMBOL(dma_set_irq_mask);
+EXPORT_SYMBOL(dma_read_counter);
+EXPORT_SYMBOL(dma_write_counter);
+EXPORT_SYMBOL(dma_current_state);
+EXPORT_SYMBOL(dma_request_sg_channel);
+EXPORT_SYMBOL(dma_request_specific_sg_channel);
+EXPORT_SYMBOL(dma_prog_sg_channel);
+EXPORT_SYMBOL(dma_release_sg_channel);
+EXPORT_SYMBOL(dma_prepare_sg_list);
+EXPORT_SYMBOL(dma_channel_enabled);
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/ea313x.c work_2.6.28.2/arch/arm/mach-lpc313x/ea313x.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/ea313x.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/ea313x.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,532 @@
+/*  arch/arm/mach-lpc313x/ea313x.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  ea313x board init routines.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dm9000.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <mach/gpio.h>
+#include <mach/i2c.h>
+#include <mach/board.h>
+
+static struct lpc313x_mci_irq_data irq_data = {
+	.irq = IRQ_SDMMC_CD,
+};
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value(GPIO_MI2STX_BCK0);
+}
+
+static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	int level;
+
+	/* enable power to the slot */
+	gpio_set_value(GPIO_MI2STX_DATA0, 0);
+	/* set cd pins as GPIO pins */
+	gpio_direction_input(GPIO_MI2STX_BCK0);
+
+	/* select the opposite level senstivity */
+	level = mci_get_cd(0)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+	/* set card detect irq info */
+	irq_data.data = data;
+	irq_data.irq_hdlr = irqhdlr;
+	set_irq_type(irq_data.irq, level);
+	ret = request_irq(irq_data.irq,
+			ea313x_mci_detect_interrupt,
+			level,
+			"mmc-cd", 
+			&irq_data);
+	/****temporary for PM testing */
+	enable_irq_wake(irq_data.irq);
+
+	return irq_data.irq;
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return 0;
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	/* on current version of EA board the card detect
+	 * pull-up in on switched power side. So can't do
+	 * power management so use the always enable power 
+	 * jumper.
+	 */
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data.irq, &irq_data);
+}
+
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+static struct lpc313x_mci_board ea313x_mci_platform_data = {
+	.num_slots		= 1,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.exit			= mci_exit,
+};
+
+static u64 mci_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_mci_device = {
+	.name		= "lpc313x_mmc",
+	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
+	.dev		= {
+		.dma_mask		= &mci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &ea313x_mci_platform_data,
+	},
+	.resource	= lpc313x_mci_resources,
+};
+
+/*
+ * DM9000 ethernet device
+ */
+#if defined(CONFIG_DM9000)
+static struct resource dm9000_resource[] = {
+	[0] = {
+		.start	= EXT_SRAM1_PHYS,
+		.end	= EXT_SRAM1_PHYS + 0xFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= EXT_SRAM1_PHYS + 0x10000,
+		.end	= EXT_SRAM1_PHYS + 0x100FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= IRQ_DM9000_ETH_INT,
+		.end	= IRQ_DM9000_ETH_INT,
+		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	}
+};
+/* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive 
+reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
+other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time 
+such as 80 usecs. 
+LPC313x has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
+The latest Apex bootloader pacth makes use of this feture.
+For this to work SYS_MPMC_WTD_DEL0 & SYS_MPMC_WTD_DEL1 should be programmed with MPMC_STWTRD0
+& MPMC_STWTRD1 values. The logic only deactivates the nOE for one clock cycle which is
+11nsec but DM9000 needs 80nsec between nOEs. So lets add some dummy instructions such as
+reading a GPIO register to compensate for extra 70nsec.
+*/
+# define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
+
+static void dm9000_dumpblk(void __iomem *reg, int count)
+{
+	int i;
+	int tmp;
+
+	count = (count + 1) >> 1;
+	for (i = 0; i < count; i++) {
+		DM_IO_DELAY();
+		tmp = readw(reg);
+	}
+}
+
+static void dm9000_inblk(void __iomem *reg, void *data, int count)
+{
+	int i;
+	u16* pdata = (u16*)data;
+	count = (count + 1) >> 1;
+	for (i = 0; i < count; i++) {
+		DM_IO_DELAY();
+		*pdata++ = readw(reg);
+	}
+}
+
+static struct dm9000_plat_data dm9000_platdata = {
+	.flags		= DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM | DM9000_PLATF_SIMPLE_PHY,
+	.dumpblk = dm9000_dumpblk,
+	.inblk = dm9000_inblk,
+};
+
+static struct platform_device dm9000_device = {
+	.name		= "dm9000",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dm9000_resource),
+	.resource	= dm9000_resource,
+	.dev		= {
+		.platform_data	= &dm9000_platdata,
+	}
+};
+static void __init ea_add_device_dm9000(void)
+{
+	/*
+	 * Configure Chip-Select 2 on SMC for the DM9000.
+	 * Note: These timings were calculated for MASTER_CLOCK = 90000000
+	 *  according to the DM9000 timings.
+	 */
+	MPMC_STCONFIG1 = 0x81;
+	MPMC_STWTWEN1 = 1;
+	MPMC_STWTOEN1 = 1;
+	MPMC_STWTRD1 = 4;
+	MPMC_STWTPG1 = 1;
+	MPMC_STWTWR1 = 1;
+	MPMC_STWTTURN1 = 2;
+	/* enable oe toggle between consec reads */
+	SYS_MPMC_WTD_DEL1 = _BIT(5) | 4;
+
+	/* Configure Interrupt pin as input, no pull-up */
+	gpio_direction_input(GPIO_MNAND_RYBN3);
+
+	platform_device_register(&dm9000_device);
+}
+#else
+static void __init ea_add_device_dm9000(void) {}
+#endif /* CONFIG_DM9000 */
+
+
+#if defined (CONFIG_MTD_NAND_LPC313X)
+static struct resource lpc313x_nand_resources[] = {
+	[0] = {
+		.start  = IO_NAND_PHYS,
+		.end	= IO_NAND_PHYS + IO_NAND_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= IO_NAND_BUF_PHYS,
+		.end 	= IO_NAND_BUF_PHYS + IO_NAND_BUF_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start 	= IRQ_NAND_FLASH,
+		.end 	= IRQ_NAND_FLASH,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition ea313x_nand0_partitions[] = {
+	/* The EA3131 board uses the following block scheme:
+	128K: Blocks 0   - 0    - LPC31xx info and bad block table
+	384K: Blocks 1   - 3    - Apex bootloader
+	256K: Blocks 4   - 5    - Apex environment
+	4M:   Blocks 6   - 37   - Kernel image
+	16M:  Blocks 38  - 165  - Ramdisk image (if used)
+	???:  Blocks 166 - end  - Root filesystem/storage */
+	{
+		.name	= "lpc313x-rootfs",
+		.offset	= (BLK_SIZE * 166),
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct lpc313x_nand_timing ea313x_nanddev_timing = {
+	.ns_trsd	= 36,
+	.ns_tals	= 36,
+	.ns_talh	= 12,
+	.ns_tcls	= 36,
+	.ns_tclh	= 12,
+	.ns_tdrd	= 36,
+	.ns_tebidel	= 12,
+	.ns_tch		= 12,
+	.ns_tcs		= 48,
+	.ns_treh	= 24,
+	.ns_trp		= 48,
+	.ns_trw		= 24,
+	.ns_twp		= 36
+};
+
+static struct lpc313x_nand_dev_info ea313x_ndev[] = {
+	{
+		.name		= "nand0",
+		.nr_partitions	= ARRAY_SIZE(ea313x_nand0_partitions),
+		.partitions	= ea313x_nand0_partitions
+	}
+};
+
+static struct lpc313x_nand_cfg ea313x_plat_nand = {
+	.nr_devices	= ARRAY_SIZE(ea313x_ndev),
+	.devices	= ea313x_ndev,
+	.timing		= &ea313x_nanddev_timing,
+	.support_16bit	= 0,
+};
+
+static u64 nand_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_nand_device = {
+	.name		= "lpc313x_nand",
+	.dev		= {
+		.dma_mask		= &nand_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+				.platform_data	= &ea313x_plat_nand,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_nand_resources),
+	.resource	= lpc313x_nand_resources,
+};
+#endif
+
+#if defined(CONFIG_SPI_LPC313X)
+static struct resource lpc313x_spi_resources[] = {
+	[0] = {
+		.start	= SPI_PHYS,
+		.end	= SPI_PHYS + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SPI,
+		.end	= IRQ_SPI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static void spi_set_cs_state(int cs_num, int state)
+{
+	/* Only CS0 is supported, so no checks are needed */
+	(void) cs_num;
+
+	/* Set GPO state for CS0 */
+	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
+}
+
+struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
+{
+	/* SPI CS0 */
+	[0] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs_state,
+	},
+};
+
+struct lpc313x_spi_cfg lpc313x_spidata =
+{
+	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
+	.spics_cfg		= lpc313x_stdspics_cfg,
+};
+
+static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
+static struct platform_device lpc313x_spi_device = {
+	.name		= "spi_lpc313x",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &lpc313x_spi_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data	= &lpc313x_spidata,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
+	.resource	= lpc313x_spi_resources,
+};
+
+/* If both SPIDEV and MTD data flash are enabled with the same chip select, only 1 will work */
+#if defined(CONFIG_SPI_SPIDEV)
+/* SPIDEV driver registration */
+static int __init lpc313x_spidev_register(void)
+{
+	struct spi_board_info info =
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	};
+
+	return spi_register_board_info(&info, 1);
+}
+arch_initcall(lpc313x_spidev_register);
+#endif
+
+#if defined(CONFIG_MTD_DATAFLASH)
+/* MTD Data FLASH driver registration */
+static int __init lpc313x_spimtd_register(void)
+{
+	struct spi_board_info info =
+	{
+		.modalias = "mtd_dataflash",
+		.max_speed_hz = 30000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	};
+
+	return spi_register_board_info(&info, 1);
+}
+arch_initcall(lpc313x_spimtd_register);
+#endif
+#endif
+
+static struct platform_device *devices[] __initdata = {
+	&lpc313x_mci_device,
+#if defined (CONFIG_MTD_NAND_LPC313X)
+	&lpc313x_nand_device,
+#endif
+#if defined(CONFIG_SPI_LPC313X)
+	&lpc313x_spi_device,
+#endif
+};
+
+static struct map_desc ea313x_io_desc[] __initdata = {
+	{
+		.virtual	= io_p2v(EXT_SRAM0_PHYS),
+		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
+		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_USB_PHYS),
+		.pfn		= __phys_to_pfn(IO_USB_PHYS),
+		.length		= IO_USB_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+static struct i2c_board_info ea313x_i2c_devices[] __initdata = {
+	{
+		I2C_BOARD_INFO("pca9532", 0x60),
+	},
+};
+
+#if defined(CONFIG_MACH_EA3152)
+static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
+	{
+		I2C_BOARD_INFO("lpc3152-psu", 0x0C),
+	},
+};
+#endif
+
+
+static void __init ea313x_init(void)
+{
+	lpc313x_init();
+	/* register i2cdevices */
+	lpc313x_register_i2c_devices();
+	
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	/* add DM9000 device */
+	ea_add_device_dm9000();
+	
+	i2c_register_board_info(0, ea313x_i2c_devices,
+		ARRAY_SIZE(ea313x_i2c_devices));
+
+#if defined(CONFIG_MACH_EA3152)
+	i2c_register_board_info(1, ea3152_i2c1_devices,
+		ARRAY_SIZE(ea3152_i2c1_devices));
+#endif
+}
+
+static void __init ea313x_map_io(void)
+{
+	lpc313x_map_io();
+	iotable_init(ea313x_io_desc, ARRAY_SIZE(ea313x_io_desc));
+}
+
+#if defined(CONFIG_MACH_EA3152)
+MACHINE_START(EA3152, "NXP EA3152")
+	/* Maintainer: Durgesh Pattamatta, NXP */
+	.phys_io	= IO_APB01_PHYS,
+	.io_pg_offst	= (io_p2v(IO_APB01_PHYS) >> 18) & 0xfffc,
+	.boot_params	= 0x30000100,
+	.map_io		= ea313x_map_io,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= ea313x_init,
+MACHINE_END
+#endif
+
+#if defined(CONFIG_MACH_EA313X)
+MACHINE_START(EA313X, "NXP EA313X")
+	/* Maintainer: Durgesh Pattamatta, NXP */
+	.phys_io	= IO_APB01_PHYS,
+	.io_pg_offst	= (io_p2v(IO_APB01_PHYS) >> 18) & 0xfffc,
+	.boot_params	= 0x30000100,
+	.map_io		= ea313x_map_io,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= ea313x_init,
+MACHINE_END
+#endif
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/generic.c work_2.6.28.2/arch/arm/mach-lpc313x/generic.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/generic.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/generic.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,269 @@
+/*  arch/arm/mach-lpc313x/generic.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  Common code for machines with LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/console.h>
+#include <linux/serial_8250.h>
+
+#include <asm/errno.h>
+#include <mach/hardware.h>
+
+#include <mach/gpio.h>
+#include <asm/mach/map.h>
+
+/* local functions */
+
+static void lpc313x_uart_pm(struct uart_port * port, unsigned int state,
+			      unsigned int oldstate)
+{
+	switch (state) {
+	case 0:
+		/* Free the pins so that UART IP will take control of it */
+		gpio_free(GPIO_UART_RXD);
+		gpio_free(GPIO_UART_TXD);
+		/*
+		 * Enable the peripheral clock for this serial port.
+		 * This is called on uart_open() or a resume event.
+		 */
+		/* Enable UART base clock */
+		cgu_endis_base_freq(CGU_SB_UARTCLK_BASE_ID, 1);
+
+		/* Enable UART IP clock */
+		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+		break;
+	case 1:
+		/* we can wake the system in this state. So leave clocks on */
+		printk(KERN_INFO "lpc313x_uart_pm: UART can wake\n");
+		break;
+	case 3:
+		/*
+		 * Disable the peripheral clock for this serial port.
+		 * This is called on uart_close() or a suspend event.
+		 */
+		/* Disable UART IP clock */
+		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 0);
+		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 0);
+
+		/* Disable UART base clock */
+		cgu_endis_base_freq(CGU_SB_UARTCLK_BASE_ID, 0);
+
+		/* Free the pins and let GPIO handle it */
+		gpio_request(GPIO_UART_RXD, "uart_rx");
+		gpio_request(GPIO_UART_TXD, "uart_tx");
+
+		gpio_direction_input(GPIO_UART_RXD);
+		gpio_direction_output(GPIO_UART_TXD, 0);
+		break;
+	default:
+		printk(KERN_ERR "lpc313x_uart_pm: unknown pm %d\n", state);
+	}
+
+}
+
+static struct plat_serial8250_port platform_serial_ports[] = {
+	{
+		.membase = (void *)io_p2v(UART_PHYS),
+		.mapbase = (unsigned long)UART_PHYS,
+		.irq = IRQ_UART,
+		.uartclk = XTAL_CLOCK,
+		.regshift = 2,
+		.iotype = UPIO_MEM,
+		.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST,
+		.pm = lpc313x_uart_pm,
+	},
+	{
+		.flags		= 0
+	},
+};
+
+static struct platform_device serial_device = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data = &platform_serial_ports,
+	},
+};
+
+
+static struct platform_device *devices[] __initdata = {
+	&serial_device,
+};
+
+static struct map_desc lpc313x_io_desc[] __initdata = {
+	{
+		.virtual	= io_p2v(IO_INTC_PHYS),
+		.pfn		= __phys_to_pfn(IO_INTC_PHYS),
+		.length		= IO_INTC_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_APB01_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB01_PHYS),
+		.length		= IO_APB01_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_APB2_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB2_PHYS),
+		.length		= IO_APB2_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_APB3_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB3_PHYS),
+		.length		= IO_APB3_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_APB4_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB4_PHYS),
+		.length		= IO_APB4_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_DMA_REG_PHYS),
+		.pfn		= __phys_to_pfn(IO_DMA_REG_PHYS),
+		.length		= IO_DMA_REG_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_MPMC_CFG_PHYS),
+		.pfn		= __phys_to_pfn(IO_MPMC_CFG_PHYS),
+		.length		= IO_MPMC_CFG_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
+		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
+		.length		= IO_NAND_BUF_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_ISRAM0_PHYS),
+		.pfn		= __phys_to_pfn(IO_ISRAM0_PHYS),
+		.length		= IO_ISRAM0_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+void __init lpc313x_map_io(void)
+{
+	iotable_init(lpc313x_io_desc, ARRAY_SIZE(lpc313x_io_desc));
+}
+extern int __init cgu_init(char *str);
+
+int __init lpc313x_init(void)
+{
+	/* cgu init */
+	cgu_init("");
+	/* Switch on the UART clocks */
+	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_IOCONF_PCLK_ID, 1);
+
+	/* Put adc block in low power state.
+	 * Once ADC driver is added this should move to driver.
+	 */
+	SYS_ADC_PD = 1;
+	/* Disable ring oscillators used by Random number generators */
+	SYS_RNG_OSC_CFG = 0;
+
+	/* Mux I2S signals based on selected channel */
+#if defined (CONFIG_SND_I2S_TX0_MASTER)
+	/* I2S TX0 WS, DATA */
+	GPIO_DRV_IP(IOCONF_EBI_I2STX_0, 0x60);
+
+	/* I2S TX0 BCK */
+	GPIO_DRV_IP(IOCONF_EBI_MCI, 0x80);
+#endif
+
+#if defined (CONFIG_SND_I2S_TX1_MASTER)
+	/* I2S TX1 BCK, WS, DATA */
+	GPIO_DRV_IP(IOCONF_I2STX_1, 0x7);
+#endif
+
+#if defined (CONFIG_SND_I2S_RX0_MASTER) | defined (CONFIG_SND_I2S_RX0_SLAVE)
+	/* I2S RX0 BCK, WS, DATA */
+	GPIO_DRV_IP(IOCONF_I2SRX_0, 0x7);
+#endif
+#if defined (CONFIG_SND_I2S_RX1_MASTER) | defined (CONFIG_SND_I2S_RX1_SLAVE)
+	/* I2S RX1 BCK, WS, DATA */
+	GPIO_DRV_IP(IOCONF_I2SRX_1, 0x7);
+#endif
+	/* AUDIO CODEC CLOCK (256FS) */
+	GPIO_DRV_IP(IOCONF_I2STX_1, 0x8);
+
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+
+#if defined(CONFIG_SERIAL_8250_CONSOLE)
+static int __init lpc313x_init_console(void)
+{
+	static __initdata char serr[] =
+		KERN_ERR "Serial port #%u setup failed\n";
+	struct uart_port up;
+	int mul, div;
+
+	/* Switch on the UART clocks */
+	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+
+ 	/*
+	 * Set up serial port #0. Do not use autodetection; the result is
+	 * not what we want.
+ 	 */
+	memset(&up, 0, sizeof(up));
+
+	up.membase = (char *) io_p2v(UART_PHYS);
+	up.mapbase = (unsigned long)UART_PHYS,
+	up.irq = IRQ_UART;
+	up.uartclk = XTAL_CLOCK;
+	/* check what FDR bootloader is using */
+	mul = (UART_FDR_REG >> 4) & 0xF;
+	div = UART_FDR_REG & 0xF;
+	if (div != 0)  {
+		up.uartclk = (XTAL_CLOCK * mul) / (mul + div); 
+	} 
+	up.regshift = 2;
+	up.iotype = UPIO_MEM;
+	up.type	= PORT_NXP16750;
+	up.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST;
+	up.line	= 0;
+	platform_serial_ports[0].uartclk = up.uartclk;
+	if (early_serial_setup(&up))
+		printk(serr, up.line);
+
+	return 0;
+}
+console_initcall(lpc313x_init_console);
+
+#endif /*CONFIG_SERIAL_8250_CONSOLE*/
+
+
+
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/gpio.c work_2.6.28.2/arch/arm/mach-lpc313x/gpio.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/gpio.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/gpio.c	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,135 @@
+/*  linux/arch/arm/mach-lpc313x/gpio.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * GPIO driver for LPC313x & LPC315x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#include <asm/errno.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+
+void lpx313x_gpio_func_mode(int gpio)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_RESET(port) = pin; 
+	GPIO_M0_SET(port) = pin;
+
+	raw_local_irq_restore(flags);
+
+}
+
+EXPORT_SYMBOL(lpx313x_gpio_func_mode);
+
+
+
+
+int lpc313x_gpio_direction_output(unsigned gpio, int value)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_SET(port) = pin; 
+
+	if(value) {
+		GPIO_M0_SET(port) = pin;
+	} else {
+		GPIO_M0_RESET(port) = pin;
+	}
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(lpc313x_gpio_direction_output);
+
+
+
+int gpio_is_valid(unsigned gpio)
+{
+	int ret = 1;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin_no = (gpio & GPIO_PIN_MASK);
+
+
+	if ( (gpio & ~(GPIO_PORT_MASK | GPIO_PIN_MASK)) &&
+	     ((port >> 5) > 12)) {
+		return 0;
+	} 
+	switch (port) {
+		case IOCONF_EBI_I2STX_0:
+			if (pin_no > 9)
+				ret = 0;
+			break;
+		case IOCONF_PWM:
+		case IOCONF_CGU:
+			if (pin_no > 0)
+				ret = 0;
+			break;
+		case IOCONF_I2SRX_0:
+		case IOCONF_I2SRX_1:
+			if (pin_no > 2)
+				ret = 0;
+			break;
+		case IOCONF_I2STX_1:
+			if (pin_no > 3)
+				ret = 0;
+			break;
+		case IOCONF_EBI:
+			if (pin_no > 15)
+				ret = 0;
+			break;
+		case IOCONF_GPIO:
+			if (pin_no > 14)
+				ret = 0;
+			break;
+		case IOCONF_UART:
+		case IOCONF_I2C1:
+			if (pin_no > 1)
+				ret = 0;
+			break;
+		case IOCONF_SPI:
+			if (pin_no > 4)
+				ret = 0;
+			break;
+		case IOCONF_NAND_CTRL:
+			if (pin_no > 3)
+				ret = 0;
+			break;
+	}
+	return ret;
+}
+
+EXPORT_SYMBOL(gpio_is_valid);
+
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/i2c.c work_2.6.28.2/arch/arm/mach-lpc313x/i2c.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/i2c.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/i2c.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,161 @@
+/*  linux/arch/arm/mach-lpc313x/i2c.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * I2C initialization for LPC313x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/i2c-pnx.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <mach/hardware.h>
+#include <mach/i2c.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+
+#define LPC313x_I2C0_SLV_ADDR            __REG (I2C0_PHYS + 0x014)
+#define LPC313x_I2C1_SLV_ADDR            __REG (I2C1_PHYS + 0x014)
+
+static int set_clock_run(struct platform_device *pdev)
+{
+	if (pdev->id)
+		cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 1);
+	else
+		cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 1);
+	
+	udelay(2);
+	return 0;
+}
+
+static int set_clock_stop(struct platform_device *pdev)
+{
+	if (pdev->id)
+		cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 0);
+	else
+		cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 0);
+
+	return 0;
+}
+
+static int i2c_lpc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int retval = 0;
+#ifdef CONFIG_PM
+	retval = set_clock_stop(pdev);
+#endif
+	return retval;
+}
+
+static int i2c_lpc_resume(struct platform_device *pdev)
+{
+	int retval = 0;
+#ifdef CONFIG_PM
+	retval = set_clock_run(pdev);
+#endif
+	return retval;
+}
+
+static u32 calculate_input_freq(struct platform_device *pdev)
+{
+	return (FFAST_CLOCK/1000000);
+}
+
+
+static struct i2c_pnx_algo_data lpc_algo_data0 = {
+	.base = I2C0_PHYS,
+	.irq = IRQ_I2C0,
+};
+
+static struct i2c_pnx_algo_data lpc_algo_data1 = {
+	.base = I2C1_PHYS,
+	.irq = IRQ_I2C1,
+};
+
+static struct i2c_adapter lpc_adapter0 = {
+	.name = I2C_CHIP_NAME "0",
+	.algo_data = &lpc_algo_data0,
+};
+static struct i2c_adapter lpc_adapter1 = {
+	.name = I2C_CHIP_NAME "1",
+	.algo_data = &lpc_algo_data1,
+};
+
+static struct i2c_pnx_data i2c0_data = {
+	.suspend = i2c_lpc_suspend,
+	.resume = i2c_lpc_resume,
+	.calculate_input_freq = calculate_input_freq,
+	.set_clock_run = set_clock_run,
+	.set_clock_stop = set_clock_stop,
+	.adapter = &lpc_adapter0,
+};
+
+static struct i2c_pnx_data i2c1_data = {
+	.suspend = i2c_lpc_suspend,
+	.resume = i2c_lpc_resume,
+	.calculate_input_freq = calculate_input_freq,
+	.set_clock_run = set_clock_run,
+	.set_clock_stop = set_clock_stop,
+	.adapter = &lpc_adapter1,
+};
+
+static struct platform_device i2c0_device = {
+	.name = "pnx-i2c",
+	.id = 0,
+	.dev = {
+		.platform_data = &i2c0_data,
+	},
+};
+
+static struct platform_device i2c1_device = {
+	.name = "pnx-i2c",
+	.id = 1,
+	.dev = {
+		.platform_data = &i2c1_data,
+	},
+};
+
+static struct platform_device *devices[] __initdata = {
+	&i2c0_device,
+	&i2c1_device,
+};
+
+void __init lpc313x_register_i2c_devices(void)
+{
+	cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 1);
+	cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 1);
+
+	/* Enable I2C1 signals */
+	GPIO_DRV_IP(IOCONF_I2C1, 0x3);
+
+#if defined (CONFIG_MACH_VAL3153) || defined (CONFIG_MACH_EA313X)
+	/* on EA and VAL boards UDA1380 is connected to I2C1
+	 * whose slave address is same as LPC313x's default slave
+	 * adress causing bus contention errors. So change the 
+	 * deafult slave address register value of LPC313x here.
+	 */
+	LPC313x_I2C0_SLV_ADDR = 0x06E;
+	LPC313x_I2C1_SLV_ADDR = 0x06E;
+#endif
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/board.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/board.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/board.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/board.h	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,151 @@
+/*  arch/arm/mach-lpc313x/generic.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  Defines prototypes for generic init functions LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __MACH_BOARD_H
+#define __MACH_BOARD_H
+
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/mmc/host.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mmc/host.h>
+
+
+extern void __init lpc313x_map_io(void);
+extern void __init lpc313x_init_irq(void);
+extern int __init lpc313x_init(void);
+extern int __init lpc313x_register_i2c_devices(void);
+extern void lpc313x_vbus_power(int enable);
+extern int lpc313x_entering_suspend_mem(void);
+
+
+struct sys_timer;
+extern struct sys_timer lpc313x_timer;
+
+/*
+ * Timing information structure for the NAND interface. Although there are
+ * multiple chip selects for the NAND controller, there is only 1 set of
+ * timing data shared among all chip selects. All the parts should be of
+ * the same type or very similar timings. These values are used to adjust
+ * the NAND timing to the current system clock speed.
+ *
+ * These values are NanoSecond timings. See the LPC31xx Users Guide for
+ * information on what these timings are and set the value for each timing
+ * with the matching value from the NAND device data sheet.
+ */
+struct lpc313x_nand_timing
+{
+	u32 ns_trsd;
+	u32 ns_tals;
+	u32 ns_talh;
+	u32 ns_tcls;
+	u32 ns_tclh;
+	u32 ns_tdrd;
+	u32 ns_tebidel;
+	u32 ns_tch;
+	u32 ns_tcs;
+	u32 ns_treh;
+	u32 ns_trp;
+	u32 ns_trw;
+	u32 ns_twp;
+};
+
+/*
+ * This structure is required for each chip select with an attached device
+ * and partitioning scheme. One of these structures is required for each
+ * device attached to a chip select of the NAND controller.
+ */
+struct lpc313x_nand_dev_info
+{
+	char *name; /* Informational name only */
+	int nr_partitions; /* Number of partitions on this device */
+	struct mtd_partition *partitions; /* Pointer to partition table */
+};
+
+/*
+ * High level NAND configuration structure
+ */
+struct lpc313x_nand_cfg {
+	int nr_devices;
+	struct lpc313x_nand_dev_info *devices;
+	struct lpc313x_nand_timing *timing;
+	int support_16bit;
+};
+
+/*
+ * Specifies behaviour of each supported chip select
+ */
+typedef void (*spi_cs_sel)(int, int);
+struct lpc313x_spics_cfg {
+	/* spi_spo is the serial clock polarity between transfers, 1 = high level,
+	   0 = low */
+	u8 spi_spo;
+	/* spi_sph is the control for clock edge capture, 0 = capture data on 1rst
+	   clock edge, 1 = second edge capture */
+	u8 spi_sph;
+	spi_cs_sel spi_cs_set; /* Sets state of SPI chip select */
+};
+
+/*
+ * Defines the number of chip selects and the cs data
+ */
+struct lpc313x_spi_cfg {
+	u32 num_cs; /* Number of CS supported on this board */
+	/* Array of cs setup data (num_cs entries) */
+	struct lpc313x_spics_cfg *spics_cfg;
+};
+
+#if defined (CONFIG_MACH_VAL3153) 
+#define MAX_MCI_SLOTS		2
+#else
+#define MAX_MCI_SLOTS		1
+#endif
+
+/*
+ * the board-type specific routines
+ */
+struct lpc313x_mci_board {
+	u32 num_slots;
+	u32 detect_delay_ms; /* delay in mS before detecting cards after interrupt */
+	int (*init)(u32 slot_id, irq_handler_t , void *);
+	int (*get_ro)(u32 slot_id);
+	int (*get_cd)(u32 slot_id);
+	int (*get_ocr)(u32 slot_id);
+	int (*get_bus_wd)(u32 slot_id);
+	/*
+	 * Enable power to selected slot and set voltage to desired level.
+	 * Voltage levels are specified using MMC_VDD_xxx defines defined
+	 * in linux/mmc/host.h file.
+	 */
+	void (*setpower)(u32 slot_id, u32 volt);
+	void (*exit)(u32 slot_id);
+	void (*select_slot)(u32 slot_id);
+};
+
+struct lpc313x_mci_irq_data {
+	u32 irq;
+	irq_handler_t irq_hdlr;
+	void* data;
+};
+
+#endif /*__MACH_BOARD_H*/
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/cgu.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/cgu.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/cgu.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/cgu.h	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,638 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/cgu.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  CGU defines and register structures for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef LPC313X_CGU_H
+#define LPC313X_CGU_H
+
+ /***********************************************************************
+ * CGU register definitions
+ **********************************************************************/
+#define CGU_SB_NR_BASE     12
+#define CGU_SB_NR_CLK      92
+#define CGU_SB_NR_BCR      5
+#define CGU_SB_NR_FRACDIV  24
+#define CGU_SB_NR_DYN_FDIV 7
+#define CGU_SB_NR_ESR      89
+#define CGU_SB_BASE0_FDIV_CNT           7
+#define CGU_SB_BASE0_FDIV_LOW_ID        0
+#define CGU_SB_BASE0_FDIV_HIGH_ID       6
+#define CGU_SB_BASE0_FDIV0_W            8
+
+#define CGU_SB_BASE1_FDIV_CNT           2
+#define CGU_SB_BASE1_FDIV_LOW_ID        7
+#define CGU_SB_BASE1_FDIV_HIGH_ID       8
+
+#define CGU_SB_BASE2_FDIV_CNT           2
+#define CGU_SB_BASE2_FDIV_LOW_ID        9
+#define CGU_SB_BASE2_FDIV_HIGH_ID       10
+
+#define CGU_SB_BASE3_FDIV_CNT           3
+#define CGU_SB_BASE3_FDIV_LOW_ID        11
+#define CGU_SB_BASE3_FDIV_HIGH_ID       13
+
+#define CGU_SB_BASE4_FDIV_CNT           1
+#define CGU_SB_BASE4_FDIV_LOW_ID        14
+#define CGU_SB_BASE4_FDIV_HIGH_ID       14
+
+#define CGU_SB_BASE5_FDIV_CNT           1
+#define CGU_SB_BASE5_FDIV_LOW_ID        15
+#define CGU_SB_BASE5_FDIV_HIGH_ID       15
+
+#define CGU_SB_BASE6_FDIV_CNT           1
+#define CGU_SB_BASE6_FDIV_LOW_ID        16
+#define CGU_SB_BASE6_FDIV_HIGH_ID       16
+
+#define CGU_SB_BASE7_FDIV_CNT           6
+#define CGU_SB_BASE7_FDIV_LOW_ID        17
+#define CGU_SB_BASE7_FDIV_HIGH_ID       22
+#define CGU_SB_BASE7_FDIV0_W            13
+
+#define CGU_SB_BASE10_FDIV_CNT          1
+#define CGU_SB_BASE10_FDIV_LOW_ID       23
+#define CGU_SB_BASE10_FDIV_HIGH_ID      23
+
+
+typedef volatile struct
+{
+  /* Switches controls */
+  volatile u32 base_scr[12]; /* Switch control */
+  volatile u32 base_fs1[12]; /* Frequency select side 1 */
+  volatile u32 base_fs2[12]; /* Frequency select side 2 */
+  volatile u32 base_ssr[12]; /* Switch status */
+  /* Clock enable controls (positive and inverted clock pairs share control register)*/
+  volatile u32 clk_pcr[92]; /* power control */
+  volatile u32 clk_psr[92]; /* power status */
+  /* enable select from fractional dividers (positive and inverted clock pairs share esr)*/
+  volatile u32 clk_esr[89]; /* enable select */
+  /* Base controls, currently only fd_run (base wide fractional divider enable) bit.*/
+  volatile u32 base_bcr[5]; /* Base control */
+  /* Fractional divider controls & configuration*/
+  volatile u32 base_fdc[24]; /* Fractional divider config & ctrl */
+  volatile u32 base_dyn_fdc[7]; /* Fractional divider config & ctrl for dynamic fracdivs */
+  volatile u32 base_dyn_sel[7]; /* Fractional divider register for selecting an external signal to trigger high-speed operation*/
+} CGU_SB_REGS_T;
+
+/* ----------------
+* HP PLL Registers
+* ----------------
+*/
+typedef volatile struct
+{
+  volatile u32 fin_select;
+  volatile u32 mdec;
+  volatile u32 ndec;
+  volatile u32 pdec;
+  volatile u32 mode;
+  volatile u32 status;
+  volatile u32 ack;
+  volatile u32 req;
+  volatile u32 inselr;
+  volatile u32 inseli;
+  volatile u32 inselp;
+  volatile u32 selr;
+  volatile u32 seli;
+  volatile u32 selp;
+} CGU_HP_CFG_REGS;
+
+typedef volatile struct
+{
+  volatile u32 powermode;
+  volatile u32 wd_bark;
+  volatile u32 ffast_on;
+  volatile u32 ffast_bypass;
+  volatile u32 resetn_soft[56];
+  CGU_HP_CFG_REGS hp[2];
+} CGU_CONFIG_REGS;
+
+#define CGU_SB    ((CGU_SB_REGS_T*) io_p2v(CGU_SB_PHYS))
+#define CGU_CFG   ((CGU_CONFIG_REGS*) io_p2v(CGU_CFG_PHYS))
+
+
+/* Switch Control Register */
+#define CGU_SB_SCR_EN1              _BIT(0)
+#define CGU_SB_SCR_EN2              _BIT(1)
+#define CGU_SB_SCR_RST              _BIT(2)
+#define CGU_SB_SCR_STOP             _BIT(3)
+#define CGU_SB_SCR_FS_MASK          0x3
+
+/* Switch Status Register */
+#define CGU_SB_SSR_FS_GET(x)        ( ((x) >> 2) & 0x7)
+/* Power Control Register */
+#define CGU_SB_PCR_RUN              _BIT(0)
+#define CGU_SB_PCR_AUTO             _BIT(1)
+#define CGU_SB_PCR_WAKE_EN          _BIT(2)
+#define CGU_SB_PCR_EXTEN_EN         _BIT(3)
+#define CGU_SB_PCR_ENOUT_EN         _BIT(4)
+/* Power Status Register */
+#define CGU_SB_PSR_ACTIVE           _BIT(0)
+#define CGU_SB_PSR_WAKEUP           _BIT(1)
+/* Enable Select Register */
+#define CGU_SB_ESR_ENABLE           _BIT(0)
+#define CGU_SB_ESR_SELECT(x)        _SBF(1, (x))
+#define CGU_SB_ESR_SEL_GET(x)       (((x) >> 1) & 0x7)
+
+/* Base control Register */
+#define CGU_SB_BCR_FD_RUN           _BIT(0)
+/* Fractional Divider Configuration Register */
+#define CGU_SB_FDC_RUN              _BIT(0)
+#define CGU_SB_FDC_RESET            _BIT(1)
+#define CGU_SB_FDC_STRETCH          _BIT(2)
+#define CGU_SB_FDC_MADD(x)          _SBF( 3, ((x) & 0xFF))
+#define CGU_SB_FDC_MSUB(x)          _SBF(11, ((x) & 0xFF))
+#define CGU_SB_FDC17_MADD(x)        _SBF( 3, ((x) & 0x1FFF))
+#define CGU_SB_FDC17_MSUB(x)        _SBF(16, ((x) & 0x1FFF))
+#define CGU_SB_FDC_MADD_GET(x)      (((x) >> 3) & 0xFF)
+#define CGU_SB_FDC_MSUB_GET(x)      ((((x) >> 11) & 0xFF) | 0xFFFFFF00)
+#define CGU_SB_FDC17_MADD_GET(x)    (((x) >> 3) & 0x1FFF)
+#define CGU_SB_FDC17_MSUB_GET(x)    ((((x) >> 16) & 0x1FFF) | 0xFFFFE000)
+#define CGU_SB_FDC_MADD_POS         3
+
+/* Dynamic Fractional Divider Configuration Register */
+#define CGU_SB_DYN_FDC_RUN          _BIT(0)
+#define CGU_SB_DYN_FDC_ALLOW        _BIT(1)
+#define CGU_SB_DYN_FDC_STRETCH      _BIT(2)
+
+/**********************************************************************
+* Register description of POWERMODE
+**********************************************************************/
+#define CGU_POWERMODE_MASK     0x3
+#define CGU_POWERMODE_NORMAL   0x1
+#define CGU_POWERMODE_WAKEUP   0x3
+
+/**********************************************************************
+* Register description of WD_BARK
+**********************************************************************/
+#define CGU_WD_BARK            0x1
+
+/**********************************************************************
+* Register description of FFAST_ON
+**********************************************************************/
+#define CGU_FFAST_ON           0x1
+
+/**********************************************************************
+* Register description of FFAST_BYPASS
+**********************************************************************/
+#define CGU_FFAST_BYPASS       0x1
+
+/**********************************************************************
+* Register description of soft reset registers
+**********************************************************************/
+#define CGU_CONFIG_SOFT_RESET  0x1
+
+/**********************************************************************
+* Register description of HP_FIN_SELECT
+**********************************************************************/
+#define CGU_HPLL_FIN_SEL_MASK       0xf
+#define CGU_FIN_SELECT_FFAST        0x0
+#define CGU_FIN_SELECT_XT_DAI_BCK0  0x1
+#define CGU_FIN_SELECT_XT_DAI_WS0   0x2
+#define CGU_FIN_SELECT_XT_DAI_BCK1  0x3
+#define CGU_FIN_SELECT_XT_DAI_WS1   0x4
+#define CGU_FIN_SELECT_HPPLL0       0x5
+#define CGU_FIN_SELECT_HPPLL1       0x6
+#define CGU_FIN_SELECT_MAX          7
+
+/**********************************************************************
+* Register description of HP_MDEC
+**********************************************************************/
+#define CGU_HPLL_MDEC_MASK          0x1ffff
+/**********************************************************************
+* Register description of HP_NDEC
+**********************************************************************/
+#define CGU_HPLL_NDEC_MSK           0x3ff
+/**********************************************************************
+* Register description of HP_PDEC
+**********************************************************************/
+#define CGU_HPLL_PDEC_MSK           0x7f
+/**********************************************************************
+* Register description of HP_MODE
+**********************************************************************/
+#define CGU_HPLL_MODE_POR_VAL       0x6
+#define CGU_HPLL_MODE_CLKEN         _BIT(0)
+#define CGU_HPLL_MODE_SKEWEN        _BIT(1)
+#define CGU_HPLL_MODE_PD            _BIT(2)
+#define CGU_HPLL_MODE_DIRECTO       _BIT(3)
+#define CGU_HPLL_MODE_DIRECTI       _BIT(4)
+#define CGU_HPLL_MODE_FRM           _BIT(5)
+#define CGU_HPLL_MODE_BANDSEL       _BIT(6)
+#define CGU_HPLL_MODE_LIMUP_OFF     _BIT(7)
+#define CGU_HPLL_MODE_BYPASS        _BIT(8)
+
+/**********************************************************************
+* Register description of HP1_STATUS
+**********************************************************************/
+#define CGU_HPLL_STATUS_FR          _BIT(1)
+#define CGU_HPLL_STATUS_LOCK        _BIT(0)
+
+/**********************************************************************
+* Register description of HP_ACK & HP_REQ
+**********************************************************************/
+#define CGU_HPLL_ACK_P              _BIT(2)
+#define CGU_HPLL_ACK_N              _BIT(1)
+#define CGU_HPLL_ACK_M              _BIT(0)
+
+/**********************************************************************
+* Register description of HP1_INSELR
+**********************************************************************/
+#define CGU_HPLL_INSELR_MASK        0xf
+/**********************************************************************
+* Register description of HP1_INSELI
+**********************************************************************/
+#define CGU_HPLL_INSELI_MASK        0x3f
+/**********************************************************************
+* Register description of HP1_INSELP
+**********************************************************************/
+#define CGU_HPLL_INSELP_MASK        0x1f
+/**********************************************************************
+* Register description of HP1_SELR
+**********************************************************************/
+#define CGU_HPLL_SELR_MASK          0xf
+/**********************************************************************
+* Register description of HP1_SELI
+**********************************************************************/
+#define CGU_HPLL_SELI_MASK          0x3f
+/**********************************************************************
+* Register description of HP1_SELP
+**********************************************************************/
+#define CGU_HPLL_SELP_MASK          0x1f
+
+/***********************************************************************
+* Clock domain base id's
+***********************************************************************/
+typedef enum
+{
+  CGU_SB_SYS_BASE_ID = 0,
+  CGU_SB_BASE_FIRST = CGU_SB_SYS_BASE_ID,
+  CGU_SB_AHB0_APB0_BASE_ID,
+  CGU_SB_AHB0_APB1_BASE_ID,
+  CGU_SB_AHB0_APB2_BASE_ID,
+  CGU_SB_AHB0_APB3_BASE_ID,
+  CGU_SB_IPINT_BASE_ID,
+  CGU_SB_UARTCLK_BASE_ID,
+  CGU_SB_CLK1024FS_BASE_ID,
+  CGU_SB_I2SRX_BCK0_BASE_ID,
+  CGU_SB_I2SRX_BCK1_BASE_ID,
+  CGU_SB_SPI_CLK_BASE_ID,
+  CGU_SB_SYSCLK_O_BASE_ID,
+  CGU_SB_BASE_LAST = CGU_SB_SYSCLK_O_BASE_ID
+} CGU_DOMAIN_ID_T;
+
+/***********************************************************************
+// Clock id's (= clkid in address calculation)
+***********************************************************************/
+typedef enum
+{
+  /* domain 0 = SYS_BASE */
+  CGU_SB_APB0_CLK_ID = 0,
+  CGU_SYS_FIRST = CGU_SB_APB0_CLK_ID,
+  CGU_SB_APB1_CLK_ID,
+  CGU_SB_APB2_CLK_ID,
+  CGU_SB_APB3_CLK_ID,
+  CGU_SB_APB4_CLK_ID,
+  CGU_SB_AHB2INTC_CLK_ID,
+  CGU_SB_AHB0_CLK_ID,
+  CGU_SB_EBI_CLK_ID,
+  CGU_SB_DMA_PCLK_ID,
+  CGU_SB_DMA_CLK_GATED_ID,
+  CGU_SB_NANDFLASH_S0_CLK_ID,
+  CGU_SB_NANDFLASH_ECC_CLK_ID,
+  CGU_SB_NANDFLASH_AES_CLK_ID, /* valid on LPC3153 & LPC3154 only */
+  CGU_SB_NANDFLASH_NAND_CLK_ID,
+  CGU_SB_NANDFLASH_PCLK_ID,
+  CGU_SB_CLOCK_OUT_ID,
+  CGU_SB_ARM926_CORE_CLK_ID,
+  CGU_SB_ARM926_BUSIF_CLK_ID,
+  CGU_SB_ARM926_RETIME_CLK_ID,
+  CGU_SB_SD_MMC_HCLK_ID,
+  CGU_SB_SD_MMC_CCLK_IN_ID,
+  CGU_SB_USB_OTG_AHB_CLK_ID,
+  CGU_SB_ISRAM0_CLK_ID,
+  CGU_SB_RED_CTL_RSCLK_ID,
+  CGU_SB_ISRAM1_CLK_ID,
+  CGU_SB_ISROM_CLK_ID,
+  CGU_SB_MPMC_CFG_CLK_ID,
+  CGU_SB_MPMC_CFG_CLK2_ID,
+  CGU_SB_MPMC_CFG_CLK3_ID,
+  CGU_SB_INTC_CLK_ID,
+  CGU_SYS_LAST = CGU_SB_INTC_CLK_ID,
+
+  /* domain 1 = AHB0APB0_BASE */
+  CGU_SB_AHB2APB0_ASYNC_PCLK_ID,
+  CGU_AHB0APB0_FIRST = CGU_SB_AHB2APB0_ASYNC_PCLK_ID,
+  CGU_SB_EVENT_ROUTER_PCLK_ID,
+  CGU_SB_ADC_PCLK_ID,
+  CGU_SB_ADC_CLK_ID,
+  CGU_SB_WDOG_PCLK_ID,
+  CGU_SB_IOCONF_PCLK_ID,
+  CGU_SB_CGU_PCLK_ID,
+  CGU_SB_SYSCREG_PCLK_ID,
+  CGU_SB_OTP_PCLK_ID, /* valid on LPC315x series only */
+  CGU_SB_RNG_PCLK_ID,
+  CGU_AHB0APB0_LAST = CGU_SB_RNG_PCLK_ID,
+
+
+  /* domain 2 = AHB0APB1_BASE */
+  CGU_SB_AHB2APB1_ASYNC_PCLK_ID,
+  CGU_AHB0APB1_FIRST = CGU_SB_AHB2APB1_ASYNC_PCLK_ID,
+  CGU_SB_TIMER0_PCLK_ID,
+  CGU_SB_TIMER1_PCLK_ID,
+  CGU_SB_TIMER2_PCLK_ID,
+  CGU_SB_TIMER3_PCLK_ID,
+  CGU_SB_PWM_PCLK_ID,
+  CGU_SB_PWM_PCLK_REGS_ID,
+  CGU_SB_PWM_CLK_ID,
+  CGU_SB_I2C0_PCLK_ID,
+  CGU_SB_I2C1_PCLK_ID,
+  CGU_AHB0APB1_LAST = CGU_SB_I2C1_PCLK_ID,
+
+  /* domain 3 = AHB0APB2_BASE */
+  CGU_SB_AHB2APB2_ASYNC_PCLK_ID,
+  CGU_AHB0APB2_FIRST = CGU_SB_AHB2APB2_ASYNC_PCLK_ID,
+  CGU_SB_PCM_PCLK_ID,
+  CGU_SB_PCM_APB_PCLK_ID,
+  CGU_SB_UART_APB_CLK_ID,
+  CGU_SB_LCD_PCLK_ID,
+  CGU_SB_LCD_CLK_ID,
+  CGU_SB_SPI_PCLK_ID,
+  CGU_SB_SPI_PCLK_GATED_ID,
+  CGU_AHB0APB2_LAST = CGU_SB_SPI_PCLK_GATED_ID,
+
+  /* domain 4 = AHB0APB3_BASE */
+  CGU_SB_AHB2APB3_ASYNC_PCLK_ID,
+  CGU_AHB0APB3_FIRST = CGU_SB_AHB2APB3_ASYNC_PCLK_ID,
+  CGU_SB_I2S_CFG_PCLK_ID,
+  CGU_SB_EDGE_DET_PCLK_ID,
+  CGU_SB_I2STX_FIFO_0_PCLK_ID,
+  CGU_SB_I2STX_IF_0_PCLK_ID,
+  CGU_SB_I2STX_FIFO_1_PCLK_ID,
+  CGU_SB_I2STX_IF_1_PCLK_ID,
+  CGU_SB_I2SRX_FIFO_0_PCLK_ID,
+  CGU_SB_I2SRX_IF_0_PCLK_ID,
+  CGU_SB_I2SRX_FIFO_1_PCLK_ID,
+  CGU_SB_I2SRX_IF_1_PCLK_ID,
+  CGU_SB_RSVD69_ID,
+  CGU_SB_AHB2APB3_RSVD_ID,
+  CGU_AHB0APB3_LAST = CGU_SB_AHB2APB3_RSVD_ID,
+
+  /* domain 5 = PCM_BASE */
+  CGU_SB_PCM_CLK_IP_ID,
+  CGU_PCM_FIRST = CGU_SB_PCM_CLK_IP_ID,
+  CGU_PCM_LAST = CGU_SB_PCM_CLK_IP_ID,
+
+  /* domain 6 = UART_BASE */
+  CGU_SB_UART_U_CLK_ID,
+  CGU_UART_FIRST = CGU_SB_UART_U_CLK_ID,
+  CGU_UART_LAST = CGU_SB_UART_U_CLK_ID,
+
+  /* domain 7 = CLK1024FS_BASE */
+  CGU_SB_I2S_EDGE_DETECT_CLK_ID,
+  CGU_CLK1024FS_FIRST = CGU_SB_I2S_EDGE_DETECT_CLK_ID,
+  CGU_SB_I2STX_BCK0_N_ID,
+  CGU_SB_I2STX_WS0_ID,
+  CGU_SB_I2STX_CLK0_ID,
+  CGU_SB_I2STX_BCK1_N_ID,
+  CGU_SB_I2STX_WS1_ID,
+  CGU_SB_CLK_256FS_ID,
+  CGU_SB_I2SRX_BCK0_N_ID,
+  CGU_SB_I2SRX_WS0_ID,
+  CGU_SB_I2SRX_BCK1_N_ID,
+  CGU_SB_I2SRX_WS1_ID,
+  CGU_SB_RSVD84_ID,
+  CGU_SB_RSVD85_ID,
+  CGU_SB_RSVD86_ID,
+  CGU_CLK1024FS_LAST = CGU_SB_RSVD86_ID,
+
+  /* domain 8 = BCK0_BASE */
+  CGU_SB_I2SRX_BCK0_ID,
+  CGU_I2SRX_BCK0_FIRST = CGU_SB_I2SRX_BCK0_ID,
+  CGU_I2SRX_BCK0_LAST = CGU_SB_I2SRX_BCK0_ID,
+
+  /* domain 9 = BCK1_BASE */
+  CGU_SB_I2SRX_BCK1_ID,
+  CGU_I2SRX_BCK1_FIRST = CGU_SB_I2SRX_BCK1_ID,
+  CGU_I2SRX_BCK1_LAST = CGU_SB_I2SRX_BCK1_ID,
+
+  /* domain 10 = SPI_BASE */
+  CGU_SB_SPI_CLK_ID,
+  CGU_SPI_FIRST = CGU_SB_SPI_CLK_ID,
+  CGU_SB_SPI_CLK_GATED_ID,
+  CGU_SPI_LAST = CGU_SB_SPI_CLK_GATED_ID,
+
+  /* domain 11 = SYSCLKO_BASE */
+  CGU_SB_SYSCLK_O_ID,
+  CGU_SYSCLK_O_FIRST = CGU_SB_SYSCLK_O_ID,
+  CGU_SYSCLK_O_LAST = CGU_SB_SYSCLK_O_ID,
+
+  CGU_SB_INVALID_CLK_ID = -1
+} CGU_CLOCK_ID_T;
+
+
+/***********************************************************************
+* CGU driver defines - MACROS & constants
+**********************************************************************/
+#define CGU_INVALID_ID  0xFFFF
+
+/* Clocks which which need wake_en set. These are system clocks not
+ * managed by individual drivers. All other clocks should be disabled
+ * at startup.
+ */
+#define CGU_WKE_CLKS_0_31   ( _BIT(CGU_SB_APB0_CLK_ID) | _BIT(CGU_SB_APB1_CLK_ID) | \
+                              _BIT(CGU_SB_APB2_CLK_ID) | _BIT(CGU_SB_APB3_CLK_ID) | _BIT(CGU_SB_APB4_CLK_ID) | \
+                              _BIT(CGU_SB_AHB2INTC_CLK_ID) | _BIT(CGU_SB_AHB0_CLK_ID) | \
+                              _BIT(CGU_SB_EBI_CLK_ID) | _BIT(CGU_SB_DMA_PCLK_ID) | _BIT(CGU_SB_DMA_CLK_GATED_ID) | \
+                              _BIT(CGU_SB_ARM926_CORE_CLK_ID) | _BIT(CGU_SB_ARM926_BUSIF_CLK_ID) | \
+                              _BIT(CGU_SB_ARM926_RETIME_CLK_ID) | _BIT(CGU_SB_ISRAM0_CLK_ID) | \
+                              _BIT(CGU_SB_ISRAM1_CLK_ID) | _BIT(CGU_SB_ISROM_CLK_ID) | \
+                              _BIT(CGU_SB_MPMC_CFG_CLK_ID) | _BIT(CGU_SB_MPMC_CFG_CLK2_ID) | _BIT(CGU_SB_MPMC_CFG_CLK3_ID) | \
+                              _BIT(CGU_SB_INTC_CLK_ID) | _BIT(CGU_SB_AHB2APB0_ASYNC_PCLK_ID) | \
+                              _BIT(CGU_SB_EVENT_ROUTER_PCLK_ID) /*| _BIT(CGU_SB_CLOCK_OUT_ID)*/)
+
+#define CGU_WKE_CLKS_32_63 ( _BIT(CGU_SB_IOCONF_PCLK_ID - 32) | _BIT(CGU_SB_CGU_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_SYSCREG_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_TIMER0_PCLK_ID - 32) )
+
+
+#define CGU_WKE_CLKS_64_92 ( 0 )
+
+
+/***********************************************************************
+* CGU driver enumerations
+**********************************************************************/
+/* Possible HPLL ids */
+typedef enum {CGU_HPLL0_ID, CGU_HPLL1_ID} CGU_HPLL_ID_T;
+
+/* CGU soft reset module ID enumerations */
+typedef enum
+{
+  APB0_RST_SOFT = 0,
+  AHB2APB0_PNRES_SOFT,
+  APB1_RST_SOFT,
+  AHB2APB1_PNRES_SOFT,
+  APB2_RESETN_SOFT,
+  AHB2APB2_PNRES_SOFT,
+  APB3_RESETN_SOFT,
+  AHB2APB3_PNRES_SOFT,
+  APB4_RESETN_SOFT,
+  AHB2INTC_RESETN_SOFT,
+  AHB0_RESETN_SOFT,
+  EBI_RESETN_SOFT,
+  PCM_PNRES_SOFT,
+  PCM_RESET_N_SOFT,
+  PCM_RESET_ASYNC_N_SOFT,
+  TIMER0_PNRES_SOFT,
+  TIMER1_PNRES_SOFT,
+  TIMER2_PNRES_SOFT,
+  TIMER3_PNRES_SOFT,
+  ADC_PRESETN_SOFT,
+  ADC_RESETN_ADC10BITS_SOFT,
+  PWM_RESET_AN_SOFT,
+  UART_SYS_RST_AN_SOFT,
+  I2C0_PNRES_SOFT,
+  I2C1_PNRES_SOFT,
+  I2S_CFG_RST_N_SOFT,
+  I2S_NSOF_RST_N_SOFT,
+  EDGE_DET_RST_N_SOFT,
+  I2STX_FIFO_0_RST_N_SOFT,
+  I2STX_IF_0_RST_N_SOFT,
+  I2STX_FIFO_1_RST_N_SOFT,
+  I2STX_IF_1_RST_N_SOFT,
+  I2SRX_FIFO_0_RST_N_SOFT,
+  I2SRX_IF_0_RST_N_SOFT,
+  I2SRX_FIFO_1_RST_N_SOFT,
+  I2SRX_IF_1_RST_N_SOFT,
+  RSRVD_0_SOFT,
+  RSRVD_1_SOFT,
+  RSRVD_2_SOFT,
+  RSRVD_3_SOFT,
+  RSRVD_4_SOFT,
+  LCD_PNRES_SOFT,
+  SPI_PNRES_APB_SOFT,
+  SPI_PNRES_IP_SOFT,
+  DMA_PNRES_SOFT,
+  NANDFLASH_CTRL_ECC_RESET_N_SOFT,
+  NANDFLASH_CTRL_AES_RESET_N_SOFT,
+  NANDFLASH_CTRL_NAND_RESET_N_SOFT,
+  RNG_RESETN_SOFT,
+  SD_MMC_PNRES_SOFT,
+  SD_MMC_NRES_CCLK_IN_SOFT,
+  USB_OTG_AHB_RST_N_SOFT,
+  RED_CTL_RESET_N_SOFT,
+  AHB_MPMC_HRESETN_SOFT,
+  AHB_MPMC_REFRESH_RESETN_SOFT,
+  INTC_RESETN_SOFT
+} CGU_MOD_ID_T;
+
+/***********************************************************************
+* CGU driver structures
+**********************************************************************/
+/* CGU HPLL config settings structure type */
+typedef struct
+{
+  u32 fin_select;
+  u32 ndec;
+  u32 mdec;
+  u32 pdec;
+  u32 selr;
+  u32 seli;
+  u32 selp;
+  u32 mode;
+  u32 freq; /* in MHz for driver internal data */
+} CGU_HPLL_SETUP_T;
+
+/* CGU fractional divider settings structure type */
+typedef struct
+{
+  u8 stretch; /* Fractional divider stretch enable. */
+  u8 n;       /* Fractional divider nominal nominator */
+  u16 m;      /* Fractional divider nominal denominator */
+} CGU_FDIV_SETUP_T;
+
+/***********************************************************************
+* CGU driver functions
+**********************************************************************/
+/* Return the current base frequecy of the requested domain*/
+u32 cgu_get_base_freq(CGU_DOMAIN_ID_T baseid);
+
+/* Change the base frequency for the requested domain */
+void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel);
+
+/* Return the current frequecy of the requested clock*/
+u32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid);
+
+/* Change the sub-domain frequency for the requested clock */
+void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg);
+
+/* Configure the selected HPLL */
+void cgu_hpll_config(CGU_HPLL_ID_T id, CGU_HPLL_SETUP_T* pllsetup);
+
+/* enable / disable external enabling of the requested clock in CGU */
+void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable);
+
+/* frac divider config function */
+u32 cgu_fdiv_config(u32 fdId, CGU_FDIV_SETUP_T fdivCfg, u32 enable);
+
+/***********************************************************************
+* CGU driver inline (ANSI C99 based) functions
+**********************************************************************/
+/* enable / disable the requested clock in CGU */
+static inline void cgu_clk_en_dis(CGU_CLOCK_ID_T clkid, u32 enable)
+{
+  if (enable)
+  {
+    CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_RUN;
+  }
+  else
+  {
+    CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_RUN;
+  }
+
+}
+/* Issue a software reset to the requested module */
+static inline void cgu_soft_reset_module(CGU_MOD_ID_T modId)
+{
+  volatile u32 i;
+
+  /* clear and set the register */
+  CGU_CFG->resetn_soft[modId] = 0;
+  /* introduce some delay */
+  for (i = 0;i < 1000;i++);
+
+  CGU_CFG->resetn_soft[modId] = CGU_CONFIG_SOFT_RESET;
+}
+
+
+/***********************************************************************
+* Enable/Disable frequency input to the selected base
+**********************************************************************/
+static inline void cgu_endis_base_freq(CGU_DOMAIN_ID_T baseid, int en)
+{
+	/* Let us not disturb anything except STOP */
+	if (!en){
+		CGU_SB->base_scr[baseid] |= CGU_SB_SCR_STOP;
+	} else {
+		CGU_SB->base_scr[baseid] &= ~CGU_SB_SCR_STOP;
+	}
+}
+
+#endif /* LPC313X_CGU_DRIVER_H */
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/constants.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/constants.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/constants.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/constants.h	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,107 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/constants.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Manifest constants for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+/* ----- Globals */
+#define _BIT(n)	  ((1) << (n))
+/* shift bit field */
+#define _SBF(f,v) ((v) << (f))
+
+
+/***********************************************************************
+ * Physical bases
+ **********************************************************************/
+#define EVTR_PHYS         (0x13000000)
+#define ADC_PHYS          (0x13002000)
+#define WDT_PHYS          (0x13002400)
+#define SYS_PHYS          (0x13002800)
+#define GPIO_PHYS         (0x13003000)
+#define CGU_SB_PHYS       (0x13004000)
+#define CGU_CFG_PHYS      (0x13004c00)
+#define TIMER0_PHYS       (0x13008000)
+#define TIMER1_PHYS       (0x13008400)
+#define TIMER2_PHYS       (0x13008800)
+#define TIMER3_PHYS       (0x13008c00)
+#define I2C0_PHYS         (0x1300a000)
+#define I2C1_PHYS         (0x1300a400)
+#define UART_PHYS         (0x15001000)
+#define SPI_PHYS          (0x15002000)
+#define I2S_PHYS          (0x16000000)
+#define DMA_PHYS          (0x17000000)
+#define MPMC_PHYS         (0x17008000)
+#define SDMMC_PHYS        (0x18000000)
+#define USBOTG_PHYS       (0x19000000)
+#define INTC_PHYS         (0x60000000)
+#define NANDC_PHYS        (0x17000800)
+/***********************************************************************
+ * Memory definitions
+ **********************************************************************/
+#define EXT_SDRAM_PHYS    (0x30000000)
+#define EXT_SRAM0_PHYS    (0x20000000)
+#define EXT_SRAM1_PHYS    (0x20020000)
+#define ISRAM0_PHYS       (0x11028000)
+#define ISRAM0_LENGTH     (0x00018000)
+#define ISRAM1_PHYS       (0x11040000)
+#define ISRAM1_LENGTH     (0x00018000)
+
+/***********************************************************************
+ * XTAL clock definitions
+ **********************************************************************/
+#define XTAL_CLOCK        (12000000)
+#define FFAST_CLOCK       XTAL_CLOCK
+
+/* SoC CPU IO addressing */
+/* APB0 & APB1 address range*/
+#define IO_APB01_PHYS     (0x13000000)
+#define IO_APB01_SIZE     (0x0000B000)
+/* APB2 address range*/
+#define IO_APB2_PHYS      (0x15000000)
+#define IO_APB2_SIZE      (0x00003000)
+/* APB3 address range*/
+#define IO_APB3_PHYS      (0x16000000)
+#define IO_APB3_SIZE      (0x00001000)
+/* APB4 address range*/
+#define IO_APB4_PHYS      (0x17000000)
+#define IO_APB4_SIZE      (0x00001000)
+/* DMA registers address range*/
+#define IO_DMA_REG_PHYS  (DMA_PHYS)
+#define IO_DMA_REG_SIZE  (0x0000800)
+/* MPMC config registers address range*/
+#define IO_MPMC_CFG_PHYS  (0x17008000)
+#define IO_MPMC_CFG_SIZE  (0x00001000)
+/* SD/MMC address range*/
+#define IO_SDMMC_PHYS     (SDMMC_PHYS)
+#define IO_SDMMC_SIZE     (0x00001000)
+/* USB OTG address range*/
+#define IO_USB_PHYS       (USBOTG_PHYS)
+#define IO_USB_SIZE       (0x00001000)
+/* Interrupt controller address range*/
+#define IO_INTC_PHYS      (0x60000000)
+#define IO_INTC_SIZE      (0x00001000)
+/* NAND address range*/
+#define IO_NAND_PHYS	  (NANDC_PHYS)
+#define IO_NAND_SIZE	  (0x00000800)
+/* NAND buffer address range*/
+#define IO_NAND_BUF_PHYS  (0x70000000)
+#define IO_NAND_BUF_SIZE  (0x00001000)
+/* ISRAM address range*/
+#define IO_ISRAM0_PHYS     (0x11028000)
+#define IO_ISRAM0_SIZE     (0x00018000)
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/debug-macro.S work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/debug-macro.S
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/debug-macro.S	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/debug-macro.S	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,26 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 2008 NXP semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include "hardware.h"
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst     \rx, #1                 @ MMU enabled?
+		mov     \rx, #0x15000000	    @ physical base
+		movne   \rx, \rx, lsr #4	    @ virtual base
+		orrne   \rx, \rx, #0xf0000000   @ virtual base
+		orr     \rx, \rx, #0x00001000   @ offset from base
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/dma.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/dma.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/dma.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/dma.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,383 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/dma.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * DMA register defines & structures for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#include <mach/constants.h>
+
+/***********************************************************************
+ * DMA register definitions
+ **********************************************************************/
+#define DMACH_SRC_ADDR(ch)    __REG (DMA_PHYS + ((ch) << 5) + 0x00)
+#define DMACH_DST_ADDR(ch)    __REG (DMA_PHYS + ((ch) << 5) + 0x04)
+#define DMACH_LEN(ch)         __REG (DMA_PHYS + ((ch) << 5) + 0x08)
+#define DMACH_CFG(ch)         __REG (DMA_PHYS + ((ch) << 5) + 0x0C)
+#define DMACH_EN(ch)          __REG (DMA_PHYS + ((ch) << 5) + 0x10)
+#define DMACH_TCNT(ch)        __REG (DMA_PHYS + ((ch) << 5) + 0x1C)
+#define DMACH_ALT_EN          __REG (DMA_PHYS + 0x400)
+#define DMACH_IRQ_STATUS      __REG (DMA_PHYS + 0x404)
+#define DMACH_IRQ_MASK        __REG (DMA_PHYS + 0x408)
+#define DMACH_ALT_PHYS(ch)    (DMA_PHYS + 0x200 + ((ch) << 4))
+#define DMACH_SOFT_INT_PHYS   (DMA_PHYS + 0x40C )
+
+/***********************************************************************
+* Channel CONFIGURATION register defines
+***********************************************************************/
+#define DMA_CFG_CIRC_BUF        _BIT(18)
+#define DMA_CFG_CMP_CH_EN       _BIT(17)
+#define DMA_CFG_CMP_CH_NR(n)    _SBF(13, ((n) & 0x7))
+#define DMA_CFG_INV_ENDIAN      _BIT(12)
+#define DMA_CFG_CIRC_BUF        _BIT(18)
+#define DMA_CFG_TX_WORD         _SBF(10, 0x00)
+#define DMA_CFG_TX_HWORD        _SBF(10, 0x01)
+#define DMA_CFG_TX_BYTE         _SBF(10, 0x02)
+#define DMA_CFG_TX_BURST        _SBF(10, 0x03)
+#define DMA_CFG_RD_SLV_NR(n)    _SBF(5, ((n) & 0x1F))
+#define DMA_CFG_WR_SLV_NR(n)    _SBF(0, ((n) & 0x1F))
+
+#define DMA_CFG_GET_CMP_CH_NR(n)    (((n) >> 13) & 0x7)
+#define DMA_CFG_GET_RD_SLV_NR(n)    (((n) >> 5) & 0x1F)
+#define DMA_CFG_GET_WR_SLV_NR(n)    ((n) & 0x1F)
+
+/* bit defines for interrupt status and mask register */
+#define DMA_IRQS_SOFT         _BIT(30)
+#define DMA_IRQS_ABORT        _BIT(31)
+
+/* DMA hardware constants */
+#define DMA_MAX_CHANNELS   12
+#define DMA_MAX_TRANSFERS  2047
+
+/*bit defines for configuration register */
+#define DMA_COMPANION_ENABLE _BIT()
+/* DMA slave number defines */
+#define DMA_SLV_PCM_TX     1
+#define DMA_SLV_PCM_RX     2
+#define DMA_SLV_UART_RX    3
+#define DMA_SLV_UART_TX    4
+#define DMA_SLV_I2C0       5
+#define DMA_SLV_I2C1       6
+#define DMA_SLV_I2STX0_L   7
+#define DMA_SLV_I2STX0_R   8
+#define DMA_SLV_I2STX1_L   9
+#define DMA_SLV_I2STX1_R   10
+#define DMA_SLV_I2SRX0_L   11
+#define DMA_SLV_I2SRX0_R   12
+#define DMA_SLV_I2SRX1_L   13
+#define DMA_SLV_I2SRX1_R   16
+#define DMA_SLV_LCD        17
+#define DMA_SLV_SPI_TX     18
+#define DMA_SLV_SPI_RX     19
+#define DMA_SLV_SDMMC      20
+#define DMA_CLV_INVALID    0xFF
+
+/* DMA transfer types */
+#define DMA_TRANSFER_WORD       0
+#define DMA_TRANSFER_HALF_WORD  1
+#define DMA_TRANSFER_BYTE       2
+#define DMA_TRANSFER_BURST      3
+
+/*
+ * Type of interrupt
+ */
+typedef enum 
+{
+	DMA_IRQ_FINISHED = 0,
+	DMA_IRQ_HALFWAY,
+	DMA_IRQ_SOFTINT,
+	DMA_IRQ_DMAABORT
+} dma_irq_type_t;
+ /* 
+ * DMA IRQ channel callback function
+ * parameters:
+ * 1st parameter - channel number for which an IRQ occured
+ * 2nd parameter - what type of interrupt has happened for a channel
+ * 3rd parameter - additional data (callback-specific context)
+ * 4th parameter - registers structure as passed to interrupt handler
+ */
+typedef void (*dma_cb_t)(int, dma_irq_type_t, void *);
+
+typedef union __dma_config_t{
+	struct {
+		unsigned int write_slave_nr:5;
+		unsigned int read_slave_nr:5;
+		unsigned int transfer_size:2;
+		unsigned int invert_endian:1;
+		unsigned int companion_channel:3;
+		unsigned int rsrvd0:1;
+		unsigned int companion_enable:1;
+		unsigned int circular_buffer:1;
+		unsigned int rsrvd1:12;
+	} s;
+	u32 value;
+} dma_config_t;
+
+/*
+ * DMA setup structure
+ */
+typedef struct dma_setup
+{
+	/* source address for transfer*/
+	u32 src_address;
+	/* source address for transfer*/
+	u32 dest_address;
+	/* toatl transfer length*/
+	u32 trans_length;
+	/* channel configuration */
+	//dma_config_t cfg;
+	u32 cfg;
+} dma_setup_t;
+
+/*
+ * SDMA scatter-gather list structure 
+ */
+typedef struct dma_sg_ll
+{
+	dma_setup_t setup;
+	u32 next_entry;
+} dma_sg_ll_t;
+
+
+/*
+ * API definition
+ */
+
+
+/*
+ * Program SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - channel number, obtained from dma_request_channel()
+ * 2nd parameter - ptr to the structure containing setup info for the channel
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_prog_channel (unsigned int, dma_setup_t   *);
+
+/*
+ * Request SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - free-form string identifier of channel. Must be non-NULL
+ * 2nd parameter - callback function to be invoked when an interrupt
+ *                 occurs for this channel
+ * 3rd parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function when it's invoked
+ *
+ * Returns: channel number on success, otherwise (negative) failure 
+ */
+int dma_request_channel (char *, dma_cb_t cb, void *);
+
+/*
+ * Request specific SDMA channel
+ *
+ * Function parameters:
+ * 1th parameter - specific channel number
+ * 2nd parameter - free-form string identifier of channel. Must be non-NULL
+ * 3rd parameter - callback function to be invoked when an interrupt
+ *                 occurs for this channel
+ * 4th parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function when it's invoked
+ *
+ *
+ * Returns: channel number on success, otherwise (negative) failure 
+ */
+int dma_request_specific_channel (int, char *, dma_cb_t cb, void *);
+
+
+/*
+ * Mask/unmask interrupts for the specified channel
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - 0 to unmask halfway-done interrupt, 1 to mask it
+ * 3rd parameter - 0 to unmask on-finish interrupt, 1 to mask it
+ *
+ * Returns: 0 on success, otherwise failure
+ */
+int dma_set_irq_mask(unsigned int, int, int);
+
+/*
+ * Start SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_start_channel (unsigned int);
+
+/*
+ * Stop SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_stop_channel (unsigned int);
+
+/*
+ * Release SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_release_channel (unsigned int);
+
+/*
+ * Read channel counter
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - ptr to the counter variable to be filled
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_read_counter (unsigned int, unsigned int *);
+
+/*
+ * Write channel counter
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - value to be written
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_write_counter (unsigned int, u32);
+
+/*
+ * Read current channel state
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - ptr to the source address variable to be filled
+ * 3rd parameter - ptr to the destination address variable to be filled
+ * 4th parameter - ptr to the transfer length variable to be filled
+ * 5th parameter - ptr to the configuration variable to be filled
+ * 6th parameter - ptr to the enable flag variable to be filled
+ * 7th parameter - ptr to the address counter variable to be filled
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_current_state    (unsigned int, unsigned int *, unsigned int *, unsigned int *, unsigned int  *, unsigned int  *, unsigned int  *);
+
+/*
+ * Request SDMA SG channel
+ * Reserves two consequent channels
+ *
+ * Function parameters:
+ * 1st parameter - free-form string identifier of channel.
+ * 2nd parameter - callback function to be invoked when an interrupt
+ *                 occurs for this channel
+ * 3rd parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function when it's invoked
+ * 4th parameter - flag to enable soft IRQ for this channel. Only 1 channel
+ *                 may be enabled with soft-irq.
+ *
+ * Callback parameters:
+ * 1st parameter - channel number for which an IRQ occured
+ * 2nd parameter - what type of interrupt has happened for a channel
+ * 3rd parameter - additional data (callback-specific context)
+ * 4th parameter - registers structure as passed to interrupt handler
+ *
+ * Returns: bigger channel number on success, otherwise negative error code
+ */
+int dma_request_sg_channel (char *, dma_cb_t cb, void *, int);
+
+/*
+ * Request specific SDMA SG channel (actually pair of channels)
+ * Reserves two consequent channels with the bigger number as requested
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - free-form string identifier of channel.
+ * 3rd parameter - callback function to be invoked when an interrupt
+ *                 occurs for this channel
+ * 4th parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function when it's invoked
+ * 5th parameter - flag to enable soft IRQ for this channel. Only 1 channel
+ *                 may be enabled with soft-irq.
+ *
+ * Callback parameters:
+ * 1st parameter - channel number for which an IRQ occured
+ * 2nd parameter - what type of interrupt has happened for a channel
+ * 3rd parameter - additional data (callback-specific context)
+ * 4th parameter - registers structure as passed to interrupt handler
+ *
+ * Returns: bigger channel number on success, otherwise negative error code
+ */
+int dma_request_specific_sg_channel (int, char *, dma_cb_t cb, void *, int);
+
+/*
+ * Prepare SG list for programming into the SDMA controller
+ * This function is intended to set right companion channel for each
+ * entry in the list except the last one and to set the last entry of 
+ * the scatter-gather list according to one of the methods to define 
+ * the last entry described.
+ *
+ * Function parameters:
+ * 1st parameter - channel number returned by dma_request_sg_channel()
+ * 2nd parameter - ptr to the first scatter gather list entry
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_prepare_sg_list(int, dma_sg_ll_t *);
+
+/*
+ * Program SDMA SG channel
+ * This function is very similar to dma_prog_channel, but in this case
+ * the user has to supply only the linked-list address
+ *
+ * Function parameters:
+ * 1st parameter - channel number returned by dma_request_sg_channel() 
+ * 2nd parameter - physical ptr to the first entry in the linked list
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_prog_sg_channel(int, u32 );
+
+/*
+ * Release SDMA SG channel
+ *
+ * Function parameters:
+ * 1st parameter - channel number returned by dma_request_sg_channel()
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_release_sg_channel (unsigned int);
+
+/*
+ * Indicates if DMA channel is enabled
+ *
+ * Function parameters:
+ * 1st parameter - MA channel number
+ *
+ * Returns: 0 is disabled, otherwise !0
+ */
+int dma_channel_enabled(unsigned int);
+
+#endif				/* _ASM_ARCH_DMA_H */
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/entry-macro.S work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/entry-macro.S
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/entry-macro.S	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/entry-macro.S	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,35 @@
+/*
+ * linux/arch/arm/mach-lpc313x/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for LPC313x-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro	get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro	arch_ret_to_user, tmp1, tmp2
+		.endm
+
+#define IRQ_VEC_OFF     0x100      /* Offset to IRQ number  */
+#define IRQ_STAT_OFF    0x200      /* Offset to IRQ status  */
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =io_p2v(INTC_PHYS)
+		@ Load offset & priority of the highest priority
+		@ interrupt pending.
+		ldr	\irqnr, [\base, #IRQ_VEC_OFF]
+		mov	\irqnr, \irqnr, lsr #3
+		/* Assuming INTC_IRQ_VEC_BASE is set 0 during init. 
+		   If not then add masking instruction below. uncomment the following.
+		and	\irqnr, \irqnr, #0x1F
+		*/
+		movs	\irqstat, \irqnr
+		.endm
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/event_router.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/event_router.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/event_router.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/event_router.h	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,201 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/event_router.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Event router defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#ifndef __ASM_ARCH_EVT_IRQS_H
+#define __ASM_ARCH_EVT_IRQS_H
+
+
+/* event PIN or internal signal */
+typedef enum _EVT_TYPE_
+{
+  EVT_ipint_int = 0,
+  EVT_mLCD_DB_0,
+  EVT_mLCD_DB_1,
+  EVT_mLCD_DB_2,
+  EVT_mLCD_DB_3,
+  EVT_mLCD_DB_4,
+  EVT_mLCD_DB_5,
+  EVT_mLCD_DB_6,
+  EVT_mLCD_DB_7,
+  EVT_mLCD_DB_8,
+  EVT_mLCD_DB_9,
+  EVT_mLCD_DB_10,
+  EVT_mLCD_DB_11,
+  EVT_mLCD_DB_12,
+  EVT_mLCD_DB_13,
+  EVT_mLCD_DB_14,
+  EVT_mLCD_DB_15,
+  EVT_mLCD_RS,
+  EVT_mLCD_CSB,
+  EVT_mLCD_E_RD,
+  EVT_mLCD_RW_WR,
+  EVT_mNAND_RYBN0,
+  EVT_mNAND_RYBN1,
+  EVT_mNAND_RYBN2,
+  EVT_mNAND_RYBN3,
+  EVT_EBI_D_0,
+  EVT_EBI_D_1,
+  EVT_EBI_D_2,
+  EVT_EBI_D_3,
+  EVT_EBI_D_4,
+  EVT_EBI_D_5,
+  EVT_EBI_D_6,
+  EVT_EBI_D_7,
+  EVT_EBI_D_8,
+  EVT_EBI_D_9,
+  EVT_EBI_D_10,
+  EVT_EBI_D_11,
+  EVT_EBI_D_12,
+  EVT_EBI_D_13,
+  EVT_EBI_D_14,
+  EVT_EBI_D_15,
+  EVT_EBI_NWE,
+  EVT_EBI_A_0_ALE,
+  EVT_EBI_A_1_CLE,
+  EVT_EBI_DQM_0_NOE,
+  EVT_EBI_NCAS_BLOUT_0,
+  EVT_EBI_NRAS_BLOUT_1,
+  EVT_GPIO1,
+  EVT_GPIO0,
+  EVT_GPIO2,
+  EVT_GPIO3,
+  EVT_GPIO4,
+  EVT_mGPIO5,
+  EVT_mGPIO6,
+  EVT_mGPIO7,
+  EVT_mGPIO8,
+  EVT_mGPIO9,
+  EVT_mGPIO10,
+  EVT_GPIO11,
+  EVT_GPIO12,
+  EVT_GPIO13,
+  EVT_GPIO14,
+  EVT_GPIO15,
+  EVT_GPIO16,
+  EVT_GPIO17,
+  EVT_GPIO18,
+  EVT_NAND_NCS_0,
+  EVT_NAND_NCS_1,
+  EVT_NAND_NCS_2,
+  EVT_NAND_NCS_3,
+  EVT_SPI_MISO,
+  EVT_SPI_MOSI,
+  EVT_SPI_CS_IN,
+  EVT_SPI_SCK,
+  EVT_SPI_CS_OUT0,
+  EVT_UART_RXD,
+  EVT_UART_TXD,
+  EVT_mUART_CTS_N,
+  EVT_mUART_RTS_N,
+  EVT_mI2STX_CLK0,
+  EVT_mI2STX_BCK0,
+  EVT_mI2STX_DATA0,
+  EVT_mI2STX_WS0,
+  EVT_I2SRX_BCK0,
+  EVT_I2SRX_DATA0,
+  EVT_I2SRX_WS0,
+  EVT_I2SRX_DATA1,
+  EVT_I2SRX_BCK1,
+  EVT_I2SRX_WS1,
+  EVT_I2STX_DATA1,
+  EVT_I2STX_BCK1,
+  EVT_I2STX_WS1,
+  EVT_CLK_256FS_O,
+  EVT_I2C_SDA1,
+  EVT_I2C_SCL1,
+  EVT_PWM_DATA,
+  EVT_AD_NINT_I,
+  EVT_PLAY_DET_I,
+  EVT_timer0_intct1,
+  EVT_timer1_intct1,
+  EVT_timer2_intct1,
+  EVT_timer3_intct1,
+  EVT_adc_int,
+  EVT_wdog_m0,
+  EVT_uart_rxd,
+  EVT_i2c0_scl_n,
+  EVT_i2c1_scl_n,
+  EVT_arm926_nfiq,
+  EVT_arm926_nirq,
+  EVT_MCI_DAT_0,
+  EVT_MCI_DAT_1,
+  EVT_MCI_DAT_2,
+  EVT_MCI_DAT_3,
+  EVT_MCI_DAT_4,
+  EVT_MCI_DAT_5,
+  EVT_MCI_DAT_6,
+  EVT_MCI_DAT_7,
+  EVT_MCI_CMD,
+  EVT_MCI_CLK,
+  EVT_USB_VBUS,
+  EVT_usb_otg_ahb_needclk,
+  EVT_usb_atx_pll_lock,
+  EVT_usb_otg_vbus_pwr_en,
+  EVT_USB_ID,
+  EVT_isram0_mrc_finished,
+  EVT_isram1_mrc_finished,
+  EVT_LAST
+} EVENT_T;
+
+/* External interrupt type enumerations */
+typedef enum
+{
+  EVT_ACTIVE_LOW,
+  EVT_ACTIVE_HIGH,
+  EVT_FALLING_EDGE,
+  EVT_RISING_EDGE,
+  EVT_BOTH_EDGE
+} EVENT_TYPE_T;
+
+/* Macros to compute the bank based on EVENT_T */
+#define EVT_GET_BANK(evt)   (((evt) >> 5) & 0x3)
+
+/* structure to map board IRQ to event pin */
+typedef struct {
+	u32 irq;
+	EVENT_T event_pin;
+	EVENT_TYPE_T type;
+} IRQ_EVENT_MAP_T;
+
+#define EVT_MAX_VALID_BANKS   4
+#define EVT_MAX_VALID_INT_OUT 5
+
+/* Activation polarity register defines */
+#define EVT_APR_HIGH    1
+#define EVT_APR_LOW     0
+#define EVT_APR_BANK0_DEF 0x00000001
+#define EVT_APR_BANK1_DEF 0x00000000
+#define EVT_APR_BANK2_DEF 0x00000000
+#define EVT_APR_BANK3_DEF 0x0FFFFFFC
+
+/* Activation type register defines */
+#define EVT_ATR_EDGE    1
+#define EVT_ATR_LEVEL   0
+#define EVT_ATR_BANK0_DEF 0x00000001
+#define EVT_ATR_BANK1_DEF 0x00000000
+#define EVT_ATR_BANK2_DEF 0x00000000
+#define EVT_ATR_BANK3_DEF 0x077FFFFC
+
+
+#endif
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/gpio.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/gpio.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/gpio.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/gpio.h	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,241 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/gpio.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * GPIO defines & routines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef _LPC313X_GPIO_H
+
+#include <mach/hardware.h>
+
+#define GPIO_PORT_MASK  0x0FE0
+#define GPIO_PIN_MASK   0x001F
+
+
+#define GPIO_MGPIO9           (IOCONF_EBI_MCI | 0)  
+#define GPIO_MGPIO6           (IOCONF_EBI_MCI | 1)  
+#define GPIO_MLCD_DB_7        (IOCONF_EBI_MCI | 2)  
+#define GPIO_MLCD_DB_4        (IOCONF_EBI_MCI | 3)  
+#define GPIO_MLCD_DB_2        (IOCONF_EBI_MCI | 4)  
+#define GPIO_MNAND_RYBN0      (IOCONF_EBI_MCI | 5)  
+#define GPIO_MI2STX_CLK0      (IOCONF_EBI_MCI | 6)  
+#define GPIO_MI2STX_BCK0      (IOCONF_EBI_MCI | 7)  
+#define GPIO_EBI_A_1_CLE      (IOCONF_EBI_MCI | 8)  
+#define GPIO_EBI_NCAS_BLOUT   (IOCONF_EBI_MCI | 9)  
+#define GPIO_MLCD_DB_0        (IOCONF_EBI_MCI | 10) 
+#define GPIO_EBI_DQM_0_NOE    (IOCONF_EBI_MCI | 11) 
+#define GPIO_MLCD_CSB         (IOCONF_EBI_MCI | 12) 
+#define GPIO_MLCD_DB_1        (IOCONF_EBI_MCI | 13) 
+#define GPIO_MLCD_E_RD        (IOCONF_EBI_MCI | 14) 
+#define GPIO_MLCD_RS          (IOCONF_EBI_MCI | 15) 
+#define GPIO_MLCD_RW_WR       (IOCONF_EBI_MCI | 16) 
+#define GPIO_MLCD_DB_3        (IOCONF_EBI_MCI | 17) 
+#define GPIO_MLCD_DB_5        (IOCONF_EBI_MCI | 18) 
+#define GPIO_MLCD_DB_6        (IOCONF_EBI_MCI | 19) 
+#define GPIO_MLCD_DB_8        (IOCONF_EBI_MCI | 20) 
+#define GPIO_MLCD_DB_9        (IOCONF_EBI_MCI | 21) 
+#define GPIO_MLCD_DB_10       (IOCONF_EBI_MCI | 22) 
+#define GPIO_MLCD_DB_11       (IOCONF_EBI_MCI | 23) 
+#define GPIO_MLCD_DB_12       (IOCONF_EBI_MCI | 24) 
+#define GPIO_MLCD_DB_13       (IOCONF_EBI_MCI | 25) 
+#define GPIO_MLCD_DB_14       (IOCONF_EBI_MCI | 26) 
+#define GPIO_MLCD_DB_15       (IOCONF_EBI_MCI | 27) 
+#define GPIO_MGPIO5           (IOCONF_EBI_MCI | 28) 
+#define GPIO_MGPIO7           (IOCONF_EBI_MCI | 29) 
+#define GPIO_MGPIO8           (IOCONF_EBI_MCI | 30) 
+#define GPIO_MGPIO10          (IOCONF_EBI_MCI | 31) 
+                
+#define GPIO_MNAND_RYBN1      (IOCONF_EBI_I2STX_0 | 0) 
+#define GPIO_MNAND_RYBN2      (IOCONF_EBI_I2STX_0 | 1) 
+#define GPIO_MNAND_RYBN3      (IOCONF_EBI_I2STX_0 | 2) 
+#define GPIO_MUART_CTS_N      (IOCONF_EBI_I2STX_0 | 3) 
+#define GPIO_MUART_RTS_N      (IOCONF_EBI_I2STX_0 | 4) 
+#define GPIO_MI2STX_DATA0     (IOCONF_EBI_I2STX_0 | 5) 
+#define GPIO_MI2STX_WS0       (IOCONF_EBI_I2STX_0 | 6) 
+#define GPIO_EBI_NRAS_BLOUT   (IOCONF_EBI_I2STX_0 | 7) 
+#define GPIO_EBI_A_0_ALE      (IOCONF_EBI_I2STX_0 | 8) 
+#define GPIO_EBI_NWE          (IOCONF_EBI_I2STX_0 | 9) 
+                 
+#define GPIO_CGU_SYSCLK_O     (IOCONF_CGU | 0) 
+
+#define GPIO_I2SRX_BCK0       (IOCONF_I2SRX_0 | 0) 
+#define GPIO_I2SRX_DATA0      (IOCONF_I2SRX_0 | 1) 
+#define GPIO_I2SRX_WS0        (IOCONF_I2SRX_0 | 2) 
+                  
+#define GPIO_I2SRX_DATA1      (IOCONF_I2SRX_1 | 0) 
+#define GPIO_I2SRX_BCK1       (IOCONF_I2SRX_1 | 1) 
+#define GPIO_I2SRX_WS1        (IOCONF_I2SRX_1 | 2) 
+                  
+#define GPIO_I2STX_DATA1      (IOCONF_I2STX_1 | 0) 
+#define GPIO_I2STX_BCK1       (IOCONF_I2STX_1 | 1) 
+#define GPIO_I2STX_WS1        (IOCONF_I2STX_1 | 2) 
+#define GPIO_I2STX_256FS_O    (IOCONF_I2STX_1 | 3) 
+ 
+#define GPIO_EBI_D_9          (IOCONF_EBI | 0)  
+#define GPIO_EBI_D_10         (IOCONF_EBI | 1)  
+#define GPIO_EBI_D_11         (IOCONF_EBI | 2)  
+#define GPIO_EBI_D_12         (IOCONF_EBI | 3)  
+#define GPIO_EBI_D_13         (IOCONF_EBI | 4)  
+#define GPIO_EBI_D_14         (IOCONF_EBI | 5)  
+#define GPIO_EBI_D_4          (IOCONF_EBI | 6)  
+#define GPIO_EBI_D_0          (IOCONF_EBI | 7)  
+#define GPIO_EBI_D_1          (IOCONF_EBI | 8)  
+#define GPIO_EBI_D_2          (IOCONF_EBI | 9)  
+#define GPIO_EBI_D_3          (IOCONF_EBI | 10) 
+#define GPIO_EBI_D_5          (IOCONF_EBI | 11) 
+#define GPIO_EBI_D_6          (IOCONF_EBI | 12) 
+#define GPIO_EBI_D_7          (IOCONF_EBI | 13) 
+#define GPIO_EBI_D_8          (IOCONF_EBI | 14) 
+#define GPIO_EBI_D_15         (IOCONF_EBI | 15) 
+                  
+
+#define GPIO_GPIO1            (IOCONF_GPIO | 0)  
+#define GPIO_GPIO0            (IOCONF_GPIO | 1)  
+#define GPIO_GPIO2            (IOCONF_GPIO | 2)  
+#define GPIO_GPIO3            (IOCONF_GPIO | 3)  
+#define GPIO_GPIO4            (IOCONF_GPIO | 4)  
+#define GPIO_GPIO11           (IOCONF_GPIO | 5)  
+#define GPIO_GPIO12           (IOCONF_GPIO | 6)  
+#define GPIO_GPIO13           (IOCONF_GPIO | 7)  
+#define GPIO_GPIO14           (IOCONF_GPIO | 8)  
+#define GPIO_GPIO15           (IOCONF_GPIO | 9)  
+#define GPIO_GPIO16           (IOCONF_GPIO | 10) 
+#define GPIO_GPIO17           (IOCONF_GPIO | 11) 
+#define GPIO_GPIO18           (IOCONF_GPIO | 12) 
+#define GPIO_GPIO19           (IOCONF_GPIO | 13) 
+#define GPIO_GPIO20           (IOCONF_GPIO | 14) 
+                
+#define GPIO_I2C_SDA1         (IOCONF_I2C1 | 0) 
+#define GPIO_I2C_SCL1         (IOCONF_I2C1 | 1) 
+                          
+#define GPIO_SPI_MISO         (IOCONF_SPI | 0) 
+#define GPIO_SPI_MOSI         (IOCONF_SPI | 1) 
+#define GPIO_SPI_CS_IN        (IOCONF_SPI | 2) 
+#define GPIO_SPI_SCK          (IOCONF_SPI | 3) 
+#define GPIO_SPI_CS_OUT0      (IOCONF_SPI | 4) 
+                 
+#define GPIO_NAND_NCS_3       (IOCONF_NAND_CTRL | 0)
+#define GPIO_NAND_NCS_0       (IOCONF_NAND_CTRL | 1)
+#define GPIO_NAND_NCS_1       (IOCONF_NAND_CTRL | 2)
+#define GPIO_NAND_NCS_2       (IOCONF_NAND_CTRL | 3)
+                 
+#define GPIO_PWM_DATA         (IOCONF_PWM | 0)
+                  
+#define GPIO_UART_RXD         (IOCONF_UART | 0)
+#define GPIO_UART_TXD         (IOCONF_UART | 1)
+                
+                
+                
+static inline int lpc313x_gpio_direction_input(unsigned gpio)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_RESET(port) = pin; 
+	GPIO_M0_RESET(port) = pin;
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+static inline int lpc313x_gpio_ip_driven(unsigned gpio)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_RESET(port) = pin; 
+	GPIO_M0_SET(port) = pin;
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+
+static inline int lpc313x_gpio_get_value(unsigned gpio)
+{
+	return (GPIO_STATE(gpio & GPIO_PORT_MASK) & (1 << (gpio & GPIO_PIN_MASK)));
+}
+
+static inline void lpc313x_gpio_set_value(unsigned gpio, int value)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_SET(port) = pin; 
+
+	if(value) {
+		GPIO_M0_SET(port) = pin;
+	} else {
+		GPIO_M0_RESET(port) = pin;
+	}
+
+	raw_local_irq_restore(flags);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Wrappers for "new style" GPIO calls. These calls LPC313x specific versions
+ * to allow future extension of GPIO logic.
+*/
+static inline  int gpio_direction_input(unsigned gpio)
+{
+	return lpc313x_gpio_direction_input(gpio);
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	lpc313x_gpio_set_value(gpio, value);
+	return 0;
+}
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return lpc313x_gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	lpc313x_gpio_set_value(gpio, value);
+}
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+/**
+ * FIXME: It is assumed that freeing a gpio pin
+ * will set it to the default mode. eh?
+ **/
+static inline void gpio_free( unsigned gpio)
+{
+	lpc313x_gpio_ip_driven(gpio);
+}
+int gpio_is_valid(unsigned pin);
+
+
+#endif /*_LPC313X_GPIO_H*/
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/hardware.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/hardware.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/hardware.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,79 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/hardware.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Hardware register defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#include "constants.h"
+
+
+/* macros to convert phys to virtual & virtual to phys memory location*/
+#define io_p2v(x) (0xf0000000 | (((x) & 0xff000000) >> 4) | ((x) & 0x000fffff))
+#define io_v2p(x) (             (((x) & 0x0ff00000) << 4) | ((x) & 0x000fffff))
+
+#define MASK_AND_SET(v,m,s)	(v) = ((v)&~(m))|(s)
+
+#ifdef __ASSEMBLY__
+
+# define __REG(x)	io_p2v(x)
+# define __PREG(x)	io_v2p(x)
+
+#else
+
+# if 0
+#  define __REG(x)	(*((volatile u32 *)io_p2v(x)))
+# else
+/*
+ * This __REG() version gives the same results as the one above,  except
+ * that we are fooling gcc somehow so it generates far better and smaller
+ * assembly code for access to contigous registers.  
+ */
+#include <asm/types.h>
+typedef struct { volatile u32 offset[4096]; } __regbase;
+# define __REGP(x)	((__regbase *)((x)&~4095))->offset[((x)&4095)>>2]
+# define __REG(x)	__REGP(io_p2v(x))
+typedef struct { volatile u16 offset[4096]; } __regbase16;
+# define __REGP16(x)	((__regbase16 *)((x)&~4095))->offset[((x)&4095)>>1]
+# define __REG16(x)	__REGP16(io_p2v(x))
+typedef struct { volatile u8 offset[4096]; } __regbase8;
+# define __REGP8(x)	((__regbase8 *)((x)&~4095))->offset[(x)&4095]
+# define __REG8(x)	__REGP8(io_p2v(x))
+#endif /* 0 */
+
+# define __REG2(x,y)	\
+	( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+				  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+
+# define __PREG(x)	(io_v2p((u32)&(x)))
+
+/* include CGU header */
+#include "cgu.h"
+
+#endif /*__ASSEMBLY__ */
+
+
+#include "registers.h"
+
+#endif
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/i2c.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/i2c.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/i2c.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/i2c.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,76 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/i2c.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * LPC313x-specific tweaks for NXP I2C block
+ *
+ * Based on mach-pnx4008/include/mach/i2c.h by Vitaly Wool <vwool@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_I2C_H__
+#define __ASM_ARCH_I2C_H__
+
+enum {
+	mstatus_tdi = 0x00000001,
+	mstatus_afi = 0x00000002,
+	mstatus_nai = 0x00000004,
+	mstatus_drmi = 0x00000008,
+	mstatus_active = 0x00000020,
+	mstatus_scl = 0x00000040,
+	mstatus_sda = 0x00000080,
+	mstatus_rff = 0x00000100,
+	mstatus_rfe = 0x00000200,
+	mstatus_tff = 0x00000400,
+	mstatus_tfe = 0x00000800,
+};
+
+enum {
+	mcntrl_tdie = 0x00000001,
+	mcntrl_afie = 0x00000002,
+	mcntrl_naie = 0x00000004,
+	mcntrl_drmie = 0x00000008,
+	mcntrl_rffie = 0x00000020,
+	mcntrl_daie = 0x00000040,
+	mcntrl_tffie = 0x00000080,
+	mcntrl_reset = 0x00000100,
+};
+
+enum {
+	rw_bit = 1 << 0,
+	start_bit = 1 << 8,
+	stop_bit = 1 << 9,
+};
+
+#define I2C_REG_RX(a)	((a)->ioaddr)		/* Rx FIFO reg (RO) */
+#define I2C_REG_TX(a)	((a)->ioaddr)		/* Tx FIFO reg (WO) */
+#define I2C_REG_STS(a)	((a)->ioaddr + 0x04)	/* Status reg (RO) */
+#define I2C_REG_CTL(a)	((a)->ioaddr + 0x08)	/* Ctl reg */
+#define I2C_REG_CKH(a)	((a)->ioaddr + 0x0C)	/* Clock divider high */
+#define I2C_REG_CKL(a)	((a)->ioaddr + 0x10)	/* Clock divider low */
+#define I2C_REG_ADR(a)	((a)->ioaddr + 0x14)	/* I2C address */
+#define I2C_REG_RFL(a)	((a)->ioaddr + 0x18)	/* Rx FIFO level (RO) */
+#define I2C_REG_TFL(a)	((a)->ioaddr + 0x1c)	/* Tx FIFO level (RO) */
+#define I2C_REG_RXB(a)	((a)->ioaddr + 0x20)	/* Num of bytes Rx-ed (RO) */
+#define I2C_REG_TXB(a)	((a)->ioaddr + 0x24)	/* Num of bytes Tx-ed (RO) */
+#define I2C_REG_TXS(a)	((a)->ioaddr + 0x28)	/* Tx slave FIFO (RO) */
+#define I2C_REG_STFL(a)	((a)->ioaddr + 0x2c)	/* Tx slave FIFO level (RO) */
+
+#define I2C_CHIP_NAME		"LPC313x-I2C"
+
+#endif				/* __ASM_ARCH_I2C_H___ */
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/io.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/io.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/io.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/io.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,33 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/io.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * IO space defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <mach/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		((void __iomem *)(a))
+#define __mem_pci(a)	(a)
+
+#endif
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/irqs.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/irqs.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/irqs.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/irqs.h	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,196 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/irqs.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  IRQ defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+
+
+# define IRQ_EVT_ROUTER0  1        /*interrupts from Event router 0*/
+# define IRQ_EVT_ROUTER1  2        /*interrupts from Event router 1*/
+# define IRQ_EVT_ROUTER2  3        /*interrupts from Event router 2*/
+# define IRQ_EVT_ROUTER3  4        /*interrupts from Event router 3*/
+# define IRQ_TIMER0       5        /*Timer 0 IRQ */
+# define IRQ_TIMER1       6        /*Timer 1 IRQ */
+# define IRQ_TIMER2       7        /*Timer 2 IRQ */
+# define IRQ_TIMER3       8        /*Timer 3 IRQ */
+# define IRQ_ADC          9        /*10bit ADC irq*/
+# define IRQ_UART         10       /*UART irq */
+# define IRQ_I2C0         11       /*I2C 0 IRQ */
+# define IRQ_I2C1         12       /*I2C 1 IRQ */
+# define IRQ_I2S0_OUT     13       /*I2S 0 out IRQ */
+# define IRQ_I2S1_OUT     14       /*I2S 1 out IRQ */
+# define IRQ_I2S0_IN      15       /*I2S 0 IN IRQ */
+# define IRQ_I2S1_IN      16       /*I2S 1 IN IRQ */
+# define IRQ_LCD          18       /*LCD irq */
+# define IRQ_SPI_SMS      19       /*SPI SMS IRQ */
+# define IRQ_SPI_TX       20       /*SPI Transmit IRQ */
+# define IRQ_SPI_RX       21       /*SPI Receive IRQ */
+# define IRQ_SPI_OVR      22       /*SPI overrun IRQ */
+# define IRQ_SPI          23       /*SPI interrupt IRQ */
+# define IRQ_DMA          24       /*DMA irq */
+# define IRQ_NAND_FLASH   25       /*NAND flash irq */
+# define IRQ_MCI          26       /*MCI irq */
+# define IRQ_USB          27       /*USB irq */
+# define IRQ_ISRAM0       28       /*ISRAM0 irq */
+# define IRQ_ISRAM1       29       /*ISRAM1 irq */
+
+
+# define NR_IRQ_CPU	  30	/* IRQs directly recognized by CPU */
+
+#define IRQ_EVT_START   NR_IRQ_CPU
+
+/* System specific IRQs */
+#include "event_router.h"
+
+/* Other chip IRQs routed through event router.
+ * These IRQs should be treated as board IRQs but they are
+ * common for all boards.
+ */
+#define IRQ_WDT        30  /* Watchdog interrupt */
+#define IRQ_VBUS_EN    31  /* VBUS power enable */
+#define IRQ_VBUS_OVRC  32  /* Detect VBUS over current - Host mode */
+#define IRQ_USB_ID     33  /* Detect ID pin change - OTG */
+
+#define _INTERNAL_IRQ_EVENT_MAP	\
+	{IRQ_WDT, EVT_wdog_m0, EVT_RISING_EDGE}, \
+	{IRQ_VBUS_EN, EVT_usb_otg_vbus_pwr_en, EVT_FALLING_EDGE}, \
+	{IRQ_VBUS_OVRC, EVT_USB_VBUS, EVT_FALLING_EDGE}, \
+	{IRQ_USB_ID, EVT_USB_ID, EVT_ACTIVE_LOW}, \
+
+#if defined(CONFIG_LPC3152_AD)
+/* For chips with analog die there are some more AD events routed
+ * through event router.
+ */
+#define IRQ_RTC	        34
+#define IRQ_PLAY        35
+#define NR_IRQ_CHIP_EVT	6
+
+#define AD_IRQ_EVENT_MAP	\
+	{IRQ_RTC, EVT_AD_NINT_I, EVT_ACTIVE_LOW}, \
+	{IRQ_PLAY, EVT_PLAY_DET_I, EVT_ACTIVE_HIGH}, \
+
+#define CHIP_IRQ_EVENT_MAP   _INTERNAL_IRQ_EVENT_MAP \
+	AD_IRQ_EVENT_MAP 
+
+#else
+#define CHIP_IRQ_EVENT_MAP   _INTERNAL_IRQ_EVENT_MAP
+#define NR_IRQ_CHIP_EVT	     4
+#endif
+
+/* now compute the board start IRQ number */
+#define IRQ_BOARD_START   (NR_IRQ_CPU + NR_IRQ_CHIP_EVT)
+
+/* Route all internal chip events to IRQ_EVT_ROUTER0 */
+#define IRQ_EVTR0_START        IRQ_EVT_START
+#define IRQ_EVTR0_END          (IRQ_BOARD_START - 1)
+
+
+#if defined (CONFIG_MACH_VAL3153) 
+
+# define IRQ_CS8900_ETH_INT  IRQ_BOARD_START	/* Ethernet chip */
+# define IRQ_SDMMC_CD0       (IRQ_BOARD_START + 1)	/* SD card detect */
+# define IRQ_SDMMC_CD1       (IRQ_BOARD_START + 2)	/* SD card detect */
+# define NR_IRQ_BOARD        3
+
+/* now define board irq to event pin map */
+#define BOARD_IRQ_EVENT_MAP	{ \
+	CHIP_IRQ_EVENT_MAP \
+	{IRQ_CS8900_ETH_INT, EVT_GPIO16, EVT_ACTIVE_HIGH}, \
+	{IRQ_SDMMC_CD0, EVT_GPIO12, EVT_ACTIVE_HIGH}, \
+	{IRQ_SDMMC_CD1, EVT_GPIO13, EVT_ACTIVE_HIGH}, \
+	}
+/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
+   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding 
+   group triggers.
+*/
+#define IRQ_EVTR1_START        IRQ_CS8900_ETH_INT
+#define IRQ_EVTR1_END          IRQ_CS8900_ETH_INT
+#define IRQ_EVTR2_START        IRQ_SDMMC_CD0
+#define IRQ_EVTR2_END          IRQ_SDMMC_CD0
+#define IRQ_EVTR3_START        IRQ_SDMMC_CD1
+#define IRQ_EVTR3_END          IRQ_SDMMC_CD1
+
+
+#elif defined (CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
+# define IRQ_DM9000_ETH_INT   IRQ_BOARD_START	/* Ethernet chip */
+# define IRQ_SDMMC_CD         (IRQ_BOARD_START + 1)	/* SD card detect */
+# define IRQ_EA_VBUS_OVRC     (IRQ_BOARD_START + 2)	/* Over current indicator */
+# define NR_IRQ_BOARD         3
+
+/* now define board irq to event pin map */
+#define BOARD_IRQ_EVENT_MAP	{ \
+	CHIP_IRQ_EVENT_MAP \
+	{IRQ_DM9000_ETH_INT, EVT_mNAND_RYBN3, EVT_ACTIVE_HIGH}, \
+	{IRQ_SDMMC_CD, EVT_mI2STX_BCK0, EVT_ACTIVE_LOW}, \
+	{IRQ_EA_VBUS_OVRC, EVT_I2SRX_WS0, EVT_ACTIVE_LOW}, \
+	}
+/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
+   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding 
+   group triggers.
+*/
+#define IRQ_EVTR1_START        IRQ_DM9000_ETH_INT
+#define IRQ_EVTR1_END          IRQ_DM9000_ETH_INT
+#define IRQ_EVTR2_START        IRQ_SDMMC_CD
+#define IRQ_EVTR2_END          IRQ_SDMMC_CD
+#define IRQ_EVTR3_START        IRQ_EA_VBUS_OVRC
+#define IRQ_EVTR3_END          IRQ_EA_VBUS_OVRC
+
+#elif defined (CONFIG_MACH_VAL3154)
+# define IRQ_SDMMC_CD	 IRQ_BOARD_START 	/* SD card detect */
+# define NR_IRQ_BOARD	 1
+
+/* now define board irq to event pin map */
+#define BOARD_IRQ_EVENT_MAP	{ \
+	CHIP_IRQ_EVENT_MAP \
+	{IRQ_SDMMC_CD, EVT_mI2STX_BCK0, EVT_ACTIVE_LOW}, \
+	}
+/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
+   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding 
+   group triggers.
+*/
+#define IRQ_EVTR1_START        IRQ_SDMMC_CD
+#define IRQ_EVTR1_END          IRQ_SDMMC_CD
+#define IRQ_EVTR2_START        0
+#define IRQ_EVTR2_END          0
+#define IRQ_EVTR3_START        0
+#define IRQ_EVTR3_END          0
+
+#else
+# define NR_IRQ_BOARD          0
+#define IRQ_EVTR0_START        0
+#define IRQ_EVTR0_END          0
+#define IRQ_EVTR1_START        0
+#define IRQ_EVTR1_END          0
+#define IRQ_EVTR2_START        0
+#define IRQ_EVTR2_END          0
+#define IRQ_EVTR3_START        0
+#define IRQ_EVTR3_END          0
+
+#endif
+
+
+#define NR_IRQS		(NR_IRQ_CPU + NR_IRQ_CHIP_EVT + NR_IRQ_BOARD)
+
+#endif
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/memory.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/memory.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/memory.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/memory.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,38 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/memory.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  Memory defines for machines with LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET	UL(0x30000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+#endif
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/registers.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/registers.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/registers.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/registers.h	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,658 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/registers.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Register defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_REGISTERS_H
+#define __ASM_ARCH_REGISTERS_H
+
+
+/***********************************************************************
+ * Interrupt controller register definitions
+ **********************************************************************/
+#define INTC_IRQ_PRI_MASK     __REG(INTC_PHYS + 0x000)
+#define INTC_FIQ_PRI_MASK     __REG(INTC_PHYS + 0x004)
+#define INTC_IRQ_VEC_BASE     __REG(INTC_PHYS + 0x100)
+#define INTC_FIQ_VEC_BASE     __REG(INTC_PHYS + 0x104)
+#define INTC_REQ_REG(irq)     __REG(INTC_PHYS + 0x400 + ((irq) << 2))
+
+#define INTC_REQ_PEND         _BIT(31)
+#define INTC_REQ_SET_SWINT    _BIT(30)
+#define INTC_REQ_CLR_SWINT    _BIT(29)
+#define INTC_REQ_WE_PRIO_LVL  _BIT(28)
+#define INTC_REQ_WE_TARGET    _BIT(27)
+#define INTC_REQ_WE_ENABLE    _BIT(26)
+#define INTC_REQ_WE_ACT_LOW   _BIT(25)
+#define INTC_REQ_ACT_LOW      _BIT(17)
+#define INTC_REQ_ENABLE       _BIT(16)
+#define INTC_REQ_TARGET(n)    _SBF(8, ((n) & 0x3F))
+#define INTC_REQ_PRIO_LVL(n)  ((n) & 0xFF)
+#define INTC_REQ_TARGET_IRQ   (INTC_REQ_WE_TARGET)
+#define INTC_REQ_TARGET_FIQ   (INTC_REQ_WE_TARGET | _BIT(8))
+
+/***********************************************************************
+ * Event router register definitions
+ **********************************************************************/
+#define EVRT_INT_PEND(bank)  __REG (EVTR_PHYS + 0xC00 + ((bank) << 2))
+#define EVRT_INT_CLR(bank)   __REG (EVTR_PHYS + 0xC20 + ((bank) << 2))
+#define EVRT_INT_SET(bank)   __REG (EVTR_PHYS + 0xC40 + ((bank) << 2))
+#define EVRT_MASK(bank)      __REG (EVTR_PHYS + 0xC60 + ((bank) << 2))
+#define EVRT_MASK_CLR(bank)  __REG (EVTR_PHYS + 0xC80 + ((bank) << 2))
+#define EVRT_MASK_SET(bank)  __REG (EVTR_PHYS + 0xCA0 + ((bank) << 2))
+#define EVRT_APR(bank)       __REG (EVTR_PHYS + 0xCC0 + ((bank) << 2))
+#define EVRT_ATR(bank)       __REG (EVTR_PHYS + 0xCE0 + ((bank) << 2))
+#define EVRT_RSR(bank)       __REG (EVTR_PHYS + 0xD20 + ((bank) << 2))
+#define EVRT_OUT_PEND(vec,bank)     __REG (EVTR_PHYS + 0x1000 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK(vec,bank)     __REG (EVTR_PHYS + 0x1400 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK_CLR(vec,bank) __REG (EVTR_PHYS + 0x1800 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK_SET(vec,bank) __REG (EVTR_PHYS + 0x1C00 + ((vec) << 5) + ((bank) << 2))
+
+/***********************************************************************
+ * WDT register definitions
+ **********************************************************************/
+#define WDT_IR       __REG (WDT_PHYS + 0x00)
+#define WDT_TCR      __REG (WDT_PHYS + 0x04)
+#define WDT_TC       __REG (WDT_PHYS + 0x08)
+#define WDT_PR       __REG (WDT_PHYS + 0x0c)
+#define WDT_MCR      __REG (WDT_PHYS + 0x14)
+#define WDT_MR0      __REG (WDT_PHYS + 0x18)
+#define WDT_MR1      __REG (WDT_PHYS + 0x1c)
+#define WDT_EMR      __REG (WDT_PHYS + 0x3c)
+
+#define WDT_IR_MR1        _BIT(1)
+#define WDT_IR_MR0        _BIT(0)
+#define WDT_TCR_CNT_RESET _BIT(1)
+#define WDT_TCR_CNT_EN    _BIT(0)
+#define WDT_MCR_STOP_MR1  _BIT(5)
+#define WDT_MCR_RESET_MR1 _BIT(4)
+#define WDT_MCR_INT_MR1   _BIT(3)
+#define WDT_MCR_STOP_MR0  _BIT(2)
+#define WDT_MCR_RESET_MR0 _BIT(1)
+#define WDT_MCR_INT_MR0   _BIT(0)
+#define WDT_EMR_CTRL0(n)  _SBF(4,((n) &0x3))
+#define WDT_EMR_CTRL1(n)  _SBF(6,((n) &0x3))
+#define WDT_EMR_M1        _BIT(1)
+#define WDT_EMR_M0        _BIT(0)
+
+/***********************************************************************
+ * Timer register definitions
+ **********************************************************************/
+#define TIMER_LOAD(base)      __REG ((base) + 0x00)
+#define TIMER_VALUE(base)     __REG ((base) + 0x04)
+#define TIMER_CONTROL(base)   __REG ((base) + 0x08)
+#define TIMER_CLEAR(base)     __REG ((base) + 0x0c)
+
+#define TM_CTRL_ENABLE    _BIT(7)
+#define TM_CTRL_MODE      _BIT(6)
+#define TM_CTRL_PERIODIC  _BIT(6)
+#define TM_CTRL_PS1       _SBF(2, 0)
+#define TM_CTRL_PS16      _SBF(2, 1)
+#define TM_CTRL_PS256     _SBF(2, 2)
+#define TM_CTRL_PS_MASK   _SBF(2, 0x3)
+
+/***********************************************************************
+ * UART register definitions
+ **********************************************************************/
+#define UART_DLL_REG      __REG (UART_PHYS + 0x00)
+#define UART_FIFO_REG     __REG (UART_PHYS + 0x00)
+#define UART_IE_REG       __REG (UART_PHYS + 0x04)
+#define UART_DLM_REG      __REG (UART_PHYS + 0x04)
+#define UART_IIR_REG      __REG (UART_PHYS + 0x08)
+#define UART_FCR_REG      __REG (UART_PHYS + 0x08)
+#define UART_LCR_REG      __REG (UART_PHYS + 0x0c)
+#define UART_MCR_REG      __REG (UART_PHYS + 0x10)
+#define UART_LSR_REG      __REG (UART_PHYS + 0x14)
+#define UART_MSR_REG      __REG (UART_PHYS + 0x18)
+#define UART_SCR_REG      __REG (UART_PHYS + 0x1c)
+#define UART_ACR_REG      __REG (UART_PHYS + 0x20)
+#define UART_ICR_REG      __REG (UART_PHYS + 0x24)
+#define UART_FDR_REG      __REG (UART_PHYS + 0x28)
+
+/***********************************************************************
+ * SPI register definitions
+ **********************************************************************/
+#define SPI_CONFIG_REG    __REG (SPI_PHYS + 0x00)
+#define SPI_SLV_ENAB_REG  __REG (SPI_PHYS + 0x04)
+#define SPI_TXF_FLUSH_REG __REG (SPI_PHYS + 0x08)
+#define SPI_FIFO_DATA_REG __REG (SPI_PHYS + 0x0C)
+#define SPI_NHP_POP_REG   __REG (SPI_PHYS + 0x10)
+#define SPI_NHP_MODE_REG  __REG (SPI_PHYS + 0x14)
+#define SPI_DMA_SET_REG   __REG (SPI_PHYS + 0x18)
+#define SPI_STS_REG       __REG (SPI_PHYS + 0x1C)
+#define SPI_HWINFO_REG    __REG (SPI_PHYS + 0x20)
+#define SPI_SLV_SET1_REG(slv) __REG (SPI_PHYS + 0x24 + (8 * slv))
+#define SPI_SLV_SET2_REG(slv) __REG (SPI_PHYS + 0x28 + (8 * slv))
+#define SPI_INT_TRSH_REG  __REG (SPI_PHYS + 0xFD4)
+#define SPI_INT_CLRE_REG  __REG (SPI_PHYS + 0xFD8)
+#define SPI_INT_SETE_REG  __REG (SPI_PHYS + 0xFDC)
+#define SPI_INT_STS_REG   __REG (SPI_PHYS + 0xFE0)
+#define SPI_INT_ENAB_REG  __REG (SPI_PHYS + 0xFE4)
+#define SPI_INT_CLRS_REG  __REG (SPI_PHYS + 0xFE8)
+#define SPI_INT_SETS_REG  __REG (SPI_PHYS + 0xFEC)
+#define SPI_MOD_ID_REG    __REG (SPI_PHYS + 0xFFC)
+
+/* SPI device contants */
+#define SPI_FIFO_DEPTH  64 /* 64 words (16bit) deep */
+#define SPI_NUM_SLAVES  3  /* number of slaves supported */
+#define SPI_MAX_DIV2    254
+#define SPI_MAX_DIVIDER 65024 /* = 254 * (255 + 1) */
+#define SPI_MIN_DIVIDER 2
+
+/* SPI Configuration register definitions (SPI_CONFIG_REG) */
+#define SPI_CFG_INTER_DLY(n)      _SBF(16, ((n) & 0xFFFF))
+#define SPI_CFG_INTER_DLY_GET(n)  (((n) >> 16) & 0xFFFF)
+#define SPI_CFG_UPDATE_EN         _BIT(7)
+#define SPI_CFG_SW_RESET          _BIT(6)
+#define SPI_CFG_SLAVE_DISABLE     _BIT(4)
+#define SPI_CFG_MULTI_SLAVE       _BIT(3)
+#define SPI_CFG_LOOPBACK          _BIT(2)
+#define SPI_CFG_SLAVE_MODE        _BIT(1)
+#define SPI_CFG_ENABLE            _BIT(0)
+
+/* SPI slave_enable register definitions (SPI_SLV_ENAB_REG) */
+#define SPI_SLV_EN(n)             _SBF(((n) << 1), 0x1)
+#define SPI_SLV_SUSPEND(n)        _SBF(((n) << 1), 0x3)
+
+/* SPI tx_fifo_flush register definitions (SPI_TXF_FLUSH_REG) */
+#define SPI_TXFF_FLUSH            _BIT(1)
+
+/* SPI dma_settings register definitions (SPI_DMA_SET_REG) */
+#define SPI_DMA_TX_EN             _BIT(1)
+#define SPI_DMA_RX_EN             _BIT(0)
+
+/* SPI status register definitions (SPI_STS_REG) */
+#define SPI_ST_SMS_BUSY           _BIT(5)
+#define SPI_ST_BUSY               _BIT(4)
+#define SPI_ST_RX_FF              _BIT(3)
+#define SPI_ST_RX_EMPTY           _BIT(2)
+#define SPI_ST_TX_FF              _BIT(1)
+#define SPI_ST_TX_EMPTY           _BIT(0)
+
+/* SPI slv_setting registers definitions (SPI_SLV_SET1_REG) */
+#define SPI_SLV1_INTER_TX_DLY(n)  _SBF(24, ((n) & 0xFF))
+#define SPI_SLV1_NUM_WORDS(n)     _SBF(16, ((n) & 0xFF))
+#define SPI_SLV1_CLK_PS(n)        _SBF(8, ((n) & 0xFF))
+#define SPI_SLV1_CLK_PS_GET(n)    (((n) >> 8) & 0xFF)
+#define SPI_SLV1_CLK_DIV1(n)      ((n) & 0xFF)
+#define SPI_SLV1_CLK_DIV1_GET(n)  ((n) & 0xFF)
+
+/* SPI slv_setting registers definitions (SPI_SLV_SET2_REG) */
+#define SPI_SLV2_PPCS_DLY(n)      _SBF(9, ((n) & 0xFF))
+#define SPI_SLV2_CS_HIGH          _BIT(8)
+#define SPI_SLV2_SSI_MODE         _BIT(7)
+#define SPI_SLV2_SPO              _BIT(6)
+#define SPI_SLV2_SPH              _BIT(5)
+#define SPI_SLV2_WD_SZ(n)         ((n) & 0x1F)
+
+/* SPI int_threshold registers definitions (SPI_INT_TRSH_REG) */
+#define SPI_INT_TSHLD_TX(n)       _SBF(8, ((n) & 0xFF))
+#define SPI_INT_TSHLD_RX(n)       ((n) & 0xFF)
+
+/* SPI intterrupt registers definitions ( SPI_INT_xxx) */
+#define SPI_SMS_INT               _BIT(4)
+#define SPI_TX_INT                _BIT(3)
+#define SPI_RX_INT                _BIT(2)
+#define SPI_TO_INT                _BIT(1)
+#define SPI_OVR_INT               _BIT(0)
+#define SPI_ALL_INTS              (SPI_SMS_INT | SPI_TX_INT | SPI_RX_INT | SPI_TO_INT | SPI_OVR_INT)
+
+/***********************************************************************
+* Audio Subsystem (ADSS) register definitions
+**********************************************************************/
+
+/* I2S Controller Module Register Structure */
+#define I2S_FORMAT_SETTINGS       __REG (I2S_PHYS + 0x00)
+#define I2S_CFG_MUX_SETTINGS      __REG (I2S_PHYS + 0x04)
+#define I2S_CLASSED_CFG           __REG (I2S_PHYS + 0x08)
+#define I2S_CLASSED_STS           __REG (I2S_PHYS + 0x0C)
+#define I2S_N_SOF_COUNTER         __REG (I2S_PHYS + 0x10)
+
+/* I2S channels */
+#define I2S_CH_TX0 1
+#define I2S_CH_TX1 2
+#define I2S_CH_RX0 3
+#define I2S_CH_RX1 4
+
+/* I2S channel specific registers */
+#define I2S_CH_LEFT_16BIT(n)      __REG (I2S_PHYS + ((n) * 0x80) + 0x00)
+#define I2S_CH_RIGHT_16BIT(n)     __REG (I2S_PHYS + ((n) * 0x80) + 0x04)
+#define I2S_CH_LEFT_24BIT(n)      __REG (I2S_PHYS + ((n) * 0x80) + 0x08)
+#define I2S_CH_RIGHT_24BIT(n)     __REG (I2S_PHYS + ((n) * 0x80) + 0x0C)
+#define I2S_CH_INT_STATUS(n)      __REG (I2S_PHYS + ((n) * 0x80) + 0x10)
+#define I2S_CH_INT_MASK(n)        __REG (I2S_PHYS + ((n) * 0x80) + 0x14)
+#define I2S_CH_LEFT32(n)          __REG (I2S_PHYS + ((n) * 0x80) + 0x20)
+#define I2S_CH_RIGHT32(n)         __REG (I2S_PHYS + ((n) * 0x80) + 0x40)
+#define I2S_CH_INTERLEAVED(n)     __REG (I2S_PHYS + ((n) * 0x80) + 0x60)
+
+/* I2S format settings register defines */
+#define I2S_FORMAT_I2S            0x3
+#define I2S_FORMAT_LSB16          0x4
+#define I2S_FORMAT_LSB18          0x5
+#define I2S_FORMAT_LSB20          0x6
+#define I2S_FORMAT_LSB24          0x7
+#define I2S_FORMAT_MASK           0x7
+#define I2S_SET_FORMAT(n, s)      ((s) << (((n) - 1) * 3))
+
+/* I2S Mux configuration setting defines */
+#define I2S_RXO_SELECT_MASTER     _BIT(1)
+#define I2S_RX1_SELECT_MASTER     _BIT(2)
+
+/* I2S interrupt status and mask bits */
+#define I2S_FIFO_RIGHT_UNDERRUN   _BIT(0)
+#define I2S_FIFO_LEFT_UNDERRUN    _BIT(1)
+#define I2S_FIFO_RIGHT_OVERRUN    _BIT(2)
+#define I2S_FIFO_LEFT_OVERRUN     _BIT(3)
+#define I2S_FIFO_LEFT_FULL        _BIT(4)
+#define I2S_FIFO_LEFT_HALF_FULL   _BIT(5) /* RX only */
+#define I2S_FIFO_LEFT_HALF_EMPTY  _BIT(5) /* TX only */
+#define I2S_FIFO_LEFT_NOT_EMPTY   _BIT(6) /* RX only */
+#define I2S_FIFO_LEFT_EMPTY       _BIT(6) /* TX only */
+#define I2S_FIFO_RIGHT_FULL       _BIT(7)
+#define I2S_FIFO_RIGHT_HALF_FULL  _BIT(8) /* RX only */
+#define I2S_FIFO_RIGHT_HALF_EMPTY _BIT(8) /* TX only */
+#define I2S_FIFO_RIGHT_NOT_EMPTY  _BIT(9) /* RX only */
+#define I2S_FIFO_RIGHT_EMPTY      _BIT(9) /* TX only */
+#define I2S_FIFO_ALL_MASK         0x3FF
+
+/***********************************************************************
+ * ADC_REG register definitions
+ **********************************************************************/
+#define ADC_CON_REG            __REG (ADC_PHYS + 0x20)
+
+/***********************************************************************
+ * SYS_REG register definitions
+ **********************************************************************/
+#define SYS_RNG_OSC_CFG        __REG (SYS_PHYS + 0x14)
+#define SYS_ADC_PD             __REG (SYS_PHYS + 0x18)
+#define SYS_SDMMC_DELAYMODES   __REG (SYS_PHYS + 0x2C)
+#define SYS_USB_ATX_PLL_PD_REG __REG (SYS_PHYS + 0x30)
+#define SYS_USB_OTG_CFG        __REG (SYS_PHYS + 0x34)
+#define SYS_USB_OTG_LED_CTL    __REG (SYS_PHYS + 0x38)
+#define SYS_USB_PLL_NDEC       __REG (SYS_PHYS + 0x40)
+#define SYS_USB_PLL_MDEC       __REG (SYS_PHYS + 0x44)
+#define SYS_USB_PLL_PDEC       __REG (SYS_PHYS + 0x48)
+#define SYS_USB_PLL_SELR       __REG (SYS_PHYS + 0x4C)
+#define SYS_USB_PLL_SELI       __REG (SYS_PHYS + 0x50)
+#define SYS_USB_PLL_SELP       __REG (SYS_PHYS + 0x54)
+
+#define SYS_MPMC_DELAY      __REG (SYS_PHYS + 0x68)
+#define SYS_MPMC_WTD_DEL0   __REG (SYS_PHYS + 0x6C)
+#define SYS_MPMC_WTD_DEL1   __REG (SYS_PHYS + 0x70)
+#define SYS_MPMC_TESTMODE0  __REG (SYS_PHYS + 0x78)
+#define SYS_REMAP_ADDR      __REG (SYS_PHYS + 0x84)
+#define SYS_MUX_LCD_EBI     __REG (SYS_PHYS + 0x90)
+#define SYS_MUX_GPIO_MCI    __REG (SYS_PHYS + 0x94)
+#define SYS_MUX_NAND_MCI    __REG (SYS_PHYS + 0x98)
+
+/***********************************************************************
+ * GPIO register definitions
+ **********************************************************************/
+#define GPIO_STATE(port)     __REG (GPIO_PHYS + (port) + 0x00)
+#define GPIO_STATE_M0(port)  __REG (GPIO_PHYS + (port) + 0x10)
+#define GPIO_M0_SET(port)    __REG (GPIO_PHYS + (port) + 0x14)
+#define GPIO_M0_RESET(port)  __REG (GPIO_PHYS + (port) + 0x18)
+#define GPIO_STATE_M1(port)  __REG (GPIO_PHYS + (port) + 0x20)
+#define GPIO_M1_SET(port)    __REG (GPIO_PHYS + (port) + 0x24)
+#define GPIO_M1_RESET(port)  __REG (GPIO_PHYS + (port) + 0x28)
+
+#define GPIO_OUT_LOW(port, pin)  do { GPIO_M1_SET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
+#define GPIO_OUT_HIGH(port, pin) do { GPIO_M1_SET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
+#define GPIO_IN(port, pin)       do { GPIO_M1_RESET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
+#define GPIO_DRV_IP(port, pin)   do { GPIO_M1_RESET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
+
+#define IOCONF_EBI_MCI       (0x000)
+#define IOCONF_EBI_I2STX_0   (0x040)
+#define IOCONF_CGU           (0x080)
+#define IOCONF_I2SRX_0       (0x0c0)
+#define IOCONF_I2SRX_1       (0x100)
+#define IOCONF_I2STX_1       (0x140)
+#define IOCONF_EBI           (0x180)
+#define IOCONF_GPIO          (0x1c0)
+#define IOCONF_I2C1          (0x200)
+#define IOCONF_SPI           (0x240)
+#define IOCONF_NAND_CTRL     (0x280)
+#define IOCONF_PWM           (0x2c0)
+#define IOCONF_UART          (0x300)
+
+
+/***********************************************************************
+ * MPMC memory controller register definitions
+ **********************************************************************/
+#define MPMC_CTRL           __REG (MPMC_PHYS + 0x000)
+#define MPMC_STATUS         __REG (MPMC_PHYS + 0x004)
+#define MPMC_CONFIG         __REG (MPMC_PHYS + 0x008)
+#define MPMC_DYNCTL         __REG (MPMC_PHYS + 0x020)
+#define MPMC_DYNREF         __REG (MPMC_PHYS + 0x024)
+#define MPMC_DYRDCFG        __REG (MPMC_PHYS + 0x028)
+#define MPMC_DYTRP          __REG (MPMC_PHYS + 0x030)
+#define MPMC_DYTRAS         __REG (MPMC_PHYS + 0x034)
+#define MPMC_DYTSREX        __REG (MPMC_PHYS + 0x038)
+#define MPMC_DYTAPR         __REG (MPMC_PHYS + 0x03C)
+#define MPMC_DYTDAL         __REG (MPMC_PHYS + 0x040)
+#define MPMC_DYTWR          __REG (MPMC_PHYS + 0x044)
+#define MPMC_DYTRC          __REG (MPMC_PHYS + 0x048)
+#define MPMC_DYTRFC         __REG (MPMC_PHYS + 0x04C)
+#define MPMC_DYTXSR         __REG (MPMC_PHYS + 0x050)
+#define MPMC_DYTRRD         __REG (MPMC_PHYS + 0x054)
+#define MPMC_DYTMRD         __REG (MPMC_PHYS + 0x058)
+#define MPMC_STEXDWT        __REG (MPMC_PHYS + 0x080)
+#define MPMC_DYCONFIG       __REG (MPMC_PHYS + 0x100)
+#define MPMC_DYRASCAS       __REG (MPMC_PHYS + 0x104)
+#define MPMC_STCONFIG0      __REG (MPMC_PHYS + 0x200)
+#define MPMC_STWTWEN0       __REG (MPMC_PHYS + 0x204)
+#define MPMC_STWTOEN0       __REG (MPMC_PHYS + 0x208)
+#define MPMC_STWTRD0        __REG (MPMC_PHYS + 0x20C)
+#define MPMC_STWTPG0        __REG (MPMC_PHYS + 0x210)
+#define MPMC_STWTWR0        __REG (MPMC_PHYS + 0x214)
+#define MPMC_STWTTURN0      __REG (MPMC_PHYS + 0x218)
+#define MPMC_STCONFIG1      __REG (MPMC_PHYS + 0x220)
+#define MPMC_STWTWEN1       __REG (MPMC_PHYS + 0x224)
+#define MPMC_STWTOEN1       __REG (MPMC_PHYS + 0x228)
+#define MPMC_STWTRD1        __REG (MPMC_PHYS + 0x22C)
+#define MPMC_STWTPG1        __REG (MPMC_PHYS + 0x230)
+#define MPMC_STWTWR1        __REG (MPMC_PHYS + 0x234)
+#define MPMC_STWTTURN1      __REG (MPMC_PHYS + 0x238)
+
+#define NS_TO_MPMCCLK(ns, clk)	(((ns)*((clk + 500)/1000) + 500000)/1000000)
+/* MPMC Controller Bit Field constants*/
+#define MPMC_CTL_LOW_PWR               _BIT(2)
+#define MPMC_CTL_ENABLE                _BIT(0)
+/* MPMC status Bit Field constants*/
+#define MPMC_STATUS_SA                 _BIT(2)
+#define MPMC_STATUS_WR_BUF             _BIT(1)
+#define MPMC_STATUS_BUSY               _BIT(0)
+/* MPMC config Bit Field constants*/
+#define MPMC_CFG_SDCCLK_1_2            _BIT(8)
+#define MPMC_CFG_SDCCLK_1_1            (0)
+/* SDRAM Controller Bit Field constants*/
+#define MPMC_SDRAMC_CTL_DP             _BIT(13)
+#define MPMC_SDRAMC_CTL_NORMAL_CMD     _SBF(7,0)
+#define MPMC_SDRAMC_CTL_MODE_CMD       _SBF(7,1)
+#define MPMC_SDRAMC_CTL_PALL_CMD       _SBF(7,2)
+#define MPMC_SDRAMC_CTL_NOP_CMD        _SBF(7,3)
+#define MPMC_SDRAMC_CTL_MCC            _BIT(5)
+#define MPMC_SDRAMC_CTL_SR             _BIT(2)
+#define MPMC_SDRAMC_CTL_CS             _BIT(1)
+#define MPMC_SDRAMC_CTL_CE             _BIT(0)
+/* SDRAM Config Bit Field constants*/
+#define MPMC_SDRAMC_CFG_SDRAM_MD       _SBF(3,0)
+#define MPMC_SDRAMC_CFG_LOW_PWR_MD     _SBF(3,1)
+#define MPMC_SDRAMC_CFG_SYNC_FLASH     _SBF(3,2)
+#define MPMC_SDRAMC_CFG_BUF_EN         _BIT(19)
+#define MPMC_SDRAMC_CFG_WP             _BIT(20)
+
+
+/* SDRAM Read Config Bit Field constants*/
+#define MPMC_SDRAMC_RDCFG_CLKOUTDELAY_STG       _SBF(0,0)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_STG          _SBF(0,1)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_P1_STG       _SBF(0,2)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_P2_STG       _SBF(0,3)
+/* SDRAM RASCAS Bit Field constants*/
+#define MPMC_SDRAMC_RASCAS_CAS0        _SBF(8,0)
+#define MPMC_SDRAMC_RASCAS_CAS1        _SBF(8,1)
+#define MPMC_SDRAMC_RASCAS_CAS2        _SBF(8,2)
+#define MPMC_SDRAMC_RASCAS_CAS3        _SBF(8,3)
+#define MPMC_SDRAMC_RASCAS_RAS0        _SBF(0,0)
+#define MPMC_SDRAMC_RASCAS_RAS1        _SBF(0,1)
+#define MPMC_SDRAMC_RASCAS_RAS2        _SBF(0,2)
+#define MPMC_SDRAMC_RASCAS_RAS3        _SBF(0,3)
+
+/***********************************************************************
+ * SD/MMC MCI register definitions
+ **********************************************************************/
+#define SDMMC_CTRL            __REG (SDMMC_PHYS + 0x000)
+#define SDMMC_PWREN           __REG (SDMMC_PHYS + 0x004)
+#define SDMMC_CLKDIV          __REG (SDMMC_PHYS + 0x008)
+#define SDMMC_CLKSRC          __REG (SDMMC_PHYS + 0x00c)
+#define SDMMC_CLKENA          __REG (SDMMC_PHYS + 0x010)
+#define SDMMC_TMOUT           __REG (SDMMC_PHYS + 0x014)
+#define SDMMC_CTYPE           __REG (SDMMC_PHYS + 0x018)
+#define SDMMC_BLKSIZ          __REG (SDMMC_PHYS + 0x01c)
+#define SDMMC_BYTCNT          __REG (SDMMC_PHYS + 0x020)
+#define SDMMC_INTMASK         __REG (SDMMC_PHYS + 0x024)
+#define SDMMC_CMDARG          __REG (SDMMC_PHYS + 0x028)
+#define SDMMC_CMD             __REG (SDMMC_PHYS + 0x02c)
+#define SDMMC_RESP0           __REG (SDMMC_PHYS + 0x030)
+#define SDMMC_RESP1           __REG (SDMMC_PHYS + 0x034)
+#define SDMMC_RESP2           __REG (SDMMC_PHYS + 0x038)
+#define SDMMC_RESP3           __REG (SDMMC_PHYS + 0x03c)
+#define SDMMC_MINTSTS         __REG (SDMMC_PHYS + 0x040)
+#define SDMMC_RINTSTS         __REG (SDMMC_PHYS + 0x044)
+#define SDMMC_STATUS          __REG (SDMMC_PHYS + 0x048)
+#define SDMMC_FIFOTH          __REG (SDMMC_PHYS + 0x04c)
+#define SDMMC_TCBCNT          __REG (SDMMC_PHYS + 0x05c)
+#define SDMMC_TBBCNT          __REG (SDMMC_PHYS + 0x060)
+#define SDMMC_DEBNCE          __REG (SDMMC_PHYS + 0x064)
+#define SDMMC_USRID           __REG (SDMMC_PHYS + 0x068)
+#define SDMMC_VERID           __REG (SDMMC_PHYS + 0x06c)
+#define SDMMC_HCON            __REG (SDMMC_PHYS + 0x070)
+#define SDMMC_DATA            __REG (SDMMC_PHYS + 0x100)
+#define SDMMC_DATA_ADR        (SDMMC_PHYS + 0x100)
+
+/* Control register defines */
+#define SDMMC_CTRL_CEATA_INT_EN   _BIT(11)
+#define SDMMC_CTRL_SEND_AS_CCSD   _BIT(10)
+#define SDMMC_CTRL_SEND_CCSD      _BIT(9)
+#define SDMMC_CTRL_ABRT_READ_DATA _BIT(8)
+#define SDMMC_CTRL_SEND_IRQ_RESP  _BIT(7)
+#define SDMMC_CTRL_READ_WAIT      _BIT(6)
+#define SDMMC_CTRL_DMA_ENABLE     _BIT(5)
+#define SDMMC_CTRL_INT_ENABLE     _BIT(4)
+#define SDMMC_CTRL_DMA_RESET      _BIT(2)
+#define SDMMC_CTRL_FIFO_RESET     _BIT(1)
+#define SDMMC_CTRL_RESET          _BIT(0)
+/* Clock Enable register defines */
+#define SDMMC_CLKEN_LOW_PWR      _BIT(16)
+#define SDMMC_CLKEN_ENABLE       _BIT(0)
+/* time-out register defines */
+#define SDMMC_TMOUT_DATA(n)      _SBF(8, (n))
+#define SDMMC_TMOUT_DATA_MSK     0xFFFFFF00
+#define SDMMC_TMOUT_RESP(n)      ((n) & 0xFF)
+#define SDMMC_TMOUT_RESP_MSK     0xFF
+/* card-type register defines */
+#define SDMMC_CTYPE_8BIT         _BIT(16)
+#define SDMMC_CTYPE_4BIT         _BIT(0)
+/* Interrupt status & mask register defines */
+#define SDMMC_INT_SDIO           _BIT(16)
+#define SDMMC_INT_EBE            _BIT(15)
+#define SDMMC_INT_ACD            _BIT(14)
+#define SDMMC_INT_SBE            _BIT(13)
+#define SDMMC_INT_HLE            _BIT(12)
+#define SDMMC_INT_FRUN           _BIT(11)
+#define SDMMC_INT_HTO            _BIT(10)
+#define SDMMC_INT_DTO            _BIT(9)
+#define SDMMC_INT_RTO            _BIT(8)
+#define SDMMC_INT_DCRC           _BIT(7)
+#define SDMMC_INT_RCRC           _BIT(6)
+#define SDMMC_INT_RXDR           _BIT(5)
+#define SDMMC_INT_TXDR           _BIT(4)
+#define SDMMC_INT_DATA_OVER      _BIT(3)
+#define SDMMC_INT_CMD_DONE       _BIT(2)
+#define SDMMC_INT_RESP_ERR       _BIT(1)
+#define SDMMC_INT_CD             _BIT(0)
+#define SDMMC_INT_ERROR          0xbfc2
+/* Command register defines */
+#define SDMMC_CMD_START         _BIT(31)
+#define SDMMC_CMD_CCS_EXP       _BIT(23)
+#define SDMMC_CMD_CEATA_RD      _BIT(22)
+#define SDMMC_CMD_UPD_CLK       _BIT(21)
+#define SDMMC_CMD_INIT          _BIT(15)
+#define SDMMC_CMD_STOP          _BIT(14)
+#define SDMMC_CMD_PRV_DAT_WAIT  _BIT(13)
+#define SDMMC_CMD_SEND_STOP     _BIT(12)
+#define SDMMC_CMD_STRM_MODE     _BIT(11)
+#define SDMMC_CMD_DAT_WR        _BIT(10)
+#define SDMMC_CMD_DAT_EXP       _BIT(9)
+#define SDMMC_CMD_RESP_CRC      _BIT(8)
+#define SDMMC_CMD_RESP_LONG     _BIT(7)
+#define SDMMC_CMD_RESP_EXP      _BIT(6)
+#define SDMMC_CMD_INDX(n)       ((n) & 0x1F)
+/* Status register defines */
+#define SDMMC_GET_FCNT(x)       (((x)>>17) & 0x1FF)
+#define SDMMC_FIFO_SZ           32
+
+
+/***********************************************************************
+ * NAND Controller register definitions
+ **********************************************************************/
+#define NAND_IRQSTATUS1                __REG (NANDC_PHYS + 0x000)
+#define NAND_IRQMASK1                  __REG (NANDC_PHYS + 0x004)
+#define NAND_IRQSTATUSRAW1             __REG (NANDC_PHYS + 0x008)
+#define NAND_CONFIG                    __REG (NANDC_PHYS + 0x00C)
+#define NAND_IOCONFIG                  __REG (NANDC_PHYS + 0x010)
+#define NAND_TIMING1                   __REG (NANDC_PHYS + 0x014)
+#define NAND_TIMING2                   __REG (NANDC_PHYS + 0x018)
+#define NAND_SETCMD                    __REG (NANDC_PHYS + 0x020)
+#define NAND_SETADDR                   __REG (NANDC_PHYS + 0x024)
+#define NAND_WRITEDATA                 __REG (NANDC_PHYS + 0x028)
+#define NAND_SETCE                     __REG (NANDC_PHYS + 0x02C)
+#define NAND_READDATA                  __REG (NANDC_PHYS + 0x030)
+#define NAND_CHECKSTS                  __REG (NANDC_PHYS + 0x034)
+#define NAND_CONTROLFLOW               __REG (NANDC_PHYS + 0x038)
+#define NAND_GPIO1                     __REG (NANDC_PHYS + 0x040)
+#define NAND_GPIO2                     __REG (NANDC_PHYS + 0x044)
+#define NAND_IRQSTATUS2                __REG (NANDC_PHYS + 0x048)
+#define NAND_IRQMASK2                  __REG (NANDC_PHYS + 0x04C)
+#define NAND_IRQSTATUSRAW2             __REG (NANDC_PHYS + 0x050)
+#define NAND_ECCERRSTATUS              __REG (NANDC_PHYS + 0x078)
+
+/* NAND internal SDRAM address definitions*/
+#define NAND_BUFFER_ADRESS             __REG (IO_NAND_BUF_PHYS)
+
+/* Register description of NANDIRQSTATUS1 */
+#define NAND_NANDIRQSTATUS1_RB4_POS_EDGE       _BIT(31)
+#define NAND_NANDIRQSTATUS1_RB3_POS_EDGE       _BIT(30)
+#define NAND_NANDIRQSTATUS1_RB2_POS_EDGE       _BIT(29)
+#define NAND_NANDIRQSTATUS1_RB1_POS_EDGE       _BIT(28)
+#define NAND_NANDIRQSTATUS1_ERASED_RAM1        _BIT(27)
+#define NAND_NANDIRQSTATUS1_ERASED_RAM0        _BIT(26)
+#define NAND_NANDIRQSTATUS1_WR_RAM1            _BIT(25)
+#define NAND_NANDIRQSTATUS1_WR_RAM0            _BIT(24)
+#define NAND_NANDIRQSTATUS1_RD_RAM1            _BIT(23)
+#define NAND_NANDIRQSTATUS1_RD_RAM0            _BIT(22)
+#define NAND_NANDIRQSTATUS1_ECC_DEC_RAM0       _BIT(21)
+#define NAND_NANDIRQSTATUS1_ECC_ENC_RAM0       _BIT(20)
+#define NAND_NANDIRQSTATUS1_ECC_DEC_RAM1       _BIT(19)
+#define NAND_NANDIRQSTATUS1_ECC_ENC_RAM1       _BIT(18)
+#define NAND_NANDIRQSTATUS1_NOERR_RAM0         _BIT(17)
+#define NAND_NANDIRQSTATUS1_ERR1_RAM0          _BIT(16)
+#define NAND_NANDIRQSTATUS1_ERR2_RAM0          _BIT(15)
+#define NAND_NANDIRQSTATUS1_ERR3_RAM0          _BIT(14)
+#define NAND_NANDIRQSTATUS1_ERR4_RAM0          _BIT(13)
+#define NAND_NANDIRQSTATUS1_ERR5_RAM0          _BIT(12)
+#define NAND_NANDIRQSTATUS1_ERR_UNR_RAM0       _BIT(11)
+#define NAND_NANDIRQSTATUS1_NOERR_RAM1         _BIT(10)
+#define NAND_NANDIRQSTATUS1_ERR1_RAM1          _BIT(9)
+#define NAND_NANDIRQSTATUS1_ERR2_RAM1          _BIT(8)
+#define NAND_NANDIRQSTATUS1_ERR3_RAM1          _BIT(7)
+#define NAND_NANDIRQSTATUS1_ERR4_RAM1          _BIT(6)
+#define NAND_NANDIRQSTATUS1_ERR5_RAM1          _BIT(5)
+#define NAND_NANDIRQSTATUS1_ERR_UNR_RAM1       _BIT(4)
+#define NAND_NANDIRQSTATUS1_AES_DONE_RAM1      _BIT(1)
+#define NAND_NANDIRQSTATUS1_AES_DONE_RAM0      _BIT(0)
+
+/* Register description of NANDCONFIG */
+#define NAND_NANDCONFIG_PEC                _BIT(15) /* Power off ECC clock*/
+#define NAND_NANDCONFIG_ECGC               _BIT(13) /* Enable ECC clock gating*/
+#define NAND_NANDCONFIG_8BIT_ECC           _BIT(12) /* ECC mode*/
+#define NAND_NANDCONFIG_TL_528             _SBF(10, 0x0) /* Transfer limit*/
+#define NAND_NANDCONFIG_TL_516             _SBF(10, 0x2) /* Transfer limit*/
+#define NAND_NANDCONFIG_TL_512             _SBF(10, 0x3) /* Transfer limit*/
+#define NAND_NANDCONFIG_TL_MASK            _SBF(10, 0x3) /* Transfer limit*/
+#define NAND_NANDCONFIG_EO                 _BIT(9) /* */
+#define NAND_NANDCONFIG_DC                 _BIT(8) /* Deactivate CE enable*/
+#define NAND_NANDCONFIG_M                  _BIT(7) /* 512 mode*/
+#define NAND_NANDCONFIG_LC_0               _SBF(5, 0x0) /* Latency Configuration: zero wait state*/
+#define NAND_NANDCONFIG_LC_1               _SBF(5, 0x1) /* Latency Configuration: one wait state*/
+#define NAND_NANDCONFIG_LC_2               _SBF(5, 0x2) /* Latency Configuration: two wait state*/
+#define NAND_NANDCONFIG_LC_MASK            _SBF(5, 0x3) /* Latency Configuration*/
+#define NAND_NANDCONFIG_ES                 _BIT(4) /* Endianess setting */
+#define NAND_NANDCONFIG_DE                 _BIT(3) /* DMA external enable*/
+#define NAND_NANDCONFIG_AO                 _BIT(2) /* */
+#define NAND_NANDCONFIG_WD                 _BIT(1) /* Wide device*/
+#define NAND_NANDCONFIG_EC                 _BIT(0) /* ECC on*/
+
+/* Register description of NANDIOCONFIG */
+#define NAND_NANDIOCONFIG_CFG_IO_DRIVE        _BIT(24) /* Nand IO drive default*/
+#define NAND_NANDIOCONFIG_CFG_DATA_DEF(n)     _SBF(8, ((n) & 0xFFFF)) /* Data to nand default*/
+#define NAND_NANDIOCONFIG_CFG_CLE_1           _SBF(6, 0x01) /* CLE default*/
+#define NAND_NANDIOCONFIG_CFG_ALE_1           _SBF(4, 0x01) /* ALE default*/
+#define NAND_NANDIOCONFIG_CFG_WE_1            _SBF(2, 0x01) /* WE_n default*/
+#define NAND_NANDIOCONFIG_CFG_RE_1            _SBF(0, 0x01) /* RE_n default*/
+
+/* Register description of NANDTIMING1 */
+#define NAND_NANDTIMING1_DEFAULT		   (0x000FFFFF)
+#define NAND_NANDTIMING1_TSRD(n)           _SBF(20, ((n) & 0x3)) /* Single data input delay*/
+#define NAND_NANDTIMING1_TALS(n)           _SBF(16, ((n) & 0x7)) /* Address setup time*/
+#define NAND_NANDTIMING1_TALH(n)           _SBF(12, ((n) & 0x7)) /* Address hold time*/
+#define NAND_NANDTIMING1_TCLS(n)           _SBF(4, ((n) & 0x7)) /* Command setup time*/
+#define NAND_NANDTIMING1_TCLH(n)           ((n) & 0x7) /* Command hold time*/
+
+/* Register description of NANDTIMING2 */
+#define NAND_NANDTIMING2_DEFAULT		   (0xFFFFFFFF)
+#define NAND_NANDTIMING2_TDRD(n)           _SBF(28, ((n) & 0x7)) /* Data input delay*/
+#define NAND_NANDTIMING2_TEBI(n)           _SBF(24, ((n) & 0x7)) /* EBI delay time*/
+#define NAND_NANDTIMING2_TCH(n)            _SBF(20, ((n) & 0x7)) /* Chip select hold time*/
+#define NAND_NANDTIMING2_TCS(n)            _SBF(16, ((n) & 0x7)) /* Chip select setup time*/
+#define NAND_NANDTIMING2_TRH(n)            _SBF(12, ((n) & 0x7)) /* Read enable high hold*/
+#define NAND_NANDTIMING2_TRP(n)            _SBF(8, ((n) & 0x7)) /* Read enable pulse width*/
+#define NAND_NANDTIMING2_TWH(n)            _SBF(4, ((n) & 0x7)) /* Write enable high hold*/
+#define NAND_NANDTIMING2_TWP(n)            ((n) & 0x7) /* Write enable pulse width*/
+
+/* Register description of NANDSETCE */
+#define NAND_NANDSETCE_OVR_EN(n)        _BIT(((n) & 0x3) + 12) /* */
+#define NAND_NANDSETCE_OVR_V(n)         _BIT(((n) & 0x3) + 8) /* */
+#define NAND_NANDSETCE_WP               _BIT(4) /* WP_n pin value*/
+#define NAND_NANDSETCE_CV_MASK          0x0F /* Chip select value*/
+#define NAND_NANDSETCE_CV(n)            (0x0F & ~_BIT(((n) & 0x3))) /* Chip select value*/
+#define NAND_NANDSETCE_CV0              _BIT(0)
+
+/* Register description of NANDCHECKSTS */
+#define NAND_NANDCHECKSTS_RB4_EDGE       _BIT(8) /* mNAND_RYBN3 rising edge*/
+#define NAND_NANDCHECKSTS_RB3_EDGE       _BIT(7) /* mNAND_RYBN2 rising edge*/
+#define NAND_NANDCHECKSTS_RB2_EDGE       _BIT(6) /* mNAND_RYBN1 rising edge*/
+#define NAND_NANDCHECKSTS_RB1_EDGE       _BIT(5) /* mNAND_RYBN0 rising edge*/
+#define NAND_NANDCHECKSTS_RB4_LVL        _BIT(4) /* mNAND_RYBN3 value*/
+#define NAND_NANDCHECKSTS_RB3_LVL        _BIT(3) /* mNAND_RYBN2 value*/
+#define NAND_NANDCHECKSTS_RB2_LVL        _BIT(2) /* mNAND_RYBN1 value*/
+#define NAND_NANDCHECKSTS_RB1_LVL        _BIT(1) /* mNAND_RYBN0 value*/
+#define NAND_NANDCHECKSTS_APB_BSY        _BIT(0) /* APB busy*/
+
+/* Register description of NANDCONTROLFLOW */
+
+/* Write the contents of SRAM1 to the NAND flash*/
+#define NAND_CTRL_WR_RAM1           _BIT(5)
+/* Write the contents of SRAM0 to the NAND flash */
+#define NAND_CTRL_WR_RAM0           _BIT(4)
+/* Read a defined number of bytes from the NAND flash and store them in SRAM1*/
+#define NAND_CTRL_RD_RAM1           _BIT(1)
+/* Read a defined number of bytes from the NAND flash and store them in SRAM0*/
+#define NAND_CTRL_RD_RAM0           _BIT(0)
+
+/* Register description of ... */
+#define NAND_AES_AHB_EN             _BIT(7)
+#define NAND_AES_AHB_DCRYPT_RAM1    _BIT(1)
+#define NAND_AES_AHB_DCRYPT_RAM0    _BIT(0)
+
+
+
+
+#endif  /* __ASM_ARCH_REGISTERS_H */
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/system.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/system.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/system.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/system.h	2010-03-16 10:16:48.000000000 -0700
@@ -0,0 +1,52 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/system.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <mach/hardware.h>
+#include <mach/cgu.h>
+
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle ();
+}
+
+static inline void arch_reset(char mode)
+{
+	printk("arch_reset: attempting watchdog reset\n");
+
+	/* enable WDT clock */
+	cgu_clk_en_dis(CGU_SB_WDOG_PCLK_ID, 1);
+
+	/* Disable watchdog */
+	WDT_TCR = 0;
+	WDT_MCR = WDT_MCR_STOP_MR1 | WDT_MCR_INT_MR1;
+
+	/*  If TC and MR1 are equal a reset is generated. */
+	WDT_PR  = 0x00000002;
+	WDT_TC  = 0x00000FF0;
+	WDT_MR0 = 0x0000F000;
+	WDT_MR1 = 0x00001000;
+	WDT_EMR = WDT_EMR_CTRL1(0x3);
+	/* Enable watchdog timer; assert reset at timer timeout */
+	WDT_TCR = WDT_TCR_CNT_EN;
+	cpu_reset (0);/* loop forever and wait for reset to happen */
+
+	/*NOTREACHED*/
+}
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/timex.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/timex.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/timex.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/timex.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,29 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/timex.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include "constants.h"
+
+#define CLOCK_TICK_RATE		(FFAST_CLOCK/2)
+
+#endif
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/uncompress.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/uncompress.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/uncompress.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/uncompress.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,88 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/uncompress.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Decompression UART routines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "constants.h"
+#include "registers.h"
+
+
+#undef __REG
+#define __REG(x)	(*((volatile u32 *)(x)))
+/***********************************************************************
+ * UART register definitions
+ **********************************************************************/
+#define UART_DLL      __REG (UART_PHYS + 0x00)
+#define UART_FIFO     __REG (UART_PHYS + 0x00)
+#define UART_IE       __REG (UART_PHYS + 0x04)
+#define UART_DLM      __REG (UART_PHYS + 0x04)
+#define UART_IIR      __REG (UART_PHYS + 0x08)
+#define UART_FCR      __REG (UART_PHYS + 0x08)
+#define UART_LCR      __REG (UART_PHYS + 0x0c)
+#define UART_MCR      __REG (UART_PHYS + 0x10)
+#define UART_LSR      __REG (UART_PHYS + 0x14)
+#define UART_MSR      __REG (UART_PHYS + 0x18)
+#define UART_SCR      __REG (UART_PHYS + 0x1c)
+#define UART_ACR      __REG (UART_PHYS + 0x20)
+#define UART_ICR      __REG (UART_PHYS + 0x24)
+#define UART_FDR      __REG (UART_PHYS + 0x28)
+
+
+#define UART_LOAD_DLL(div)          ((div) & 0xFF)
+#define UART_LOAD_DLM(div)          (((div) >> 8) & 0xFF)
+#define UART_LCR_DIVLATCH_EN       _BIT(7)
+#define UART_LCR_WLEN_8BITS        _SBF(0, 3)
+#define UART_FCR_DMA_MODE          _BIT(3)
+#define UART_FCR_TXFIFO_FLUSH      _BIT(2)
+#define UART_FCR_RXFIFO_FLUSH      _BIT(1)
+#define UART_FCR_FIFO_EN           _BIT(0)
+#define UART_LSR_FIFORX_ERR        _BIT(7)
+#define UART_LSR_TEMT              _BIT(6)
+#define UART_LSR_FR                _BIT(3)
+#define UART_LSR_PE                _BIT(2)
+#define UART_LSR_OE                _BIT(1)
+#define UART_LSR_RDR               _BIT(0)
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader. If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void putc(int c)
+{
+	while (!(UART_LSR & UART_LSR_TEMT))
+		barrier();
+
+	UART_FIFO = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/vmalloc.h work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/vmalloc.h
--- linux-2.6.28.2/arch/arm/mach-lpc313x/include/mach/vmalloc.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/include/mach/vmalloc.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,21 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/vmalloc.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#define VMALLOC_END       (0xe8000000)
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/irq.c work_2.6.28.2/arch/arm/mach-lpc313x/irq.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/irq.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/irq.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,346 @@
+/*  linux/arch/arm/mach-lpc313x/irq.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Interrupt controller and event router driver for LPC313x & LPC315x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <mach/irqs.h>
+#include <mach/cgu.h>
+
+
+static IRQ_EVENT_MAP_T irq_2_event[] = BOARD_IRQ_EVENT_MAP;
+
+static void intc_mask_irq(unsigned int irq)
+{
+	INTC_REQ_REG(irq) = INTC_REQ_WE_ENABLE;
+}
+
+static void intc_unmask_irq(unsigned int irq)
+{
+	INTC_REQ_REG(irq) = INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE;
+}
+
+static int intc_set_wake(unsigned irq, unsigned value)
+{
+	static u32 wake_ints = 0;
+
+	if (value)
+		/* save the irqs which wake */
+		wake_ints |= _BIT(irq);
+	else
+		/* clear the irqs which don't wake */
+		wake_ints &= ~_BIT(irq);
+
+	/* Note: the clocks to corresponding blocks shouldn't be suspended
+	 * by individual drivers for this logic to work.
+	 */
+	if (wake_ints) {
+		/* enable ARM_IRQ routing to CGU_WAKEUP */
+		EVRT_OUT_MASK_SET(4, EVT_GET_BANK(EVT_arm926_nirq)) = _BIT((EVT_arm926_nirq & 0x1F));
+	} else {
+		/* disable ARM_IRQ routing to CGU_WAKEUP */
+		EVRT_OUT_MASK_CLR(4, EVT_GET_BANK(EVT_arm926_nirq)) = _BIT((EVT_arm926_nirq & 0x1F));
+	}
+
+	//printk("wake on irq=%d value=%d 0x%08x/0x%08x/0x%08x 0x%08x/0x%08x\r\n", irq, value, 
+	//	EVRT_MASK(3), EVRT_APR(3), EVRT_ATR(3),
+	//	EVRT_OUT_MASK(4,3), EVRT_OUT_PEND(4,3));
+
+	return 0;
+}
+
+static struct irq_chip lpc313x_internal_chip = {
+	.name = "INTC",
+	.ack = intc_mask_irq,
+	.mask = intc_mask_irq,
+	.unmask = intc_unmask_irq,
+	.set_wake = intc_set_wake,
+};
+
+static void evt_mask_irq(unsigned int irq)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
+
+	EVRT_MASK_CLR(bank) = _BIT(bit_pos);
+}
+
+static void evt_unmask_irq(unsigned int irq)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
+
+	EVRT_MASK_SET(bank) = _BIT(bit_pos);
+}
+
+static void evt_ack_irq(unsigned int irq)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
+	//EVRT_MASK_CLR(bank) = _BIT(bit_pos);
+	EVRT_INT_CLR(bank) = _BIT(bit_pos);
+}
+
+static int evt_set_type(unsigned irq, unsigned type)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		EVRT_APR(bank) |= _BIT(bit_pos);
+		EVRT_ATR(bank) |= _BIT(bit_pos);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		EVRT_APR(bank) &= ~_BIT(bit_pos);
+		EVRT_ATR(bank) |= _BIT(bit_pos);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		EVRT_ATR(bank) |= _BIT(bit_pos);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		EVRT_APR(bank) |= _BIT(bit_pos);
+		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		EVRT_APR(bank) &= ~_BIT(bit_pos);
+		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int evt_set_wake(unsigned irq, unsigned value)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
+
+	if (value)
+		/* enable routing to CGU_WAKEUP */
+		EVRT_OUT_MASK_SET(4, bank) = _BIT(bit_pos);
+	else
+		/* disable routing to CGU_WAKEUP */
+		EVRT_OUT_MASK_CLR(4, bank) = _BIT(bit_pos);
+
+	return 0;
+}
+
+
+static struct irq_chip lpc313x_evtr_chip = {
+	.name = "EVENTROUTER",
+	.ack = evt_ack_irq,
+	.mask = evt_mask_irq,
+	.unmask = evt_unmask_irq,
+	.set_type = evt_set_type,
+	.set_wake = evt_set_wake,
+};
+
+
+#define ROUTER_HDLR(n) \
+	static void router##n##_handler (unsigned int irq, struct irq_desc *desc) { \
+		u32 status, bank, bit_pos; \
+		if (IRQ_EVTR##n##_START == IRQ_EVTR##n##_END) { \
+			/* translate IRQ number */ \
+			irq = IRQ_EVTR##n##_START; \
+			generic_handle_irq(irq); \
+		} else { \
+			for (irq = IRQ_EVTR##n##_START; irq <= IRQ_EVTR##n##_END; irq++) {  \
+				/* compute bank & bit position for the event_pin */ \
+				bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin); \
+				bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F; \
+				status = EVRT_OUT_PEND(n, bank); \
+				if (status & _BIT(bit_pos)) \
+					generic_handle_irq(irq); \
+			} \
+		} \
+	}
+
+
+#if IRQ_EVTR0_END
+ROUTER_HDLR(0)
+#endif /* IRQ_EVTR0_END */
+
+#if IRQ_EVTR1_END
+ROUTER_HDLR(1)
+#endif /* IRQ_EVTR1_END */
+
+#if IRQ_EVTR2_END
+ROUTER_HDLR(2)
+#endif /* IRQ_EVTR2_END */
+
+#if IRQ_EVTR3_END
+ROUTER_HDLR(3)
+#endif /* IRQ_EVTR3_END */
+
+
+void __init lpc313x_init_irq(void)
+{
+	unsigned int irq;
+	int i, j;
+	u32 bank, bit_pos;
+
+	/* enable clock to interrupt controller */
+	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, 1);
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
+
+	/* Set the vector base (we don't use direct vectoring, so this is 0) */
+	INTC_IRQ_VEC_BASE = 0x00000000;
+	INTC_FIQ_VEC_BASE = 0x00000000;
+
+	/* mask all interrupt by setting high priority untill init is done*/
+	INTC_IRQ_PRI_MASK = 0xFF;
+	INTC_FIQ_PRI_MASK = 0xFF;
+
+	/* mask all external events */
+	for (i = 0; i < EVT_MAX_VALID_BANKS; i++)
+	{
+		/* mask all events */
+		EVRT_MASK_CLR(i) = 0xFFFFFFFF;
+		/* clear all pending events */
+		EVRT_INT_CLR(i) = 0xFFFFFFFF;
+
+		for (j = 0; j < EVT_MAX_VALID_INT_OUT; j++)
+		{
+			/* mask all events */
+			EVRT_OUT_MASK_CLR(j,i) = 0xFFFFFFFF;
+		}
+	}
+
+	/* Clear and disable all interrupts. Start from index 1 since 0 is unused.*/
+	for (irq = 1; irq < NR_IRQ_CPU; irq++) {
+		/* Set the initial control values */
+		INTC_REQ_REG(irq) = INTC_REQ_WE_ENABLE;
+
+		/* Initialize as high-active, Disable the interrupt,
+		* Set target to IRQ , Set priority level to 1 (= lowest) for
+		* all the interrupt lines */
+		INTC_REQ_REG(irq) = INTC_REQ_WE_ACT_LOW |
+			INTC_REQ_WE_ENABLE |
+			INTC_REQ_TARGET_IRQ |
+			INTC_REQ_PRIO_LVL(1) |
+			INTC_REQ_WE_PRIO_LVL;
+
+		set_irq_chip(irq, &lpc313x_internal_chip);
+		set_irq_handler(irq, handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	/* Now configure external/board interrupts using event router */
+	for (irq = IRQ_EVT_START; irq < NR_IRQS; irq++) {
+		/* compute bank & bit position for the event_pin */
+		bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
+		bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
+		
+		printk("irq=%d Event=0x%x bank:%d bit:%d type:%d\r\n", irq,
+			irq_2_event[irq - IRQ_EVT_START].event_pin, bank,
+			bit_pos, irq_2_event[irq - IRQ_EVT_START].type);
+
+		set_irq_chip(irq, &lpc313x_evtr_chip);
+		set_irq_flags(irq, IRQF_VALID);
+		/* configure the interrupt senstivity */
+		switch (irq_2_event[irq - IRQ_EVT_START].type) {
+			case EVT_ACTIVE_LOW:
+				EVRT_APR(bank) &= ~_BIT(bit_pos);
+				EVRT_ATR(bank) &= ~_BIT(bit_pos);
+				set_irq_handler(irq, handle_level_irq);
+				break;
+			case EVT_ACTIVE_HIGH:
+				EVRT_APR(bank) |= _BIT(bit_pos);
+				EVRT_ATR(bank) &= ~_BIT(bit_pos);
+				set_irq_handler(irq, handle_level_irq);
+				break;
+			case EVT_FALLING_EDGE:
+				EVRT_APR(bank) &= ~_BIT(bit_pos);
+				EVRT_ATR(bank) |= _BIT(bit_pos);
+				set_irq_handler(irq, handle_edge_irq);
+				break;
+			case EVT_RISING_EDGE:
+				EVRT_APR(bank) |= _BIT(bit_pos);
+				EVRT_ATR(bank) |= _BIT(bit_pos);
+				set_irq_handler(irq, handle_edge_irq);
+				break;
+			case EVT_BOTH_EDGE:
+				EVRT_ATR(bank) |= _BIT(bit_pos);
+				set_irq_handler(irq, handle_edge_irq);
+			default:
+				printk("Invalid Event type.\r\n");
+				break;
+		}
+		if ( (irq >= IRQ_EVTR0_START) && (irq <= IRQ_EVTR0_END) ) {
+			/* enable routing to vector 0 */
+			EVRT_OUT_MASK_SET(0, bank) = _BIT(bit_pos);
+		} else if ( (irq >= IRQ_EVTR1_START) && (irq <= IRQ_EVTR1_END) ) {
+			/* enable routing to vector 1 */
+			EVRT_OUT_MASK_SET(1, bank) = _BIT(bit_pos);
+		} else if ( (irq >= IRQ_EVTR2_START) && (irq <= IRQ_EVTR2_END) ) {
+			/* enable routing to vector 2 */
+			EVRT_OUT_MASK_SET(2, bank) = _BIT(bit_pos);
+		} else if ( (irq >= IRQ_EVTR3_START) && (irq <= IRQ_EVTR3_END) ) {
+			/* enable routing to vector 3 */
+			EVRT_OUT_MASK_SET(3, bank) = _BIT(bit_pos);
+		} else {
+			printk("Invalid Event router setup.\r\n");
+		}
+	}
+	/* for power management. Wake from internal irqs */
+	EVRT_APR(3) &= ~_BIT(12);
+	EVRT_ATR(3) &= ~_BIT(12);
+	EVRT_MASK_SET(3) = _BIT(12);
+
+	/* install IRQ_EVT_ROUTER0  chain handler */
+#if IRQ_EVTR0_END
+	/* install chain handler for IRQ_EVT_ROUTER0 */
+	set_irq_chained_handler (IRQ_EVT_ROUTER0, router0_handler);
+#endif
+
+#if IRQ_EVTR1_END
+	/* install chain handler for IRQ_EVT_ROUTER1 */
+	set_irq_chained_handler (IRQ_EVT_ROUTER1, router1_handler);
+#endif
+
+#if IRQ_EVTR2_END
+	/* install chain handler for IRQ_EVT_ROUTER2 */
+	set_irq_chained_handler (IRQ_EVT_ROUTER2, router2_handler);
+#endif
+
+#if IRQ_EVTR3_END
+	/* install chain handler for IRQ_EVT_ROUTER3 */
+	set_irq_chained_handler (IRQ_EVT_ROUTER3, router3_handler);
+#endif
+
+	/* Set the priority treshold to 0, i.e. don't mask any interrupt */
+	/* on the basis of priority level, for both targets (IRQ/FIQ)    */
+	INTC_IRQ_PRI_MASK = 0;
+	INTC_FIQ_PRI_MASK = 0;
+}
+
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/Kconfig work_2.6.28.2/arch/arm/mach-lpc313x/Kconfig
--- linux-2.6.28.2/arch/arm/mach-lpc313x/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/Kconfig	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,37 @@
+menu "LPC313x Implementations"
+	depends on ARCH_LPC313X
+
+choice
+	prompt "LPC313x Platform type"
+	default MACH_EA313X
+
+config MACH_EA313X
+	bool "ea313x board"
+	help
+	  Say Y here if you are using the Embedded Artist's EA313x board
+
+config MACH_EA3152
+	bool "ea3152 board"
+	select LPC3152_AD
+	help
+	  Say Y here if you are using Embedded Artist's EA3152 board
+	  
+config MACH_VAL3153
+	bool "val3153 board"
+	help
+	  Say Y here if you are using the NXP val3153 board
+
+config MACH_VAL3154
+	bool "val3154 board"
+	select LPC3152_AD
+	help
+	  Say Y here if you are using the NXP val3154 board
+	  
+endchoice
+
+config LPC3152_AD
+	bool
+
+source "kernel/Kconfig.hz"
+
+endmenu
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/leds.c work_2.6.28.2/arch/arm/mach-lpc313x/leds.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/leds.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/leds.c	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,102 @@
+/*  linux/arch/arm/mach-lpc313x/leds.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * LED driver for val3153-based boards.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/leds.h>
+#include <mach/gpio.h>
+
+
+static inline void val3153_led_on(unsigned int led)
+{
+	gpio_set_value(led, 0);
+}
+
+static inline void val3153_led_off(unsigned int led)
+{
+	gpio_set_value(led, 1);
+}
+
+static inline void val3153_led_toggle(unsigned int led)
+{
+	unsigned long is_off = gpio_get_value(led);
+	if (is_off)
+		val3153_led_on(led);
+	else
+		val3153_led_off(led);
+}
+
+
+/*
+ * Handle LED events.
+ */
+static void val3153_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch(evt) {
+	case led_start:		/* System startup */
+		val3153_led_on(GPIO_GPIO0);
+		break;
+
+	case led_stop:		/* System stop / suspend */
+		val3153_led_off(GPIO_GPIO0);
+		break;
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:		/* Every 50 timer ticks */
+		val3153_led_toggle(GPIO_GPIO2);
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:	/* Entering idle state */
+		val3153_led_off(GPIO_GPIO0);
+		break;
+
+	case led_idle_end:	/* Exit idle state */
+		val3153_led_on(GPIO_GPIO0);
+		break;
+#endif
+
+	default:
+		break;
+	}
+
+	local_irq_restore(flags);
+}
+
+
+int __init leds_init(void)
+{
+	leds_event = val3153_leds_event;
+
+	leds_event(led_start);
+	return 0;
+}
+
+__initcall(leds_init);
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/leds-pca9532.c work_2.6.28.2/arch/arm/mach-lpc313x/leds-pca9532.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/leds-pca9532.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/leds-pca9532.c	2010-03-24 14:06:39.000000000 -0700
@@ -0,0 +1,231 @@
+/*  linux/arch/arm/mach-lpc313x/leds.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * LED driver for ea313x boards.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/leds.h>
+#include <linux/input.h>
+#include <linux/mutex.h>
+#include <linux/leds-pca9532.h>
+#include <asm/leds.h>
+#include <mach/gpio.h>
+
+#define VBUS_PWR_EN	6
+#define START_STOP_LED	8  /*led5 */
+#define IDLE_LED	9  /*led6 */
+
+#define PCA9532_REG_PSC(i) (0x2+(i)*2)
+#define PCA9532_REG_PWM(i) (0x3+(i)*2)
+#define PCA9532_REG_LS0  0x6
+#define LED_REG(led) ((led>>2)+PCA9532_REG_LS0)
+#define LED_NUM(led) (led & 0x3)
+/* LED states */
+#define PCA9532_LED_OFF     0
+#define PCA9532_LED_ON      1
+#define PCA9532_LED_PWM0    2
+#define PCA9532_LED_PWM1    3
+
+
+
+#define ldev_to_led(c)       container_of(c, struct pca9532_led, ldev)
+
+struct pca9532_data {
+	struct i2c_client *client;
+	struct mutex update_lock;
+	struct input_dev    *idev;
+	u32 init;
+};
+
+static u8 g_leds[4] = { 0, 0, 0, 0};
+static struct pca9532_data g_pca_data;
+
+
+/* Set LED routing */
+static void pca9532_setgpio(int led_id, int state)
+{
+	struct pca9532_data *data = &g_pca_data;
+	struct i2c_client *client = data->client;
+	s32 ret;
+	u8 reg;
+
+	if (data->init == 0) {
+		/* save the setting */
+		g_leds[led_id >> 2] &= ~(0x3 << LED_NUM(led_id)*2);
+		g_leds[led_id >> 2] |= ((state & 0x3) << LED_NUM(led_id)*2);
+
+		return;
+	}
+
+	mutex_lock(&data->update_lock);
+	reg = (u8)(g_leds[led_id >> 2] & 0xFF);
+	/* zero led bits */
+	reg = reg & ~(0x3 << LED_NUM(led_id)*2);
+	/* set the new value */
+	reg = reg | ((state & 0x3) << LED_NUM(led_id)*2);
+
+#if 0
+	ret = i2c_smbus_read_byte_data(client, LED_REG(led_id));
+#else
+	ret = g_leds[led_id >> 2];
+#endif
+	printk ("pca9532: r: 0x%x w: 0x%x reg:0x%x\n", (u8)(ret & 0xFF), reg, LED_REG(led_id));
+	  
+	if (ret != reg)
+		i2c_smbus_write_byte_data(client, LED_REG(led_id), reg);
+
+	g_leds[led_id >> 2] = reg;
+
+	mutex_unlock(&data->update_lock);
+}
+
+
+static int pca9532_configure(struct i2c_client *client,	struct pca9532_data *data)
+{
+	/* set PWM0 for 50-50 duty cycle with longest period*/
+	i2c_smbus_write_byte_data(client, PCA9532_REG_PSC(0), 0xFF);
+	i2c_smbus_write_byte_data(client, PCA9532_REG_PWM(0), 0x80);
+
+	i2c_smbus_write_byte_data(client, PCA9532_REG_LS0, g_leds[0]);
+	i2c_smbus_write_byte_data(client, PCA9532_REG_LS0 + 1, g_leds[1]);
+	i2c_smbus_write_byte_data(client, PCA9532_REG_LS0 + 2, g_leds[2]);
+	i2c_smbus_write_byte_data(client, PCA9532_REG_LS0 + 3, g_leds[3]);
+
+	return 0;
+
+}
+/*
+ * Handle LED events.
+ */
+static void ea313x_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch(evt) {
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:		/* Every 50 timer ticks */
+		{
+			unsigned long is_off = gpio_get_value(GPIO_GPIO2);
+			if (is_off)
+				gpio_set_value(GPIO_GPIO2, 0);
+			else
+				gpio_set_value(GPIO_GPIO2, 1);
+		}
+		break;
+#endif
+	default:
+		break;
+	}
+
+	local_irq_restore(flags);
+}
+
+static int pca9532_suspend(struct i2c_client * client, pm_message_t mesg)
+{
+	/* System stop / suspend */
+	pca9532_setgpio(START_STOP_LED, PCA9532_LED_PWM0);
+	return 0;
+}
+
+static int pca9532_resume(struct i2c_client * client)
+{
+	/* System resume */
+	pca9532_setgpio(START_STOP_LED, PCA9532_LED_OFF);
+	return 0;
+}
+
+static int pca9532_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct pca9532_data *data = &g_pca_data;
+
+	if (!i2c_check_functionality(client->adapter,
+		I2C_FUNC_SMBUS_BYTE_DATA))
+		return -EIO;
+
+	memset(data, 0, sizeof(struct pca9532_data));
+
+	dev_info(&client->dev, "setting platform data\n");
+	i2c_set_clientdata(client, data);
+	data->client = client;
+	mutex_init(&data->update_lock);
+
+	pca9532_configure(client, data);
+	/* now set the led hander */
+	leds_event = ea313x_leds_event;
+	leds_event(led_start);
+	/* flag init complete */
+	data->init = 1;
+
+	return 0;
+
+}
+
+static int pca9532_remove(struct i2c_client *client)
+{
+	struct pca9532_data *data = i2c_get_clientdata(client);
+	kfree(data);
+	i2c_set_clientdata(client, NULL);
+	return 0;
+}
+
+static const struct i2c_device_id pca9532_id[] = {
+	{ "pca9532", 0 },
+	{ }
+};
+
+static struct i2c_driver pca9532_driver = {
+	.driver = {
+		.name   = "pca9532",
+	},
+	.id_table = pca9532_id,
+	.probe  = pca9532_probe,
+	.remove = pca9532_remove,
+	.suspend = pca9532_suspend,
+	.resume = pca9532_resume,
+};
+
+static int __init pca9532_init(void)
+{
+	return i2c_add_driver(&pca9532_driver);
+}
+
+static void __exit pca9532_exit(void)
+{
+	i2c_del_driver(&pca9532_driver);
+}
+
+void lpc313x_vbus_power(int enable)
+{
+	if (enable) {
+		printk (KERN_INFO "enabling USB host vbus_power\n");
+		pca9532_setgpio(VBUS_PWR_EN, PCA9532_LED_ON);
+	} else {
+		printk (KERN_INFO "disabling USB host vbus_power\n");
+		pca9532_setgpio(VBUS_PWR_EN, PCA9532_LED_OFF);
+	}
+}
+__initcall(pca9532_init);
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/Makefile work_2.6.28.2/arch/arm/mach-lpc313x/Makefile
--- linux-2.6.28.2/arch/arm/mach-lpc313x/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/Makefile	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,22 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y			+= irq.o time.o cgu.o generic.o i2c.o gpio.o dma.o usb.o wdt.o
+
+
+# Specific board support
+obj-$(CONFIG_MACH_VAL3153) += val3153.o leds.o
+obj-$(CONFIG_MACH_EA313X) += ea313x.o leds-pca9532.o
+obj-$(CONFIG_MACH_EA3152) += ea313x.o leds-pca9532.o
+obj-$(CONFIG_MACH_VAL3154) += val3154.o leds.o
+obj-$(CONFIG_LPC3152_AD) += psu.o
+
+# Power Management
+obj-$(CONFIG_PM)		+= pm.o pm_standby.o
+
+ifeq ($(CONFIG_PM_DEBUG),y)
+CFLAGS_pm.o += -DDEBUG
+endif
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/Makefile.boot work_2.6.28.2/arch/arm/mach-lpc313x/Makefile.boot
--- linux-2.6.28.2/arch/arm/mach-lpc313x/Makefile.boot	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/Makefile.boot	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,4 @@
+zreladdr-y	:= 0x30008000
+params_phys-y	:= 0x30000100
+initrd_phys-y	:= 0x32000000
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/pm.c work_2.6.28.2/arch/arm/mach-lpc313x/pm.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/pm.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/pm.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,279 @@
+/*  linux/arch/arm/mach-lpc313x/leds.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * LPC313x/4x/5x power management.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/pm.h>
+#include <linux/rtc.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+
+
+#define LPC313x_ISRAM_VA io_p2v(ISRAM0_PHYS)
+
+/*
+ * Pointers used for sizing and copying suspend function data
+ */
+extern int lpc313x_suspend_mem(void);
+extern int lpc313x_suspend_mem_sz;
+
+
+/* Enable/Disable external refresh controller used by
+ * auto clock scaling feature of CGU.
+ */
+static void lpc313x_ext_refresh_en(int enable)
+{
+	if (enable)
+		SYS_MPMC_TESTMODE0 |= _BIT(12);
+	else
+		SYS_MPMC_TESTMODE0 &= ~_BIT(12);
+
+}
+static int lpc313x_pm_valid_state(suspend_state_t state)
+{
+	switch (state) {
+		case PM_SUSPEND_ON:
+		case PM_SUSPEND_STANDBY:
+		case PM_SUSPEND_MEM:
+			return 1;
+
+		default:
+			return 0;
+	}
+}
+
+
+static suspend_state_t target_state;
+
+/*
+ * Called after processes are frozen, but before we shutdown devices.
+ */
+static int lpc313x_pm_begin(suspend_state_t state)
+{
+	target_state = state;
+	return 0;
+}
+
+static void lpc313x_clk_debug(void)
+{
+#ifdef CONFIG_PM_DEBUG
+	u32 i, clk_pcr;
+	/* print all clocks which are not auto_wake enabled and are still
+	 * running before entering low-power states.
+	 */
+	for ( i = 0; i < CGU_SB_NR_CLK; i++) {
+		clk_pcr = CGU_SB->clk_pcr[i];
+		if ( (clk_pcr & CGU_SB_PCR_RUN) && 
+			((clk_pcr & CGU_SB_PCR_WAKE_EN) == 0) )
+			printk("Opps Clk: %d is still enabled\n", i);
+	}
+#endif
+}
+
+static int lpc313x_enter_sleep(u32 standby)
+{
+	int (*lpc313x_suspend_ptr) (u32);
+	int i;
+	u32 base_clk_state = 0;
+
+#if defined(BACKUP_ISRAM)
+	void *iram_swap_area;
+#endif
+
+	/* print clocks which are still on */
+	lpc313x_clk_debug();
+
+	lpc313x_ext_refresh_en(0);
+	/*
+	 * To simplify stand-by routine, set FFAST as source clock for the
+	 * non-active switch side of SYS, APB0, APB1, APB2 & APB3 domains.
+	 */
+	for (i = 0; i < 2; i++) {
+		if (CGU_SB->base_ssr[i] & CGU_SB_SCR_EN1)
+			CGU_SB->base_fs2[i] = CGU_FIN_SELECT_FFAST;
+		else
+			CGU_SB->base_fs1[i] = CGU_FIN_SELECT_FFAST;
+	}
+	if (standby == 0) {
+		/* switch off remaining pheripheral clock domains */
+		for (i = 2; i < CGU_SB_NR_BASE; i++) {
+			if (CGU_SB->base_scr[i] & CGU_SB_SCR_STOP)
+				base_clk_state |= _BIT(i);
+			else
+				CGU_SB->base_scr[i] |= CGU_SB_SCR_STOP;
+		}
+	} else {
+		/* we need to have interrupt controller clock on for 
+		 * internal events to wake us up.
+		 */
+		CGU_SB->clk_pcr[CGU_SB_INTC_CLK_ID] = CGU_SB_PCR_RUN;
+	}
+
+
+
+#if defined(BACKUP_ISRAM)
+	/* Allocate some space for temporary IRAM storage */
+	iram_swap_area = kmalloc(lpc313x_suspend_mem_sz, GFP_KERNEL);
+	if (!iram_swap_area) {
+		printk(KERN_ERR
+		       "PM Suspend: cannot allocate memory to save portion "
+			"of SRAM\n");
+		return -ENOMEM;
+	}
+	/* Backup a small area of IRAM used for the suspend code */
+	memcpy(iram_swap_area, (void *) LPC313x_ISRAM_VA,
+			lpc313x_suspend_mem_sz);
+#endif
+
+	/*
+	 * Copy code to suspend system into IRAM. The suspend code
+	 * needs to run from IRAM as DRAM may no longer be available
+	 * when the PLL is stopped.
+	 */
+	memcpy((void *) LPC313x_ISRAM_VA, &lpc313x_suspend_mem,
+			lpc313x_suspend_mem_sz);
+	flush_icache_range((unsigned long)LPC313x_ISRAM_VA,
+		(unsigned long)(LPC313x_ISRAM_VA) + lpc313x_suspend_mem_sz);
+
+	/* Transfer to suspend code in IRAM */
+	lpc313x_suspend_ptr = (void *) LPC313x_ISRAM_VA;
+	(void) lpc313x_suspend_ptr(standby);
+
+#if defined(BACKUP_ISRAM)
+	/* Restore original IRAM contents */
+	memcpy((void *) LPC313x_ISRAM_VA, iram_swap_area,
+			lpc313x_suspend_mem_sz);
+
+	kfree(iram_swap_area);
+#endif
+
+	if (standby == 0) {
+		/* switch on domains clocks which were switched off in this
+		 * routine.
+		 */
+		for (i = 2; i < CGU_SB_NR_BASE; i++) {
+			if ((base_clk_state & _BIT(i)) == 0)
+				CGU_SB->base_scr[i] &= ~CGU_SB_SCR_STOP;
+		}
+	} else {
+
+		/* resume the state of interrupt controller clock */
+		CGU_SB->clk_pcr[CGU_SB_INTC_CLK_ID] = CGU_SB_PCR_WAKE_EN |
+					CGU_SB_PCR_RUN | CGU_SB_PCR_AUTO;
+	}
+
+	lpc313x_ext_refresh_en(1);
+
+	return 0;
+}
+
+
+
+static int lpc313x_pm_enter(suspend_state_t state)
+{
+	int ret = 0;
+
+	switch (state) {
+		/*
+		 * Suspend-to-RAM is like STANDBY plus slow clock mode, so
+		 * drivers must suspend more deeply:  only the base domains
+		 * switches SYS_BABSE, APB0, APB1 are clocked using the
+		 * main oscillator. The system can be woken-up by EXTERNAL
+		 * events ONLY. Ie., external interrupts handles through
+		 * event router.
+		 */
+		case PM_SUSPEND_MEM:
+			ret = lpc313x_enter_sleep(0);
+			break;
+
+		/*
+		 * STANDBY mode has *all* drivers suspended; ignores irqs not
+		 * marked as 'wakeup' event sources; and reduces DRAM power.
+		 * System can be woken-up by internal events. The internal
+		 * blocks which are set to wake should have their clocks
+		 * running without WAK_EN bit set in CGU.
+		 */
+		case PM_SUSPEND_STANDBY:
+			ret = lpc313x_enter_sleep(1);
+			break;
+
+		case PM_SUSPEND_ON:
+			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			break;
+
+		default:
+			pr_debug("LPC31: PM - bogus suspend state %d\n", state);
+			goto error;
+	}
+
+	pr_debug("LPC31: PM - wakeup \n");
+
+error:
+	target_state = PM_SUSPEND_ON;
+	return ret;
+}
+
+/*
+ * Called right prior to thawing processes.
+ */
+static void lpc313x_pm_end(void)
+{
+	target_state = PM_SUSPEND_ON;
+}
+
+/*
+ * Call this from platform driver suspend() to see how deeply to suspend.
+ * For internal events to wake the chip we should not stop the module 
+ * clocks. 
+ */
+int lpc313x_entering_suspend_mem(void)
+{
+	return (target_state == PM_SUSPEND_MEM);
+}
+EXPORT_SYMBOL(lpc313x_entering_suspend_mem);
+
+
+static struct platform_suspend_ops lpc313x_pm_ops ={
+	.valid	= lpc313x_pm_valid_state,
+	.begin	= lpc313x_pm_begin,
+	.enter	= lpc313x_pm_enter,
+	.end	= lpc313x_pm_end,
+};
+
+static int __init lpc313x_pm_init(void)
+{
+	pr_info("LPC31: Power Management init.\n");
+
+	/* Make sure all systems clocks are marked
+	 * as wakeable.
+	 */
+
+
+	suspend_set_ops(&lpc313x_pm_ops);
+
+	return 0;
+}
+arch_initcall(lpc313x_pm_init);
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/pm_standby.S work_2.6.28.2/arch/arm/mach-lpc313x/pm_standby.S
--- linux-2.6.28.2/arch/arm/mach-lpc313x/pm_standby.S	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/pm_standby.S	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,216 @@
+/*  linux/arch/arm/mach-lpc313x/pm_standby.S
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2010 NXP semiconductors
+ *
+ * Power management code to put LPC313x in sleep state.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/linkage.h>
+#include <mach/hardware.h>
+
+#define HPLL_LOCK_TIMEOUT	1000
+
+/* CGU defines */
+#define LPC313x_CGU_NR_BASE     12
+
+/* CGU register offsets */
+#define LPC313x_CGU_PWR_OFS      0xC00
+#define LPC313x_CGU_HP0_MD_OFS   0xD00
+#define LPC313x_CGU_HP0_ST_OFS   0xD04
+#define LPC313x_CGU_HP1_MD_OFS   0xD38
+#define LPC313x_CGU_HP1_ST_OFS   0xD3C
+
+/* CGU bit defines */
+#define LPC313x_PWR_NORM		  (1)
+#define LPC313x_PWR_SLEEP		  (3)
+#define LPC313x_HP_ST_LOCK      (1 << 0)
+#define LPC313x_HP_MODE_PD      (1 << 2)
+#define LPC313x_HP_MODE_EN      (1 << 0)
+
+/* MPMC register offsets */
+#define LPC313x_MPMC_CTL_OFS    0x000
+#define LPC313x_MPMC_STAT_OFS   0x004
+#define LPC313x_MPMC_DYNC_OFS   0x020
+
+/* MPMC bit defines */
+#define LPC313x_MPMC_LOW        (0x5)
+#define LPC313x_MPMC_NORM       (0x1)
+#define LPC313x_DYNC_SR         (1 << 2)
+#define LPC313x_STAT_SR         (1 << 2)
+#define LPC313x_STAT_WB         (1 << 1)
+#define LPC313x_STAT_BS         (1 << 0)
+
+/*
+ * Wait until SYSTEM PLL (HPLL0) has locked.
+ */
+	.macro wait_hp0_lock
+	tst r10, #LPC313x_HP_MODE_PD
+	bne 2f
+	mov	r4, #HPLL_LOCK_TIMEOUT
+1:	sub	r4, r4, #1
+	cmp	r4, #0
+	beq	2f
+	ldr	r3, [r1, #LPC313x_CGU_HP0_ST_OFS]
+	tst	r3, #LPC313x_HP_ST_LOCK
+	beq	1b
+2:
+	.endm
+
+/*
+ * Wait until SYSTEM PLL (HPLL1) has locked.
+ */
+	.macro wait_hp1_lock
+	mov	r4, #HPLL_LOCK_TIMEOUT
+	tst r11, #LPC313x_HP_MODE_PD
+	bne 2f
+1:	sub	r4, r4, #1
+	cmp	r4, #0
+	beq	2f
+	ldr	r3, [r1, #LPC313x_CGU_HP1_ST_OFS]
+	tst	r3, #LPC313x_HP_ST_LOCK
+	beq	1b
+2:
+	.endm
+
+	.text
+
+ENTRY(lpc313x_suspend_mem)
+	/* Save registers on stack */
+	stmfd	sp!, {r0 - r12, lr}
+
+	/*
+	 * Register usage:
+	 *  R1 = Base address of LPC31 CGU
+	 *  R2 = Base address of LPC31 MPMC
+	 *  R3 = temporary register
+	 *  R4 = temporary register
+	 *  R5 = temporary register
+	 *  R6 = temporary register
+	 *  R7 = temporary register
+	 *  R8 = temporary register
+	 *  R9 = temporary register
+	 *  R10 = HPLL0 state
+	 *  R11 = HPLL1 state
+	 */
+	ldr	r1, .lpc313x_va_base_cgu
+	ldr	r2, .lpc313x_va_base_mpmc
+
+	/* Drain write buffer */
+	mcr	p15, 0, r0, c7, c10, 4
+
+	/* Put SDRAM in self-refresh mode */
+
+	/* Wait for SDRAM busy status to go busy and then idle
+	 * This guarantees a small windows where DRAM isn't busy
+	 */
+1:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_WB
+	bne 1b
+2:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_BS
+	beq 2b
+3:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_BS
+	bne 3b
+	mov r3, #LPC313x_DYNC_SR
+	/* Enable SDRAM self-refresh mode */
+	str	r3, [r2, #LPC313x_MPMC_DYNC_OFS]
+	/* wait until SDRAM enters self-refresh */
+4:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_SR
+	beq 4b
+	/* put MPMC in low-power mode */
+	mov r3, #LPC313x_MPMC_LOW
+	/* Enable SDRAM self-refresh mode */
+	str	r3, [r2, #LPC313x_MPMC_CTL_OFS]
+
+	/* Skip PLL power-down for standby. */
+	cmp r0, #0
+	bne 5f
+	/* Switch all bases domain clocks to FFAST.
+	 * lpc313x_enter_suspend_mem() is called before this.
+	 */
+	ldr	r5, [r1]
+	eor r5, r5, #3
+	str	r5, [r1]
+	ldr	r5, [r1, #4]
+	eor r5, r5, #3
+	str	r5, [r1, #4]
+
+	/*
+	 * power-down plls
+	 */
+	ldr	r10, [r1, #LPC313x_CGU_HP0_MD_OFS]
+	orr r3, r12, #LPC313x_HP_MODE_PD
+	str	r3, [r1, #LPC313x_CGU_HP0_MD_OFS]
+	ldr	r11, [r1, #LPC313x_CGU_HP1_MD_OFS]
+	orr r3, r12, #LPC313x_HP_MODE_PD
+	str	r3, [r1, #LPC313x_CGU_HP1_MD_OFS]
+
+	/* Go to sleep zzzzzzzzz */
+5:	mov r3, #LPC313x_PWR_SLEEP
+	str r3, [r1, #LPC313x_CGU_PWR_OFS]
+
+	/* Skip PLL power-ups for standby. */
+	cmp r0, #0
+	bne 6f
+	/* Turn on plls */
+	str	r10, [r1, #LPC313x_CGU_HP0_MD_OFS]
+	str	r11, [r1, #LPC313x_CGU_HP1_MD_OFS]
+
+	wait_hp0_lock
+	wait_hp1_lock
+
+	/*
+	 * Restore domain clocks
+	 */
+	ldr	r5, [r1]
+	eor r5, r5, #3
+	str	r5, [r1]
+	ldr	r5, [r1, #4]
+	eor r5, r5, #3
+	str	r5, [r1, #4]
+
+	/* restore MPMC from low-power mode */
+6:	MOV r3, #LPC313x_MPMC_NORM
+	/* Enable SDRAM self-refresh mode */
+	str	r3, [r2, #LPC313x_MPMC_CTL_OFS]
+
+	/* Restore dync_ctl. Remove self-refresh. */
+	mov r3, #0
+	str	r3, [r2, #LPC313x_MPMC_DYNC_OFS]
+	/* wait until SDRAM exits self-refresh */
+7:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_SR
+	bne 7b
+
+	/* Restore registers, and return */
+	ldmfd	sp!, {r0 - r12, pc}
+
+
+.lpc313x_va_base_cgu:
+	.word io_p2v(CGU_SB_PHYS)
+
+.lpc313x_va_base_mpmc:
+	.word io_p2v(MPMC_PHYS)
+
+ENTRY(lpc313x_suspend_mem_sz)
+	.word .-lpc313x_suspend_mem
+
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/psu.c work_2.6.28.2/arch/arm/mach-lpc313x/psu.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/psu.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/psu.c	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,210 @@
+/*  linux/arch/arm/mach-lpc313x/leds.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Analog die register interface (via sysfs) driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/leds.h>
+#include <linux/input.h>
+#include <linux/mutex.h>
+#include <linux/i2c.h>
+#include <linux/hwmon-sysfs.h>
+#include <mach/hardware.h>
+
+/* Analog die I2C Register offsets*/
+#define    AD_REG_OTGDCLIC_RW                            0x0000
+#define    AD_REG_DCDCLIC_RO                             0x0001
+#define    AD_REG_CGU_RW                                 0x0002
+#define    AD_REG_AIN_0_RW                               0x0010
+#define    AD_REG_AIN_1_RW                               0x0011
+#define    AD_REG_AOUT_RW                                0x0012
+#define    AD_REG_DEC_RW                                 0x0013
+#define    AD_REG_INT_0_RW                               0x0014
+#define    AD_REG_INT_1_RW                               0x0015
+#define    AD_REG_DAIOMUX_RW                             0x0016
+#define    AD_REG_AOUTDECINT_RO                          0x0017
+#define    AD_REG_RTC_TIME                               0x0020
+#define    AD_REG_RTC_ALARM_TIME                         0x0021
+#define    AD_REG_RTC_STATUS                             0x0022
+#define    AD_REG_RTC_SET_ENA_STAT                       0x0023
+#define    AD_REG_RTC_CLR_ENA_STAT                       0x0024
+#define    AD_REG_MOD_ID                                 0x03FF
+
+struct psu_data {
+	struct i2c_client *client;
+};
+
+static struct psu_data g_pca_data;
+
+/* following are the sysfs callback functions */
+static ssize_t psu_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct sensor_device_attribute *psa = to_sensor_dev_attr(attr);
+	struct i2c_client *client = to_i2c_client(dev);
+	char reg_adr[2];
+	u32 reg_val = 0;
+
+	reg_adr[0] = (psa->index >> 8) & 0xFF;
+	reg_adr[1] = psa->index & 0xFF;
+
+	i2c_master_send(client, reg_adr, 2);
+	i2c_master_recv(client, (char*)&reg_val, 4);
+	return sprintf(buf, "0x%08x\n", reg_val);
+}
+
+static ssize_t psu_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct sensor_device_attribute *psa = to_sensor_dev_attr(attr);
+	struct i2c_client *client = to_i2c_client(dev);
+	unsigned long val = simple_strtoul(buf, NULL, 0);
+	char data[6];
+
+	if (val > 0xff)
+		return -EINVAL;
+	/* 16 bit register address */
+	data[0] = (psa->index >> 8) & 0xFF;
+	data[1] = psa->index & 0xFF;
+	/* 32 bit register value */
+	data[2] = (val >> 24) & 0xFF;
+	data[3] = (val >> 16) & 0xFF;
+	data[4] = (val >> 8) & 0xFF;
+	data[5] = val & 0xFF;
+
+	i2c_master_send(client, data, 6);
+	return count;
+}
+
+/* Define the device attributes */
+
+#define PSU_ENTRY_RO(name, cmd_idx) \
+	static SENSOR_DEVICE_ATTR(name, S_IRUGO, psu_show, NULL, cmd_idx)
+
+#define PSU_ENTRY_RW(name, cmd_idx) \
+	static SENSOR_DEVICE_ATTR(name, S_IRUGO | S_IWUSR, psu_show, \
+				  psu_store, cmd_idx)
+
+PSU_ENTRY_RW(otgdclic, AD_REG_OTGDCLIC_RW);
+PSU_ENTRY_RO(dcdclic, AD_REG_DCDCLIC_RO);
+PSU_ENTRY_RW(cgu, AD_REG_CGU_RW);
+PSU_ENTRY_RW(ain_0, AD_REG_AIN_0_RW);
+PSU_ENTRY_RW(ain_1, AD_REG_AIN_1_RW);
+PSU_ENTRY_RW(aout, AD_REG_AOUT_RW);
+PSU_ENTRY_RW(dec, AD_REG_DEC_RW);
+PSU_ENTRY_RW(int_0, AD_REG_INT_0_RW);
+PSU_ENTRY_RW(int_1, AD_REG_INT_1_RW);
+PSU_ENTRY_RW(daiomux, AD_REG_DAIOMUX_RW);
+PSU_ENTRY_RO(aoutdecint, AD_REG_AOUTDECINT_RO);
+PSU_ENTRY_RW(rtc_time, AD_REG_RTC_TIME);
+PSU_ENTRY_RW(rtc_alarm_time, AD_REG_RTC_ALARM_TIME);
+PSU_ENTRY_RW(rtc_status, AD_REG_RTC_STATUS);
+PSU_ENTRY_RW(rtc_set_ena_stat, AD_REG_RTC_SET_ENA_STAT);
+PSU_ENTRY_RW(rtc_clr_ena_stat, AD_REG_RTC_CLR_ENA_STAT);
+PSU_ENTRY_RO(mod_id, AD_REG_MOD_ID);
+
+static struct attribute *psu_attributes[] = {
+	&sensor_dev_attr_otgdclic.dev_attr.attr,
+	&sensor_dev_attr_dcdclic.dev_attr.attr,
+	&sensor_dev_attr_cgu.dev_attr.attr,
+	&sensor_dev_attr_ain_0.dev_attr.attr,
+	&sensor_dev_attr_ain_1.dev_attr.attr,
+	&sensor_dev_attr_aout.dev_attr.attr,
+	&sensor_dev_attr_dec.dev_attr.attr,
+	&sensor_dev_attr_int_0.dev_attr.attr,
+	&sensor_dev_attr_int_1.dev_attr.attr,
+	&sensor_dev_attr_daiomux.dev_attr.attr,
+	&sensor_dev_attr_aoutdecint.dev_attr.attr,
+	&sensor_dev_attr_rtc_time.dev_attr.attr,
+	&sensor_dev_attr_rtc_alarm_time.dev_attr.attr,
+	&sensor_dev_attr_rtc_status.dev_attr.attr,
+	&sensor_dev_attr_rtc_set_ena_stat.dev_attr.attr,
+	&sensor_dev_attr_rtc_clr_ena_stat.dev_attr.attr,
+	&sensor_dev_attr_mod_id.dev_attr.attr,
+	NULL		           
+};
+
+static struct attribute_group psu_defattr_group = {
+	.attrs = psu_attributes,
+};
+
+
+static int psu_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct psu_data *data = &g_pca_data;
+
+	printk(KERN_INFO "PSU_probe\n");
+	if (!i2c_check_functionality(client->adapter,
+		I2C_FUNC_SMBUS_BYTE_DATA))
+		return -EIO;
+
+	memset(data, 0, sizeof(struct psu_data));
+
+	dev_info(&client->dev, "setting platform data\n");
+	i2c_set_clientdata(client, data);
+	data->client = client;
+
+	printk(KERN_INFO "PSU_probe 1\n");
+       /* Register sysfs hooks */
+	return sysfs_create_group(&client->dev.kobj,
+				  &psu_defattr_group);
+}
+
+static int psu_remove(struct i2c_client *client)
+{
+	struct psu_data *data = i2c_get_clientdata(client);
+	sysfs_remove_group(&client->dev.kobj, &psu_defattr_group);
+	kfree(data);
+	i2c_set_clientdata(client, NULL);
+	return 0;
+}
+
+static const struct i2c_device_id psu_id[] = {
+	{ "lpc3152-psu", 0 },
+	{ }
+};
+
+static struct i2c_driver psu_driver = {
+	.driver = {
+		.name   = "lpc3152-psu",
+	},
+	.id_table = psu_id,
+	.probe  = psu_probe,
+	.remove = psu_remove,
+};
+
+static int __init psu_init(void)
+{
+	cgu_clk_en_dis(CGU_SB_SYSCLK_O_ID, 1);
+	return i2c_add_driver(&psu_driver);
+}
+
+static void __exit psu_exit(void)
+{
+	i2c_del_driver(&psu_driver);
+}
+
+module_init(psu_init);
+module_exit(psu_exit);
+
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/time.c work_2.6.28.2/arch/arm/mach-lpc313x/time.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/time.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/time.c	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,96 @@
+/*  arch/arm/mach-lpc313x/time.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  Timer driver for LPC313x & LPC315x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/time.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+
+#include <asm/mach/time.h>
+#include <mach/gpio.h>
+#include <mach/board.h>
+//#include <mach/cgu.h>
+
+
+static irqreturn_t lpc313x_timer_interrupt(int irq, void *dev_id)
+{
+	TIMER_CLEAR(TIMER0_PHYS) = 0;
+	timer_tick();
+	return IRQ_HANDLED;
+}
+
+static struct irqaction lpc313x_timer_irq = {
+	.name		= "LPC313x Timer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= lpc313x_timer_interrupt,
+};
+
+static void __init lpc313x_timer_init (void)
+{
+	/* Switch on needed Timer clocks & switch off others*/
+	cgu_clk_en_dis(CGU_SB_TIMER0_PCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_TIMER1_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_TIMER2_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_TIMER3_PCLK_ID, 0);
+
+	/* Stop/disable all timers */
+	TIMER_CONTROL(TIMER0_PHYS) = 0;
+
+	TIMER_LOAD(TIMER0_PHYS) = LATCH;
+	TIMER_CONTROL(TIMER0_PHYS) = (TM_CTRL_ENABLE | TM_CTRL_PERIODIC);
+	TIMER_CLEAR(TIMER0_PHYS) = 0;
+	setup_irq (IRQ_TIMER0, &lpc313x_timer_irq);
+}
+
+/*!
+ * Returns number of us since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ */
+static unsigned long lpc313x_gettimeoffset(void)
+{
+	u32 elapsed = LATCH - TIMER_VALUE(TIMER0_PHYS);
+	return ((elapsed * 100) / (XTAL_CLOCK / 20000));
+}
+
+static void lpc313x_timer_suspend(void)
+{
+	TIMER_CONTROL(TIMER0_PHYS) &= ~TM_CTRL_ENABLE;	/* disable timers */
+}
+
+static void lpc313x_timer_resume(void)
+{
+	TIMER_CONTROL(TIMER0_PHYS) |= TM_CTRL_ENABLE;	/* enable timers */
+}
+
+
+struct sys_timer lpc313x_timer = {
+	.init = lpc313x_timer_init,
+	.offset = lpc313x_gettimeoffset,
+	.suspend = lpc313x_timer_suspend,
+	.resume = lpc313x_timer_resume,
+};
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/usb.c work_2.6.28.2/arch/arm/mach-lpc313x/usb.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/usb.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/usb.c	2010-03-24 17:45:21.000000000 -0700
@@ -0,0 +1,298 @@
+/* linux/arch/arm/mach-lpc313x/usb.c -- platform level USB initialization
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * USB initialization code.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#undef	DEBUG
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mod_devicetable.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/fsl_devices.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+
+/****************************************************************************
+* USBOTG register definition
+****************************************************************************/
+#define USB_DEV_USBCMD			__REG(USBOTG_PHYS + 0x140)
+#define USB_DEV_USBSTS			__REG(USBOTG_PHYS + 0x144)
+#define USB_DEV_USBINTR			__REG(USBOTG_PHYS + 0x148)
+#define USB_DEV_FRINDEX			__REG(USBOTG_PHYS + 0x14C)
+#define USB_DEV_CONFIGFLAG              __REG(USBOTG_PHYS + 0x180)
+#define USB_DEV_PORTSC1			__REG(USBOTG_PHYS + 0x184)
+#define USB_DEV_OTGSC			__REG(USBOTG_PHYS + 0x1A4)
+#define USB_DEV_USBMODE			__REG(USBOTG_PHYS + 0x1A8)
+
+/* bit defines for USBCMD register */
+#define USBCMD_RS	  _BIT(0)
+#define USBCMD_RST	  _BIT(1)
+#define USBCMD_ATDTW	  _BIT(12)
+#define USBCMD_SUTW	  _BIT(13)
+
+/* bit defines for PRTSC1 register */
+#define USBPRTS_CCS	  _BIT(0)
+#define USBPRTS_PE	  _BIT(2)
+#define USBPRTS_FPR	  _BIT(6)
+#define USBPRTS_SUSP	  _BIT(7)
+#define USBPRTS_PR	  _BIT(8)
+#define USBPRTS_HSP	  _BIT(9)
+#define USBPRTS_PLPSCD	  _BIT(23)
+#define USBPRTS_PFSC	  _BIT(24)
+
+/* bit defines for OTGSC register */
+#define OTGSC_VD          _BIT(0)
+#define OTGSC_VC          _BIT(1)
+#define OTGSC_HAAR        _BIT(2)
+#define OTGSC_OT          _BIT(3)
+#define OTGSC_DP          _BIT(4)
+#define OTGSC_IDPU        _BIT(5)
+#define OTGSC_HADP        _BIT(6)
+#define OTGSC_HABA        _BIT(7)
+
+#define OTGSC_ID_INT      0
+#define OTGSC_AVV_INT     1
+#define OTGSC_ASV_INT     2
+#define OTGSC_BSV_INT     3
+#define OTGSC_BSE_INT     4
+#define OTGSC_1mST_INT    5
+#define OTGSC_DPS_INT     6
+#define OTGSC_STATUS(n)   _BIT(8 + (n))
+#define OTGSC_INT_STAT(n) _BIT(16 + (n))
+#define OTGSC_INT_EN(n)   _BIT(24 + (n))
+#define OTGSC_INT_STAT_MASK (0x007F0000)
+
+/*-------------------------------------------------------------------------*/
+static struct resource lpc313x_usb_resource[] = {
+	[0] = {
+		.start = (u32) (USBOTG_PHYS),
+		.end   = (u32) (USBOTG_PHYS + SZ_4K),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_USB,
+		.end   = IRQ_USB,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct lpc313x_usb_board_t {
+	/* timer for VBUS enable */
+	struct timer_list	vbus_timer;
+	/* board specific over current monitor */
+	int	vbus_ovrc_irq;
+};
+
+static struct lpc313x_usb_board_t lpc313x_usb_brd;
+
+static u64 usb_dmamask = 0xffffffffUL;;
+static void	lpc313x_usb_release(struct device *dev);
+
+struct fsl_usb2_platform_data lpc313x_fsl_config = {
+#if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
+	.operating_mode = FSL_USB2_DR_OTG,
+#elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_DEVICE,
+#elif !defined(CONFIG_USB_GADGET_FSL_USB2) && defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_HOST,
+#endif
+	.phy_mode = FSL_USB2_PHY_UTMI,
+};
+
+#if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
+
+static struct platform_device lpc313x_udc_device = {
+	.name = "fsl-usb2-udc",
+	.dev = {
+		.dma_mask          = &usb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.release           = lpc313x_usb_release,
+		.platform_data     = &lpc313x_fsl_config,
+	},
+	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
+	.resource      = lpc313x_usb_resource,
+};
+#endif
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_OTG)
+
+static struct platform_device lpc313x_ehci_device = {
+	.name		= "lpc-ehci",
+	.dev = {
+		.dma_mask          = &usb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.release           = lpc313x_usb_release,
+		.platform_data     = &lpc313x_fsl_config,
+	},
+	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
+	.resource      = lpc313x_usb_resource,
+};
+#endif
+
+
+/*-------------------------------------------------------------------------*/
+static void	lpc313x_usb_release(struct device *dev)
+{
+	// do nothing
+}
+
+static irqreturn_t lpc313x_vbus_ovrc_irq(int irq, void *data)
+{
+	struct lpc313x_usb_board_t* brd = data;
+	/* disable VBUS power */
+	lpc313x_vbus_power(0);
+	/* Disable over current IRQ */
+	disable_irq_nosync(irq);
+	printk(KERN_INFO "Disabling VBUS as device is drawing too much current!!\n");
+	printk(KERN_INFO "Please disconnect the high-power USB device!!\n");
+
+	/* start the timer to re-enable power to VBUS and IRQ */
+	mod_timer(&brd->vbus_timer, jiffies + msecs_to_jiffies(2000));
+
+	return IRQ_HANDLED;
+}
+
+static void lpc313x_vbusen_timer(unsigned long data)
+{
+	struct lpc313x_usb_board_t* brd = (struct lpc313x_usb_board_t*)data;
+	/* enable VBUS power */
+	lpc313x_vbus_power(1);
+	msleep(2);
+	/* enable the VBUS overcurrent monitoring IRQ */
+	enable_irq(brd->vbus_ovrc_irq);
+}
+
+
+/*-------------------------------------------------------------------------*/
+int __init usbotg_init(void)
+{
+	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	int retval = 0;
+
+	/* enable USB to AHB clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 1);
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
+
+	/* reset USB block */
+	cgu_soft_reset_module(USB_OTG_AHB_RST_N_SOFT);
+
+	/* check if bootloader already enabled USB PLL */
+	if (SYS_USB_ATX_PLL_PD_REG != 0) {
+		/* enable USB OTG PLL */
+		SYS_USB_ATX_PLL_PD_REG = 0x0;
+		/* wait for PLL to lock */
+		while (!(EVRT_RSR(bank) & _BIT(bit_pos)));
+	}
+
+	/* reset the controller */
+	USB_DEV_USBCMD = USBCMD_RST;
+	/* wait for reset to complete */
+	while (USB_DEV_USBCMD & USBCMD_RST);
+
+	/* enable pull-up on ID pin so that we detect external pull-downs*/
+	USB_DEV_OTGSC |= OTGSC_IDPU;
+	/* delay */
+	udelay(5);
+	
+	/* check ID state */
+	if ((USB_DEV_OTGSC & OTGSC_STATUS(OTGSC_ID_INT))) {
+#if defined(CONFIG_USB_GADGET_FSL_USB2)
+		/* register gadget */
+		printk(KERN_INFO "Registering USB gadget 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
+		retval = platform_device_register(&lpc313x_udc_device);
+		if ( 0 != retval )
+			printk(KERN_INFO "Can't register lpc313x_udc_device device\n");
+#else
+		printk(KERN_ERR "Unable to register USB gadget. Check USB_ID jumper!!!!!\n");
+#endif
+	} else {
+#if defined(CONFIG_USB_EHCI_HCD)
+		/* enable VBUS power */
+		lpc313x_vbus_power(1);
+		msleep(2);
+
+		/* register host */
+		printk(KERN_INFO "Registering USB host 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
+		retval = platform_device_register(&lpc313x_ehci_device);
+		if ( 0 != retval )
+			printk(KERN_INFO "Can't register lpc313x_ehci_device device\n");
+
+		/* Create VBUS enable timer */
+		setup_timer(&lpc313x_usb_brd.vbus_timer, lpc313x_vbusen_timer,
+				(unsigned long)&lpc313x_usb_brd);
+
+#if defined(CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
+		/* set thw I2SRX_WS0 pin as GPIO_IN for vbus overcurrent flag */
+		gpio_direction_input(GPIO_I2SRX_WS0);
+		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_EA_VBUS_OVRC;
+
+#else
+		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_VBUS_OVRC;
+#endif
+
+		/* request IRQ to handle VBUS power event */
+		retval = request_irq( lpc313x_usb_brd.vbus_ovrc_irq, lpc313x_vbus_ovrc_irq, 
+			IRQF_DISABLED, "VBUSOVR", 
+			&lpc313x_usb_brd);
+
+		if ( 0 != retval )
+			printk(KERN_INFO "Unable to register IRQ_VBUS_OVRC handler\n");
+		
+#else
+		printk(KERN_ERR "Unable to register USB host. Check USB_ID jumper!!!!!\n");
+#endif
+	}
+	
+#if !defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_OTG) && !defined(CONFIG_USB_EHCI_HCD)
+	/* if no USB component is enabled power-down USB block */
+	/* put in host mode */
+	USB_DEV_USBMODE = 0x3;
+
+	/* switch off PHY clock */
+	USB_DEV_PORTSC1 |= 0x00000080;
+	USB_DEV_PORTSC1 |= 0x00800000;
+
+	/* power off USB PLL */
+	SYS_USB_ATX_PLL_PD_REG = 1;
+	/* disable USB to AHB clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 0);
+#endif
+
+	return retval;
+}
+
+arch_initcall(usbotg_init);
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/val3153.c work_2.6.28.2/arch/arm/mach-lpc313x/val3153.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/val3153.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/val3153.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,460 @@
+/*  arch/arm/mach-lpc313x/val3153.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  VAL3153 board init routines.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <asm/system.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <mach/gpio.h>
+#include <mach/board.h>
+
+/* mci platform functions */
+static int mci_init(u32 slot_id, irq_handler_t , void *);
+static int mci_get_ro(u32 slot_id);
+static int mci_get_cd(u32 slot_id);
+static int mci_get_ocr(u32 slot_id);
+static void mci_setpower(u32 slot_id, u32 volt);
+static void mci_exit(u32 slot_id);
+static void mci_select_slot(u32 slot_id);
+static int mci_get_bus_wd(u32 slot_id);
+
+
+static struct resource cs89x0_resources[] = {
+	[0] = {
+		.start	= EXT_SRAM1_PHYS + 0x10000,
+		.end	= EXT_SRAM1_PHYS + 0x10000 + 16,
+		.flags	= IORESOURCE_MEM,
+	} ,
+	[1] = {
+		.start	= IRQ_CS8900_ETH_INT,
+		.end	= IRQ_CS8900_ETH_INT,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cs89x0_device = {
+	.name		= "cs89x0",
+	.num_resources	= ARRAY_SIZE(cs89x0_resources),
+	.resource	= cs89x0_resources,
+};
+
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+#if defined (CONFIG_MTD_NAND_LPC313X)
+static struct resource lpc313x_nand_resources[] = {
+	[0] = {
+		.start  = IO_NAND_PHYS,
+		.end	= IO_NAND_PHYS + IO_NAND_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= IO_NAND_BUF_PHYS,
+		.end 	= IO_NAND_BUF_PHYS + IO_NAND_BUF_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start 	= IRQ_NAND_FLASH,
+		.end 	= IRQ_NAND_FLASH,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition val3153_nand0_partitions[] = {
+	{
+		.name	= "lpc313x-boot",
+		.offset	= 0,
+		.size	= (BLK_SIZE * 1)
+	},
+	{
+		.name	= "apex",
+		.offset	= (BLK_SIZE * 1),
+		.size	= (BLK_SIZE * 3)
+	},
+	{
+		.name	= "apex-prms",
+		.offset	= (BLK_SIZE * 4),
+		.size	= (BLK_SIZE * 2)
+	},
+	{
+		.name	= "lpc313x-kernel",
+		.offset	= (BLK_SIZE * 6),
+		.size	= (BLK_SIZE * 32) /* 4MB space */
+	},
+	{
+		.name	= "lpc313x-ramdsk",
+		.offset	= (BLK_SIZE * 38),
+		.size	= (BLK_SIZE * 128) /* 16MB space */
+	},
+	{
+		.name	= "lpc313x-rootfs",
+		.offset	= (BLK_SIZE * 166),
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct lpc313x_nand_timing val3153_nanddev_timing = {
+	.ns_trsd	= 80, // FIXME - need to optimize timings
+	.ns_tals	= 80,
+	.ns_talh	= 80,
+	.ns_tcls	= 80,
+	.ns_tclh	= 80,
+	.ns_tdrd	= 80,
+	.ns_tebidel	= 80,
+	.ns_tch		= 80,
+	.ns_tcs		= 80,
+	.ns_treh	= 80,
+	.ns_trp		= 80,
+	.ns_trw		= 80,
+	.ns_twp		= 80
+};
+
+static struct lpc313x_nand_dev_info val3153_ndev[] = {
+	{
+		.name		= "nand0",
+		.nr_partitions	= ARRAY_SIZE(val3153_nand0_partitions),
+		.partitions	= val3153_nand0_partitions
+	}
+};
+
+static struct lpc313x_nand_cfg val3153_plat_nand = {
+	.nr_devices	= ARRAY_SIZE(val3153_ndev),
+	.devices	= val3153_ndev,
+	.timing		= &val3153_nanddev_timing,
+	.support_16bit	= 0,
+};
+
+static u64 nand_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_nand_device = {
+	.name		= "lpc313x_nand",
+	.dev		= {
+		.dma_mask		= &nand_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+				.platform_data	= &val3153_plat_nand,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_nand_resources),
+	.resource	= lpc313x_nand_resources,
+};
+#endif
+
+#if defined(CONFIG_SPI_LPC313X)
+static struct resource lpc313x_spi_resources[] = {
+	[0] = {
+		.start	= SPI_PHYS,
+		.end	= SPI_PHYS + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SPI,
+		.end	= IRQ_SPI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static void spi_set_cs_state(int cs_num, int state)
+{
+	/* Only CS0 is supported, so no checks are needed */
+	(void) cs_num;
+
+	/* Set GPO state for CS0 */
+	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
+}
+
+struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
+{
+	/* SPI CS0 */
+	[0] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs_state,
+	},
+};
+
+struct lpc313x_spi_cfg lpc313x_spidata =
+{
+	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
+	.spics_cfg		= lpc313x_stdspics_cfg,
+};
+
+static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
+static struct platform_device lpc313x_spi_device = {
+	.name		= "spi_lpc313x",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &lpc313x_spi_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data	= &lpc313x_spidata,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
+	.resource	= lpc313x_spi_resources,
+};
+
+/* If both SPIDEV and MTD data flash are enabled with the same chip select, only 1 will work */
+#if defined(CONFIG_SPI_SPIDEV)
+/* SPIDEV driver registration */
+static int __init lpc313x_spidev_register(void)
+{
+	struct spi_board_info info =
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	};
+
+	return spi_register_board_info(&info, 1);
+}
+arch_initcall(lpc313x_spidev_register);
+#endif
+#endif
+
+
+static struct lpc313x_mci_board val3153_mci_platform_data = {
+	.num_slots		= 2,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.select_slot		= mci_select_slot,
+	.exit			= mci_exit,
+};
+
+static u64 mci_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_mci_device = {
+	.name		= "lpc313x_mmc",
+	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
+	.dev		= {
+		.dma_mask		= &mci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &val3153_mci_platform_data,
+	},
+	.resource	= lpc313x_mci_resources,
+};
+
+
+
+static struct platform_device *devices[] __initdata = {
+	&cs89x0_device,
+	&lpc313x_mci_device,
+#if defined (CONFIG_MTD_NAND_LPC313X)
+	&lpc313x_nand_device,
+#endif
+#if defined(CONFIG_SPI_LPC313X)
+	&lpc313x_spi_device,
+#endif
+
+};
+
+static struct map_desc val3153_io_desc[] __initdata = {
+	{
+		.virtual	= io_p2v(EXT_SRAM0_PHYS),
+		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
+		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_NAND_PHYS),
+		.pfn		= __phys_to_pfn(IO_NAND_PHYS),
+		.length		= IO_NAND_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
+		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
+		.length		= IO_NAND_BUF_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_USB_PHYS),
+		.pfn		= __phys_to_pfn(IO_USB_PHYS),
+		.length		= IO_USB_SIZE,
+		.type		= MT_DEVICE
+	},
+
+};
+
+static struct lpc313x_mci_irq_data irq_data[2] = {
+	{
+		.irq = IRQ_SDMMC_CD0,
+	},
+	{
+		.irq = IRQ_SDMMC_CD1,
+	},
+};
+
+static irqreturn_t val313x_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+	u32 slot_id = (pdata->irq == irq_data[0].irq)?0:1;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(slot_id)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(slot_id)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	/* set slot_select, cd and wp pins as GPIO pins */
+	gpio_direction_input(GPIO_GPIO12);
+	gpio_direction_input(GPIO_GPIO13);
+	gpio_direction_input(GPIO_GPIO14);
+	gpio_direction_input(GPIO_GPIO15);
+	gpio_direction_input(GPIO_MI2STX_DATA0);
+
+	/* set card detect irq info */
+	irq_data[slot_id].data = data;
+	irq_data[slot_id].irq_hdlr = irqhdlr;
+	set_irq_type(irq_data[slot_id].irq, level);
+	ret = request_irq(irq_data[slot_id].irq,
+			val313x_mci_detect_interrupt,
+			level,
+			(slot_id)?"mmc-cd1":"mmc-cd0",
+			&irq_data[slot_id]);
+
+	/****temporary for PM testing */
+	enable_irq_wake(irq_data[0].irq);
+	enable_irq_wake(irq_data[1].irq);
+	return ret;
+
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return gpio_get_value((slot_id)?GPIO_GPIO15:GPIO_GPIO14);
+}
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value((slot_id)?GPIO_GPIO13:GPIO_GPIO12);
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	/* power is always on for both slots nothing to do*/
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data[slot_id].irq, &irq_data[slot_id]);
+}
+
+static void mci_select_slot(u32 slot_id)
+{
+	/* select slot 1 for anything other than 0*/
+	gpio_set_value(GPIO_MI2STX_DATA0, (slot_id)?1:0);
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+void lpc313x_vbus_power(int enable)
+{
+	printk(KERN_INFO "%s VBUS power!!!\n", (enable)?"Enabling":"Disabling" );
+	if (enable) 
+		gpio_set_value(GPIO_GPIO18, 0);
+	else
+		gpio_set_value(GPIO_GPIO18, 1);
+
+	udelay(500);
+	udelay(500);
+}
+
+
+static void __init val3153_init(void)
+{
+	lpc313x_init();
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static void __init val3153_map_io(void)
+{
+	lpc313x_map_io();
+	iotable_init(val3153_io_desc, ARRAY_SIZE(val3153_io_desc));
+}
+
+MACHINE_START(VAL3153, "NXP VAL3153")
+	/* Maintainer: Durgesh Pattamatta, NXP */
+	.phys_io	= IO_APB01_PHYS,
+	.io_pg_offst	= (io_p2v(IO_APB01_PHYS) >> 18) & 0xfffc,
+	.boot_params	= 0x30000100,
+	.map_io		= val3153_map_io,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= val3153_init,
+MACHINE_END
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/val3154.c work_2.6.28.2/arch/arm/mach-lpc313x/val3154.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/val3154.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/val3154.c	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,304 @@
+/*  arch/arm/mach-lpc313x/val3154.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  val3154 board init routines.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <mach/gpio.h>
+#include <mach/i2c.h>
+#include <mach/board.h>
+
+/* mci platform functions */
+static int mci_init(u32 slot_id, irq_handler_t , void *);
+static int mci_get_ro(u32 slot_id);
+static int mci_get_cd(u32 slot_id);
+static int mci_get_ocr(u32 slot_id);
+static void mci_setpower(u32 slot_id, u32 volt);
+static void mci_exit(u32 slot_id);
+static int mci_get_bus_wd(u32 slot_id);
+
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+static struct lpc313x_mci_board val3154_mci_platform_data = {
+	.num_slots		= 1,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.exit			= mci_exit,
+};
+
+static u64 mci_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_mci_device = {
+	.name		= "lpc313x_mmc",
+	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
+	.dev		= {
+		.dma_mask		= &mci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &val3154_mci_platform_data,
+	},
+	.resource	= lpc313x_mci_resources,
+};
+
+
+#if defined(CONFIG_SPI_LPC313X)
+static struct resource lpc313x_spi_resources[] = {
+	[0] = {
+		.start	= SPI_PHYS,
+		.end	= SPI_PHYS + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SPI,
+		.end	= IRQ_SPI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static void spi_set_cs_state(int cs_num, int state)
+{
+	/* Only CS0 is supported, so no checks are needed */
+	(void) cs_num;
+
+	/* Set GPO state for CS0 */
+	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
+}
+
+struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
+{
+	/* SPI CS0 */
+	[0] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs_state,
+	},
+};
+
+struct lpc313x_spi_cfg lpc313x_spidata =
+{
+	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
+	.spics_cfg		= lpc313x_stdspics_cfg,
+};
+
+static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
+static struct platform_device lpc313x_spi_device = {
+	.name		= "spi_lpc313x",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &lpc313x_spi_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data	= &lpc313x_spidata,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
+	.resource	= lpc313x_spi_resources,
+};
+
+/* If both SPIDEV and MTD data flash are enabled, only 1 will work */
+#if defined(CONFIG_SPI_SPIDEV)
+/* SPIDEV driver registration */
+static int __init lpc313x_spidev_register(void)
+{
+	struct spi_board_info info =
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	};
+
+	return spi_register_board_info(&info, 1);
+}
+arch_initcall(lpc313x_spidev_register);
+#endif
+#endif
+
+
+static struct platform_device *devices[] __initdata = {
+	&lpc313x_mci_device,
+#if defined(CONFIG_SPI_LPC313X)
+	&lpc313x_spi_device,
+#endif
+};
+
+static struct map_desc val3154_io_desc[] __initdata = {
+	{
+		.virtual	= io_p2v(EXT_SRAM0_PHYS),
+		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
+		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+static struct i2c_board_info val3154_i2c_devices[] __initdata = {
+	{
+		I2C_BOARD_INFO("lpc3152-psu", 0x0C),
+	},
+};
+
+static struct lpc313x_mci_irq_data irq_data = {
+	.irq = IRQ_SDMMC_CD,
+};
+
+static irqreturn_t val3154_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	/* set slot_select, cd and wp pins as GPIO pins */
+	gpio_direction_input(GPIO_MI2STX_BCK0);
+
+	/* set card detect irq info */
+	irq_data.data = data;
+	irq_data.irq_hdlr = irqhdlr;
+	set_irq_type(irq_data.irq, level);
+	ret = request_irq(irq_data.irq,
+			val3154_mci_detect_interrupt,
+			level,
+			"mmc-cd", 
+			&irq_data);
+	return ret;
+
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return 0;
+}
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value(GPIO_MI2STX_BCK0);
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	gpio_set_value(GPIO_MI2STX_DATA0, 0);
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data.irq, &irq_data);
+}
+
+void lpc313x_vbus_power(int enable)
+{
+	if (enable) 
+		gpio_set_value(GPIO_I2SRX_DATA0, 1);
+	else
+		gpio_set_value(GPIO_I2SRX_DATA0, 0);
+}
+
+static void __init val3154_init(void)
+{
+	lpc313x_init();
+	/* register i2cdevices */
+	lpc313x_register_i2c_devices();
+	
+	i2c_register_board_info(1, val3154_i2c_devices,
+		ARRAY_SIZE(val3154_i2c_devices));
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static void __init val3154_map_io(void)
+{
+	lpc313x_map_io();
+	iotable_init(val3154_io_desc, ARRAY_SIZE(val3154_io_desc));
+}
+
+
+MACHINE_START(VAL3154, "NXP VAL3154")
+	/* Maintainer: Durgesh Pattamatta, NXP */
+	.phys_io	= IO_APB01_PHYS,
+	.io_pg_offst	= (io_p2v(IO_APB01_PHYS) >> 18) & 0xfffc,
+	.boot_params	= 0x30000100,
+	.map_io		= val3154_map_io,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= val3154_init,
+MACHINE_END
diff -purN linux-2.6.28.2/arch/arm/mach-lpc313x/wdt.c work_2.6.28.2/arch/arm/mach-lpc313x/wdt.c
--- linux-2.6.28.2/arch/arm/mach-lpc313x/wdt.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/arch/arm/mach-lpc313x/wdt.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,51 @@
+/*
+ * LPC313x Watchdog timer device registration
+ *
+ * drivers/watchdog/wdt_lpc313x.c
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/platform_device.h>
+#include <mach/constants.h>
+#include <mach/irqs.h>
+
+static struct resource watchdog_resources[] = {
+	{
+		.start = WDT_PHYS,
+		.end = WDT_PHYS + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IRQ_WDT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device watchdog_device = {
+	.name = "lpc313x-wdt",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(watchdog_resources),
+	.resource = watchdog_resources,
+};
+
+static int __init wdt_device_init(void)
+{
+	return platform_device_register(&watchdog_device);
+}
+
+arch_initcall(wdt_device_init);
diff -purN linux-2.6.28.2/arch/arm/Makefile work_2.6.28.2/arch/arm/Makefile
--- linux-2.6.28.2/arch/arm/Makefile	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/arch/arm/Makefile	2010-03-15 16:58:23.000000000 -0700
@@ -144,6 +144,7 @@ endif
  machine-$(CONFIG_ARCH_MSM)	   := msm
  machine-$(CONFIG_ARCH_LOKI)       := loki
  machine-$(CONFIG_ARCH_MV78XX0)    := mv78xx0
+ machine-$(CONFIG_ARCH_LPC313X)	   := lpc313x
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
diff -purN linux-2.6.28.2/arch/arm/mm/Kconfig work_2.6.28.2/arch/arm/mm/Kconfig
--- linux-2.6.28.2/arch/arm/mm/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/arch/arm/mm/Kconfig	2010-03-15 16:57:43.000000000 -0700
@@ -187,14 +187,16 @@ config CPU_ARM926T
 		ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || \
 		ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || \
 		ARCH_AT91SAM9G20 || ARCH_AT91CAP9 || \
-		ARCH_NS9XXX || ARCH_DAVINCI || ARCH_MX2
+		ARCH_NS9XXX || ARCH_DAVINCI || ARCH_MX2 || \
+		ARCH_LPC313X
 	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || \
 		ARCH_OMAP730 || ARCH_OMAP16XX || \
 		ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || \
 		ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || \
 		ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || \
 		ARCH_AT91SAM9G20 || ARCH_AT91CAP9 || \
-		ARCH_NS9XXX || ARCH_DAVINCI || ARCH_MX2
+		ARCH_NS9XXX || ARCH_DAVINCI || ARCH_MX2 || \
+		ARCH_LPC313X
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	select CPU_PABRT_NOIFAR
diff -purN linux-2.6.28.2/arch/arm/tools/mach-types work_2.6.28.2/arch/arm/tools/mach-types
--- linux-2.6.28.2/arch/arm/tools/mach-types	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/arch/arm/tools/mach-types	2010-03-15 18:19:06.000000000 -0700
@@ -1899,3 +1899,7 @@ rut100			MACH_RUT100		RUT100			1908
 asusp535		MACH_ASUSP535		ASUSP535		1909
 htcraphael		MACH_HTCRAPHAEL		HTCRAPHAEL		1910
 sygdg1			MACH_SYGDG1		SYGDG1			1911
+val3153			MACH_VAL3153	VAL3153	9999
+ea313x			MACH_EA313X	EA313X	9998
+val3154			MACH_VAL3154	VAL3154	9997
+ea3152			MACH_EA3152		    EA3152			9996
diff -purN linux-2.6.28.2/drivers/i2c/busses/i2c-pnx.c work_2.6.28.2/drivers/i2c/busses/i2c-pnx.c
--- linux-2.6.28.2/drivers/i2c/busses/i2c-pnx.c	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/i2c/busses/i2c-pnx.c	2010-03-23 17:50:19.000000000 -0700
@@ -20,10 +20,12 @@
 #include <linux/platform_device.h>
 #include <linux/i2c-pnx.h>
 #include <mach/hardware.h>
+#include <mach/i2c.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
+#include <asm/io.h>
 
-#define I2C_PNX_TIMEOUT		10 /* msec */
+#define I2C_PNX_TIMEOUT		100 /* msec */
 #define I2C_PNX_SPEED_KHZ	100
 #define I2C_PNX_REGION_SIZE	0x100
 #define PNX_DEFAULT_FREQ	13 /* MHz */
@@ -170,11 +172,9 @@ static int i2c_pnx_master_xmit(struct i2
 		/* We still have something to talk about... */
 		val = *alg_data->mif.buf++;
 
-		if (alg_data->mif.len == 1) {
+		/* last byte of a message */
+		if ((alg_data->mif.len == 1) && alg_data->last)
 			val |= stop_bit;
-			if (!alg_data->last)
-				val |= start_bit;
-		}
 
 		alg_data->mif.len--;
 		iowrite32(val, I2C_REG_TX(alg_data));
@@ -249,9 +249,6 @@ static int i2c_pnx_master_rcv(struct i2c
 		if (alg_data->mif.len == 1) {
 			/* Last byte, do not acknowledge next rcv. */
 			val |= stop_bit;
-			if (!alg_data->last)
-				val |= start_bit;
-
 			/*
 			 * Enable interrupt RFDAIE (data in Rx fifo),
 			 * and disable DRMIE (need data for Tx)
@@ -632,7 +629,9 @@ static int __devinit i2c_pnx_probe(struc
 
 	/* Register this adapter with the I2C subsystem */
 	i2c_pnx->adapter->dev.parent = &pdev->dev;
-	ret = i2c_add_adapter(i2c_pnx->adapter);
+  /* use the new i2c_add_numbered_adapter routine for proper bus numbers */
+  i2c_pnx->adapter->nr = pdev->id;
+	ret = i2c_add_numbered_adapter(i2c_pnx->adapter);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "I2C: Failed to add bus\n");
 		goto out_irq;
diff -purN linux-2.6.28.2/drivers/i2c/busses/Kconfig work_2.6.28.2/drivers/i2c/busses/Kconfig
--- linux-2.6.28.2/drivers/i2c/busses/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/i2c/busses/Kconfig	2010-03-15 16:57:43.000000000 -0700
@@ -430,7 +430,7 @@ config I2C_PASEMI
 
 config I2C_PNX
 	tristate "I2C bus support for Philips PNX targets"
-	depends on ARCH_PNX4008
+	depends on ARCH_PNX4008 || ARCH_LPC313X
 	help
 	  This driver supports the Philips IP3204 I2C IP block master and/or
 	  slave controller
diff -purN linux-2.6.28.2/drivers/mmc/host/Kconfig work_2.6.28.2/drivers/mmc/host/Kconfig
--- linux-2.6.28.2/drivers/mmc/host/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/mmc/host/Kconfig	2010-03-15 16:57:43.000000000 -0700
@@ -4,6 +4,12 @@
 
 comment "MMC/SD/SDIO Host Controller Drivers"
 
+config MMC_LPC313x
+	tristate "NXP LPC313x SD/MMC Card Interface support"
+	default M
+	help
+	  set default module sd/mmc installed for lpc313x
+	  
 config MMC_ARMMMCI
 	tristate "ARM AMBA Multimedia Card Interface support"
 	depends on ARM_AMBA
diff -purN linux-2.6.28.2/drivers/mmc/host/lpc313x_mmc.c work_2.6.28.2/drivers/mmc/host/lpc313x_mmc.c
--- linux-2.6.28.2/drivers/mmc/host/lpc313x_mmc.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/drivers/mmc/host/lpc313x_mmc.c	2010-03-17 18:22:25.000000000 -0700
@@ -0,0 +1,1618 @@
+/*
+ * LPC313x MultiMedia Card Interface driver
+ *
+ * drivers/mmc/host/lpc313x_mmc.c
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/blkdev.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/seq_file.h>
+#include <linux/stat.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+
+#include "lpc313x_mmc.h"
+#include <mach/irqs.h>
+#include <linux/mmc/host.h>
+#include <mach/board.h>
+/* for time being use arch specific DMA framework instead of generic framework */
+#include <mach/dma.h>
+
+#define USE_DMA
+#define BURST_DMA
+
+#define LPC313x_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DTO | SDMMC_INT_DCRC | SDMMC_INT_HTO | SDMMC_INT_SBE | SDMMC_INT_EBE)
+#define LPC313x_MCI_CMD_ERROR_FLAGS	(SDMMC_INT_RTO | SDMMC_INT_RCRC | SDMMC_INT_RESP_ERR | SDMMC_INT_HLE)
+#define LPC313x_MCI_ERROR_FLAGS		(LPC313x_MCI_DATA_ERROR_FLAGS | LPC313x_MCI_CMD_ERROR_FLAGS | SDMMC_INT_HLE)
+#define LPC313x_MCI_SEND_STATUS		1
+#define LPC313x_MCI_RECV_STATUS		2
+#define LPC313x_MCI_DMA_THRESHOLD	16
+
+enum {
+	EVENT_CMD_COMPLETE = 0,
+	EVENT_XFER_COMPLETE,
+	EVENT_DATA_COMPLETE,
+	EVENT_DATA_ERROR,
+	EVENT_XFER_ERROR
+};
+
+
+enum lpc313x_mci_state {
+	STATE_IDLE = 0,
+	STATE_SENDING_CMD,
+	STATE_SENDING_DATA,
+	STATE_DATA_BUSY,
+	STATE_SENDING_STOP,
+	STATE_DATA_ERROR,
+};
+/*forward declaration */
+struct lpc313x_mci_slot;
+
+struct lpc313x_mci {
+	spinlock_t		lock;
+	void __iomem		*regs;
+
+	struct scatterlist	*sg;
+	unsigned int		pio_offset;
+
+	struct lpc313x_mci_slot	*cur_slot;
+	struct mmc_request	*mrq;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+
+#ifdef USE_DMA
+	int			dma_chn;
+	dma_addr_t		sg_dma;
+	dma_sg_ll_t		*sg_cpu;
+#endif
+	u32			cmd_status;
+	u32			data_status;
+	u32			stop_cmdr;
+	u32			dir_status;
+	struct tasklet_struct	tasklet;
+	unsigned long		pending_events;
+	unsigned long		completed_events;
+	enum lpc313x_mci_state	state;
+	struct list_head	queue;
+
+	u32			bus_hz;
+	u32			current_speed;
+	struct platform_device	*pdev;
+	struct lpc313x_mci_board *pdata;
+	struct lpc313x_mci_slot	*slot[MAX_MCI_SLOTS];
+};
+
+struct lpc313x_mci_slot {
+	struct mmc_host		*mmc;
+	struct lpc313x_mci	*host;
+
+	u32			ctype;
+
+	struct mmc_request	*mrq;
+	struct list_head	queue_node;
+
+	unsigned int		clock;
+	unsigned long		flags;
+#define LPC313x_MMC_CARD_PRESENT	0
+#define LPC313x_MMC_CARD_NEED_INIT	1
+#define LPC313x_MMC_SHUTDOWN		2
+	int			id;
+	int			irq;
+
+	struct timer_list	detect_timer;
+};
+
+#define lpc313x_mci_test_and_clear_pending(host, event)		\
+	test_and_clear_bit(event, &host->pending_events)
+#define lpc313x_mci_set_completed(host, event)			\
+	set_bit(event, &host->completed_events)
+
+#define lpc313x_mci_set_pending(host, event)				\
+	set_bit(event, &host->pending_events)
+
+#if defined (CONFIG_DEBUG_FS)
+/*
+ * The debugfs stuff below is mostly optimized away when
+ * CONFIG_DEBUG_FS is not set.
+ */
+static int lpc313x_mci_req_show(struct seq_file *s, void *v)
+{
+	struct lpc313x_mci_slot	*slot = s->private;
+	struct mmc_request	*mrq;
+	struct mmc_command	*cmd;
+	struct mmc_command	*stop;
+	struct mmc_data		*data;
+
+	/* Make sure we get a consistent snapshot */
+	spin_lock(&slot->host->lock);
+	mrq = slot->mrq;
+
+	if (mrq) {
+		cmd = mrq->cmd;
+		data = mrq->data;
+		stop = mrq->stop;
+
+		if (cmd)
+			seq_printf(s,
+				"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\n",
+				cmd->opcode, cmd->arg, cmd->flags,
+				cmd->resp[0], cmd->resp[1], cmd->resp[2],
+				cmd->resp[2], cmd->error);
+		if (data)
+			seq_printf(s, "DATA %u / %u * %u flg %x err %d\n",
+				data->bytes_xfered, data->blocks,
+				data->blksz, data->flags, data->error);
+		if (stop)
+			seq_printf(s,
+				"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\n",
+				stop->opcode, stop->arg, stop->flags,
+				stop->resp[0], stop->resp[1], stop->resp[2],
+				stop->resp[2], stop->error);
+	}
+
+	spin_unlock(&slot->host->lock);
+
+	return 0;
+}
+
+static int lpc313x_mci_req_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lpc313x_mci_req_show, inode->i_private);
+}
+
+static const struct file_operations lpc313x_mci_req_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lpc313x_mci_req_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int lpc313x_mci_regs_show(struct seq_file *s, void *v)
+{
+	struct lpc313x_mci	*host = s->private;
+
+	seq_printf(s, "STATUS:\t0x%08x\n",SDMMC_STATUS);
+	seq_printf(s, "RINTSTS:\t0x%08x\n",SDMMC_RINTSTS);
+	seq_printf(s, "CMD:\t0x%08x\n", SDMMC_CMD);
+	seq_printf(s, "CTRL:\t0x%08x\n", SDMMC_CTRL);
+	seq_printf(s, "INTMASK:\t0x%08x\n", SDMMC_INTMASK);
+	seq_printf(s, "CLKENA:\t0x%08x\n", SDMMC_CLKENA);
+
+	return 0;
+}
+
+static int lpc313x_mci_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lpc313x_mci_regs_show, inode->i_private);
+}
+
+static const struct file_operations lpc313x_mci_regs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lpc313x_mci_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void lpc313x_mci_init_debugfs(struct lpc313x_mci_slot *slot)
+{
+	struct mmc_host		*mmc = slot->mmc;
+	struct lpc313x_mci	*host = slot->host;
+	struct dentry		*root;
+	struct dentry		*node;
+
+	root = mmc->debugfs_root;
+	if (!root)
+		return;
+
+	node = debugfs_create_file("regs", S_IRUSR, root, host,
+			&lpc313x_mci_regs_fops);
+	if (IS_ERR(node))
+		return;
+	if (!node)
+		goto err;
+
+	node = debugfs_create_file("req", S_IRUSR, root, slot, &lpc313x_mci_req_fops);
+	if (!node)
+		goto err;
+
+	node = debugfs_create_u32("state", S_IRUSR, root, (u32 *)&host->state);
+	if (!node)
+		goto err;
+
+	node = debugfs_create_x32("pending_events", S_IRUSR, root,
+				     (u32 *)&host->pending_events);
+	if (!node)
+		goto err;
+
+	node = debugfs_create_x32("completed_events", S_IRUSR, root,
+				     (u32 *)&host->completed_events);
+	if (!node)
+		goto err;
+
+	return;
+
+err:
+	dev_err(&mmc->class_dev, "failed to initialize debugfs for slot\n");
+}
+#endif
+
+static inline unsigned ns_to_clocks(unsigned clkrate, unsigned ns)
+{
+	u32 clks;
+	if (clkrate > 1000000)
+		clks =  (ns * (clkrate / 1000000) + 999) / 1000;
+	else
+		clks =  ((ns/1000) * (clkrate / 1000) + 999) / 1000;
+
+	return clks;
+}
+
+static void lpc313x_mci_set_timeout(struct lpc313x_mci *host,
+		struct lpc313x_mci_slot *slot, struct mmc_data *data)
+{
+	unsigned timeout;
+
+	timeout = ns_to_clocks(slot->clock, data->timeout_ns) + data->timeout_clks;
+
+	dev_vdbg(&slot->mmc->class_dev, "tmo req:%d + %d reg:%d clk:%d\n", 
+		data->timeout_ns, data->timeout_clks, timeout, slot->clock);
+	/* the standard response timeout value (Ncr) is 64 clocks. 
+	 * Let give 4 additional clocks for response.
+	 */
+	mci_writel(TMOUT, /*0xffffffff); */ (timeout << 8) | (70));
+}
+
+static u32 lpc313x_mci_prepare_command(struct mmc_host *mmc,
+				 struct mmc_command *cmd)
+{
+	struct mmc_data	*data;
+	u32		cmdr;
+	
+	cmd->error = -EINPROGRESS;
+	cmdr = cmd->opcode;
+
+	if(cmdr == 12) 
+		cmdr |= SDMMC_CMD_STOP;
+	else 
+		cmdr |= SDMMC_CMD_PRV_DAT_WAIT;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		cmdr |= SDMMC_CMD_RESP_EXP; // expect the respond, need to set this bit
+		if (cmd->flags & MMC_RSP_136) 
+			cmdr |= SDMMC_CMD_RESP_LONG; // expect long respond
+		
+		if(cmd->flags & MMC_RSP_CRC) 
+			cmdr |= SDMMC_CMD_RESP_CRC;
+	}
+
+	data = cmd->data;
+	if (data) {
+		cmdr |= SDMMC_CMD_DAT_EXP;
+		if (data->flags & MMC_DATA_STREAM) 
+			cmdr |= SDMMC_CMD_STRM_MODE; //  set stream mode
+		if (data->flags & MMC_DATA_WRITE) 
+		    cmdr |= SDMMC_CMD_DAT_WR;
+		
+#if 0 /* Jerry, need to confirm the specification does we need to set this bit if blocks > 1 */
+		if(data->blocks > 1) 
+		    cmdr |= SDMMC_CMD_SEND_STOP;
+		
+#endif
+	}
+	return cmdr;
+}
+
+
+static void lpc313x_mci_start_command(struct lpc313x_mci *host,
+		struct mmc_command *cmd, u32 cmd_flags)
+{
+ 	int tmo = 50;
+ 	host->cmd = cmd;
+	dev_vdbg(&host->pdev->dev,
+			"start cmd:%d ARGR=0x%08x CMDR=0x%08x\n",
+			cmd->opcode, cmd->arg, cmd_flags);
+	mci_writel(CMDARG, cmd->arg); // write to CMDARG register
+	mci_writel(CMD, cmd_flags | SDMMC_CMD_START); // write to CMD register
+
+	/* wait until CIU accepts the command */
+	while (--tmo && (mci_readl(CMD) & SDMMC_CMD_START)) 
+		cpu_relax();
+}
+
+static void send_stop_cmd(struct lpc313x_mci *host, struct mmc_data *data)
+{
+	lpc313x_mci_start_command(host, data->stop, host->stop_cmdr);
+}
+
+
+#ifdef USE_DMA
+
+static void lpc313x_mci_dma_cleanup(struct lpc313x_mci *host)
+{
+	struct mmc_data			*data = host->data;
+
+	if (data) 
+		dma_unmap_sg(&host->pdev->dev, data->sg, data->sg_len,
+		     ((data->flags & MMC_DATA_WRITE)
+		      ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
+}
+
+static void lpc313x_mci_stop_dma(struct lpc313x_mci *host)
+{
+	if (host->dma_chn > 0) {
+		dma_stop_channel(host->dma_chn);
+		lpc313x_mci_dma_cleanup(host);
+	} else {
+		/* Data transfer was stopped by the interrupt handler */
+		lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+	}
+}
+
+/* This function is called by the DMA driver from tasklet context. */
+static void lpc313x_mci_dma_complete(int chn, dma_irq_type_t type, void *arg)
+{
+	struct lpc313x_mci	*host = arg;
+	struct mmc_data		*data = host->data;
+
+	dev_vdbg(&host->pdev->dev, "DMA complete\n");
+
+	spin_lock(&host->lock);
+	lpc313x_mci_dma_cleanup(host);
+
+	/*
+	 * If the card was removed, data will be NULL. No point trying
+	 * to send the stop command or waiting for NBUSY in this case.
+	 */
+	if (data) {
+		lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+		tasklet_schedule(&host->tasklet);
+	}
+	spin_unlock(&host->lock);
+}
+
+static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data *data)
+{
+	struct scatterlist		*sg;
+	unsigned int			i, direction, sg_len;
+	unsigned int			j, trans_len;
+
+	/* If we don't have a channel, we can't do DMA */
+	if (host->dma_chn < 0)
+		return -ENODEV;
+
+	/*
+	 * We don't do DMA on "complex" transfers, i.e. with
+	 * non-word-aligned buffers or lengths. Also, we don't bother
+	 * with all the DMA setup overhead for short transfers.
+	 */
+	if (data->blocks * data->blksz < LPC313x_MCI_DMA_THRESHOLD)
+		return -EINVAL;
+	if (data->blksz & 3)
+		return -EINVAL;
+
+	for_each_sg(data->sg, sg, data->sg_len, i) {
+		if (sg->offset & 3 || sg->length & 3)
+			return -EINVAL;
+	}
+
+	if (data->flags & MMC_DATA_READ)
+		direction = DMA_FROM_DEVICE;
+	else
+		direction = DMA_TO_DEVICE;
+
+	sg_len = dma_map_sg(&host->pdev->dev, data->sg, data->sg_len,
+				   direction);
+
+	dev_vdbg(&host->pdev->dev, "sd sg_cpu: 0x%08x sg_dma:0x%08x sg_len:%d \n",
+		(u32)host->sg_cpu, (u32)host->sg_dma, sg_len);
+
+	for (i = 0, j = 0; i < sg_len; i++) {
+		unsigned int length = sg_dma_len(&data->sg[i]);
+		u32 mem_addr = sg_dma_address(&data->sg[i]);
+
+		while (length) {
+
+			host->sg_cpu[j].setup.cfg = DMA_CFG_CMP_CH_EN | DMA_CFG_CMP_CH_NR(host->dma_chn);
+
+			if (data->flags & MMC_DATA_READ) {
+				host->sg_cpu[j].setup.src_address = SDMMC_DATA_ADR;
+				host->sg_cpu[j].setup.dest_address = mem_addr;
+				host->sg_cpu[j].setup.cfg |= DMA_CFG_RD_SLV_NR(DMA_SLV_SDMMC);
+			} else {
+				host->sg_cpu[j].setup.src_address = mem_addr;
+				host->sg_cpu[j].setup.dest_address = SDMMC_DATA_ADR;
+				host->sg_cpu[j].setup.cfg |= DMA_CFG_WR_SLV_NR(DMA_SLV_SDMMC);
+			}
+			host->sg_cpu[j].next_entry = host->sg_dma + (j + 1) *
+						sizeof(dma_sg_ll_t);
+
+#ifdef BURST_DMA
+			host->sg_cpu[j].setup.cfg |= DMA_CFG_TX_BURST;
+      /* 16 bytes per transfer */
+			trans_len = (length >> 4) - 1;
+#else
+      /* 4 bytes per transfer */
+			trans_len = (length >> 2) - 1;
+#endif
+
+			if (trans_len > DMA_MAX_TRANSFERS) {
+				trans_len = DMA_MAX_TRANSFERS;
+				length -= (DMA_MAX_TRANSFERS + 1) << 2;
+				mem_addr += ((DMA_MAX_TRANSFERS + 1) << 2);
+			}
+			else {
+				length = 0;
+			}
+
+			host->sg_cpu[j].setup.trans_length = trans_len;
+
+			dev_vdbg(&host->pdev->dev, "sd src: 0x%08x dest:0x%08x cfg:0x%08x nxt:0x%08x len:%d \n",
+				host->sg_cpu[j].setup.src_address, host->sg_cpu[j].setup.dest_address,
+				host->sg_cpu[j].setup.cfg, host->sg_cpu[j].next_entry,
+				host->sg_cpu[j].setup.trans_length);
+
+			/* move to next transfer descriptor */
+			j++;
+		}
+	}
+	host->sg_cpu[j].setup.src_address = host->sg_dma;
+	host->sg_cpu[j].setup.dest_address = DMACH_SOFT_INT_PHYS;
+	host->sg_cpu[j].setup.trans_length = 1;
+	host->sg_cpu[j].setup.cfg = 0;
+	// disable irq of RX & TX, let DMA handle it
+	//SDMMC_INTMASK &= ~(SDMMC_INT_RXDR | SDMMC_INT_TXDR);
+	SDMMC_CTRL |= SDMMC_CTRL_DMA_ENABLE; // enable dma
+	dma_prog_sg_channel(host->dma_chn, host->sg_dma);
+	wmb();
+	/* Go! */
+	dma_start_channel(host->dma_chn);
+
+	return 0;
+}
+
+#else
+static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data *data)
+{
+	return -ENOSYS;
+}
+
+static void lpc313x_mci_stop_dma(struct lpc313x_mci *host)
+{
+	/* Data transfer was stopped by the interrupt handler */
+	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+}
+#endif
+
+static void lpc313x_mci_submit_data(struct lpc313x_mci *host, struct mmc_data *data)
+{
+	data->error = -EINPROGRESS;
+
+	WARN_ON(host->data);
+	host->sg = NULL;
+	host->data = data;
+
+	if (lpc313x_mci_submit_data_dma(host, data)) {
+		host->sg = data->sg;
+		host->pio_offset = 0;
+		if (data->flags & MMC_DATA_READ)
+			host->dir_status = LPC313x_MCI_RECV_STATUS;
+		else 
+			host->dir_status = LPC313x_MCI_SEND_STATUS;
+
+		//SDMMC_INTMASK |= (SDMMC_INT_RXDR | SDMMC_INT_TXDR);
+		SDMMC_CTRL &= ~SDMMC_CTRL_DMA_ENABLE; // enable dma
+	}
+
+}
+
+#define mci_send_cmd(cmd,arg) {	\
+    SDMMC_CMDARG = arg;		\
+    SDMMC_CMD = SDMMC_CMD_START | cmd;\
+    while (SDMMC_CMD & SDMMC_CMD_START); \
+}
+
+void lpc313x_mci_setup_bus(struct lpc313x_mci_slot *slot)
+{
+	struct lpc313x_mci *host = slot->host;
+	u32 div;
+
+	if (slot->clock != host->current_speed) {
+		div  = (((host->bus_hz + (host->bus_hz / 5)) / slot->clock)) >> 1;
+
+		dev_dbg(&slot->mmc->class_dev, "Bus speed (slot %d) = %dHz div:%d (actual %dHz)\n",
+			slot->id, slot->clock, div, (host->bus_hz / div) >> 1);
+		
+		/* store the actual clock for calculations */
+		slot->clock = (host->bus_hz / div) >> 1;
+		/* disable clock */
+		mci_writel(CLKENA, 0);
+		mci_writel(CLKSRC,0);
+		/* inform CIU */
+		mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+		/* set clock to desired speed */
+		mci_writel(CLKDIV, div);
+		/* inform CIU */
+		mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+		/* enable clock */
+		mci_writel(CLKENA, SDMMC_CLKEN_ENABLE);
+		/* inform CIU */
+		 mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+
+		host->current_speed = slot->clock;
+	}
+
+	/* Set the current slot bus width */
+	mci_writel(CTYPE, slot->ctype);
+}
+
+static void lpc313x_mci_start_request(struct lpc313x_mci *host,
+		struct lpc313x_mci_slot *slot)
+{
+	struct mmc_request	*mrq;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+	u32			cmdflags;
+
+	mrq = slot->mrq;
+	/* now select the proper slot */
+	if (host->pdata->select_slot)
+		host->pdata->select_slot(slot->id);
+
+	/* Slot specific timing and width adjustment */
+	lpc313x_mci_setup_bus(slot);
+
+	host->cur_slot = slot;
+	host->mrq = mrq;
+
+	host->pending_events = 0;
+	host->completed_events = 0;
+	host->data_status = 0;
+
+	data = mrq->data;
+	if (data) {
+		lpc313x_mci_set_timeout(host, slot, data);
+		mci_writel(BYTCNT,data->blksz*data->blocks);
+		mci_writel(BLKSIZ,data->blksz);
+	}
+
+	cmd = mrq->cmd;
+	cmdflags = lpc313x_mci_prepare_command(slot->mmc, cmd);
+
+	if (unlikely(test_and_clear_bit(LPC313x_MMC_CARD_NEED_INIT, &slot->flags))) 
+	    cmdflags |= SDMMC_CMD_INIT; //this is the first command, let set send the initializtion clock
+	
+	if (data) //we may need to move this code to mci_start_command
+		lpc313x_mci_submit_data(host, data);
+
+	lpc313x_mci_start_command(host, cmd, cmdflags);
+
+	if (mrq->stop) 
+		host->stop_cmdr = lpc313x_mci_prepare_command(slot->mmc, mrq->stop);
+	
+}
+
+
+
+static void lpc313x_mci_queue_request(struct lpc313x_mci *host,
+		struct lpc313x_mci_slot *slot, struct mmc_request *mrq)
+{
+	dev_vdbg(&slot->mmc->class_dev, "queue request: state=%d\n",
+			host->state);
+
+	//printk("#");
+	spin_lock(&host->lock);
+	slot->mrq = mrq;
+	if (host->state == STATE_IDLE) {
+		host->state = STATE_SENDING_CMD;
+		lpc313x_mci_start_request(host, slot);
+	} else {
+		list_add_tail(&slot->queue_node, &host->queue);
+	}
+	spin_unlock(&host->lock);
+}
+
+
+static void lpc313x_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
+	struct lpc313x_mci	*host = slot->host;
+
+	WARN_ON(slot->mrq);
+
+	if (!test_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags)) {
+		mrq->cmd->error = -ENOMEDIUM;
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+	lpc313x_mci_queue_request(host, slot, mrq);
+}
+
+static void lpc313x_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
+
+	slot->ctype = 0; // set default 1 bit mode
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_1:
+		slot->ctype = 0;
+		break;
+	case MMC_BUS_WIDTH_4:
+		slot->ctype = SDMMC_CTYPE_4BIT;
+		break;
+	}
+
+
+	if (ios->clock) {
+		spin_lock(&slot->host->lock);
+		/*
+		 * Use mirror of ios->clock to prevent race with mmc
+		 * core ios update when finding the minimum.
+		 */
+		slot->clock = ios->clock;
+
+		spin_unlock(&slot->host->lock);
+	} else {
+		spin_lock(&slot->host->lock);
+		slot->clock = 0;
+		spin_unlock(&slot->host->lock);
+	}
+
+	switch (ios->power_mode) {
+	case MMC_POWER_UP:
+		set_bit(LPC313x_MMC_CARD_NEED_INIT, &slot->flags);
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+static int lpc313x_mci_get_ro(struct mmc_host *mmc)
+{
+	int			read_only = -ENOSYS;
+	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
+	struct lpc313x_mci_board *brd = slot->host->pdata;
+
+	if (brd->get_ro != NULL) {
+		read_only = brd->get_ro(slot->id);
+		dev_dbg(&mmc->class_dev, "card is %s\n",
+				read_only ? "read-only" : "read-write");
+	}
+
+	return read_only;
+}
+
+
+static int lpc313x_mci_get_cd(struct mmc_host *mmc)
+{
+	int			present = -ENOSYS;
+	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
+	struct lpc313x_mci_board *brd = slot->host->pdata;
+
+	present = !brd->get_cd(slot->id);
+	dev_vdbg(&mmc->class_dev, "card is %spresent\n", present ? "" : "not ");
+
+	return present;
+}
+
+static const struct mmc_host_ops lpc313x_mci_ops = {
+	.request	= lpc313x_mci_request,
+	.set_ios	= lpc313x_mci_set_ios,
+	.get_ro		= lpc313x_mci_get_ro,
+	.get_cd		= lpc313x_mci_get_cd,
+};
+
+static void lpc313x_mci_request_end(struct lpc313x_mci *host, struct mmc_request *mrq)
+	__releases(&host->lock)
+	__acquires(&host->lock)
+{
+	struct lpc313x_mci_slot	*slot = NULL;
+	struct mmc_host		*prev_mmc = host->cur_slot->mmc;
+
+	WARN_ON(host->cmd || host->data);
+
+	host->cur_slot->mrq = NULL;
+	host->mrq = NULL;
+	if (!list_empty(&host->queue)) {
+		slot = list_entry(host->queue.next,
+				struct lpc313x_mci_slot, queue_node);
+		list_del(&slot->queue_node);
+		dev_vdbg(&host->pdev->dev, "list not empty: %s is next\n",
+				mmc_hostname(slot->mmc));
+		host->state = STATE_SENDING_CMD;
+		lpc313x_mci_start_request(host, slot);
+	} else {
+		dev_vdbg(&host->pdev->dev, "list empty\n");
+		host->state = STATE_IDLE;
+	}
+
+	//printk("-");
+
+	spin_unlock(&host->lock);
+	mmc_request_done(prev_mmc, mrq);
+
+	spin_lock(&host->lock);
+}
+
+static void lpc313x_mci_command_complete(struct lpc313x_mci *host,
+			struct mmc_command *cmd)
+{
+	u32		status = host->cmd_status;
+
+	host->cmd_status = 0;
+
+	if(cmd->flags & MMC_RSP_PRESENT) {
+
+	    if(cmd->flags & MMC_RSP_136) {
+
+		/* Read the response from the card (up to 16 bytes).
+		 * LPC313x MMC controller saves bits 127-96 in RESP3
+		 * for easy parsing. But the UNSTUFF_BITS macro in core/mmc.c
+		 * core/sd.c expect those bits be in resp[0]. Hence
+		 * reverse the response word order.
+		 */
+		cmd->resp[3] = mci_readl(RESP0);
+		cmd->resp[2] = mci_readl(RESP1);
+		cmd->resp[1] = mci_readl(RESP2);
+		cmd->resp[0] = mci_readl(RESP3);
+	    } else {
+	        cmd->resp[0] = mci_readl(RESP0);
+		cmd->resp[1] = 0;
+		cmd->resp[2] = 0;
+		cmd->resp[3] = 0;
+	    }
+	}
+
+	if (status & SDMMC_INT_RTO)
+		cmd->error = -ETIMEDOUT;
+	else if ((cmd->flags & MMC_RSP_CRC) && (status & SDMMC_INT_RCRC))
+		cmd->error = -EILSEQ;
+	else if (status & SDMMC_INT_RESP_ERR)
+		cmd->error = -EIO;
+	else
+		cmd->error = 0;
+
+	if (cmd->error) {
+		dev_vdbg(&host->pdev->dev,
+			"command error: status=0x%08x resp=0x%08x\n"
+			"cmd=0x%08x arg=0x%08x flg=0x%08x err=%d\n", 
+			status, cmd->resp[0], 
+			cmd->opcode, cmd->arg, cmd->flags, cmd->error);
+
+		if (cmd->data) {
+			host->data = NULL;
+			lpc313x_mci_stop_dma(host);
+		}
+	} 
+}
+
+static void lpc313x_mci_tasklet_func(unsigned long priv)
+{
+	struct lpc313x_mci	*host = (struct lpc313x_mci *)priv;
+	struct mmc_request	*mrq = host->mrq;
+	struct mmc_data		*data = host->data;
+	struct mmc_command	*cmd = host->cmd;
+	enum lpc313x_mci_state	state = host->state;
+	enum lpc313x_mci_state	prev_state;
+	u32			status;
+
+	spin_lock(&host->lock);
+
+	state = host->state;
+#if 0
+	dev_vdbg(&host->pdev->dev,
+		"tasklet: state %u pending/completed/mask %lx/%lx/%x\n",
+		state, host->pending_events, host->completed_events,
+		mci_readl(host, IMR)); // check reg
+#endif
+	do {
+		prev_state = state;
+
+		switch (state) {
+		case STATE_IDLE:
+			break;
+
+		case STATE_SENDING_CMD:
+			if (!lpc313x_mci_test_and_clear_pending(host,
+						EVENT_CMD_COMPLETE))
+				break;
+
+			host->cmd = NULL;
+			lpc313x_mci_set_completed(host, EVENT_CMD_COMPLETE);
+			lpc313x_mci_command_complete(host, mrq->cmd);
+			if (!mrq->data || cmd->error) {
+				lpc313x_mci_request_end(host, host->mrq);
+				goto unlock;
+			}
+
+			prev_state = state = STATE_SENDING_DATA;
+			/* fall through */
+
+		case STATE_SENDING_DATA:
+			if (lpc313x_mci_test_and_clear_pending(host,
+						EVENT_DATA_ERROR)) {
+				lpc313x_mci_stop_dma(host);
+				if (data->stop)
+					send_stop_cmd(host, data);
+				state = STATE_DATA_ERROR;
+				break;
+			}
+
+			if (!lpc313x_mci_test_and_clear_pending(host,
+						EVENT_XFER_COMPLETE))
+				break;
+
+			lpc313x_mci_set_completed(host, EVENT_XFER_COMPLETE);
+			prev_state = state = STATE_DATA_BUSY;
+			/* fall through */
+
+		case STATE_DATA_BUSY:
+			if (!lpc313x_mci_test_and_clear_pending(host,
+						EVENT_DATA_COMPLETE))
+				break;
+
+			host->data = NULL;
+			lpc313x_mci_set_completed(host, EVENT_DATA_COMPLETE);
+			status = host->data_status;
+
+			if (unlikely(status & LPC313x_MCI_DATA_ERROR_FLAGS)) {
+				if (status & SDMMC_INT_DTO) {
+					dev_err(&host->pdev->dev,
+							"data timeout error\n");
+					data->error = -ETIMEDOUT;
+				} else if (status & SDMMC_INT_DCRC) {
+					dev_err(&host->pdev->dev,
+							"data CRC error\n");
+					data->error = -EILSEQ;
+				} else {
+					dev_err(&host->pdev->dev,
+						"data FIFO error (status=%08x)\n",
+						status);
+					data->error = -EIO;
+				}
+			}
+			else {
+				data->bytes_xfered = data->blocks * data->blksz;
+				data->error = 0;
+			}
+
+			if (!data->stop) {
+				lpc313x_mci_request_end(host, host->mrq);
+				goto unlock;
+			}
+
+			prev_state = state = STATE_SENDING_STOP;
+			if (!data->error)
+				send_stop_cmd(host, data);
+			/* fall through */
+
+		case STATE_SENDING_STOP:
+			if (!lpc313x_mci_test_and_clear_pending(host,
+						EVENT_CMD_COMPLETE))
+				break;
+
+			host->cmd = NULL;
+			lpc313x_mci_command_complete(host, mrq->stop);
+			lpc313x_mci_request_end(host, host->mrq);
+			goto unlock;
+		case STATE_DATA_ERROR:
+			if (!lpc313x_mci_test_and_clear_pending(host,
+						EVENT_XFER_COMPLETE))
+				break;
+
+			state = STATE_DATA_BUSY;
+			break;
+		}
+	} while (state != prev_state);
+
+	host->state = state;
+
+unlock:
+	spin_unlock(&host->lock);
+
+}
+
+
+
+inline static void lpc313x_mci_push_data(void *buf,int cnt)
+{
+    u32* pData = (u32*)buf;
+
+    if (cnt % 4 != 0) 
+	    printk("error not align 4\n");
+
+    cnt = cnt >> 2;
+    while (cnt > 0) {
+        SDMMC_DATA = *pData++ ;
+        cnt--;
+    }
+}
+
+inline static void lpc313x_mci_pull_data(void *buf,int cnt)
+{
+    u32* pData = (u32*)buf;
+
+    if (cnt % 4 != 0) 
+	    printk("error not align 4\n");
+    cnt = cnt >> 2;
+    while (cnt > 0) {
+        *pData++ = SDMMC_DATA;
+        cnt--;
+    }
+}
+
+static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
+{
+	struct scatterlist	*sg = host->sg;
+	void			*buf = sg_virt(sg);
+	unsigned int		offset = host->pio_offset;
+	struct mmc_data		*data = host->data;
+	u32			status;
+	unsigned int		nbytes = 0,len,old_len,count =0;
+
+	do {
+		len = SDMMC_GET_FCNT(mci_readl(STATUS)) << 2;
+		if(count == 0) 
+			old_len = len;
+		if (likely(offset + len <= sg->length)) {
+			lpc313x_mci_pull_data((void *)(buf + offset),len);
+
+			offset += len;
+			nbytes += len;
+
+			if (offset == sg->length) {
+				flush_dcache_page(sg_page(sg));
+				host->sg = sg = sg_next(sg);
+				if (!sg)
+					goto done;
+				offset = 0;
+				buf = sg_virt(sg);
+			}
+		} else {
+			unsigned int remaining = sg->length - offset;
+			lpc313x_mci_pull_data((void *)(buf + offset),remaining);
+			nbytes += remaining;
+
+			flush_dcache_page(sg_page(sg));
+			host->sg = sg = sg_next(sg);
+			if (!sg)
+				goto done;
+			offset = len - remaining;
+			buf = sg_virt(sg);
+			lpc313x_mci_pull_data(buf,offset);
+			nbytes += offset;
+		}
+
+		status = mci_readl(MINTSTS);
+		mci_writel(RINTSTS,SDMMC_INT_RXDR); // clear RXDR interrupt
+		if (status & LPC313x_MCI_DATA_ERROR_FLAGS) {
+			host->data_status = status;
+			data->bytes_xfered += nbytes;
+			smp_wmb();
+			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
+			tasklet_schedule(&host->tasklet);
+			return;
+		}
+		count ++;
+	} while (status & SDMMC_INT_RXDR); // if the RXDR is ready let read again
+	len = SDMMC_GET_FCNT(mci_readl(STATUS));
+	host->pio_offset = offset;
+	data->bytes_xfered += nbytes;
+	return;
+
+done:
+	data->bytes_xfered += nbytes;
+	smp_wmb();
+	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+}
+
+static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
+{
+	struct scatterlist	*sg = host->sg;
+	void			*buf = sg_virt(sg);
+	unsigned int		offset = host->pio_offset;
+	struct mmc_data		*data = host->data;
+	u32			status;
+	unsigned int		nbytes = 0,len;
+
+	do {
+
+		len = SDMMC_FIFO_SZ - (SDMMC_GET_FCNT(mci_readl(STATUS)) << 2);
+		if (likely(offset + len <= sg->length)) {
+			lpc313x_mci_push_data((void *)(buf + offset),len);
+
+			offset += len;
+			nbytes += len;
+			if (offset == sg->length) {
+				host->sg = sg = sg_next(sg);
+				if (!sg)
+					goto done;
+
+				offset = 0;
+				buf = sg_virt(sg);
+			}
+		} else {
+			unsigned int remaining = sg->length - offset;
+
+			lpc313x_mci_push_data((void *)(buf + offset), remaining);
+			nbytes += remaining;
+
+			host->sg = sg = sg_next(sg);
+			if (!sg) {
+				goto done;
+			}
+
+			offset = len - remaining;
+			buf = sg_virt(sg);
+			lpc313x_mci_push_data((void *)buf, offset);
+			nbytes += offset;
+		}
+
+		status = mci_readl(MINTSTS);
+		mci_writel(RINTSTS,SDMMC_INT_TXDR); // clear RXDR interrupt
+		if (status & LPC313x_MCI_DATA_ERROR_FLAGS) {
+			host->data_status = status;
+			data->bytes_xfered += nbytes;
+			smp_wmb();
+			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
+			tasklet_schedule(&host->tasklet);
+			return;
+		}
+	} while (status & SDMMC_INT_TXDR); // if TXDR, let write again
+
+	host->pio_offset = offset;
+	data->bytes_xfered += nbytes;
+
+	return;
+
+done:
+	data->bytes_xfered += nbytes;
+	smp_wmb();
+	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+}
+
+static void lpc313x_mci_cmd_interrupt(struct lpc313x_mci *host, u32 status)
+{
+	if(!host->cmd_status) 
+		host->cmd_status = status;
+
+	smp_wmb();
+	lpc313x_mci_set_pending(host, EVENT_CMD_COMPLETE);
+	tasklet_schedule(&host->tasklet);
+}
+
+static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
+{
+	struct lpc313x_mci	*host = dev_id;
+	u32			status,  pending;
+	unsigned int		pass_count = 0;
+
+	spin_lock(&host->lock);
+	do {
+		status = mci_readl(RINTSTS);
+		pending = mci_readl(MINTSTS);// read only mask reg
+		if (!pending)
+			break;
+		if(pending & LPC313x_MCI_CMD_ERROR_FLAGS) {
+		    mci_writel(RINTSTS,LPC313x_MCI_CMD_ERROR_FLAGS);  //  clear interrupt
+		    host->cmd_status = status;
+		    smp_wmb();
+		    lpc313x_mci_set_pending(host, EVENT_CMD_COMPLETE);
+		    tasklet_schedule(&host->tasklet);
+		}
+
+		if (pending & LPC313x_MCI_DATA_ERROR_FLAGS) { // if there is an error, let report DATA_ERROR
+			mci_writel(RINTSTS,LPC313x_MCI_DATA_ERROR_FLAGS);  // clear interrupt
+			host->data_status = status;
+			smp_wmb();
+			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
+			tasklet_schedule(&host->tasklet);
+		}
+
+
+		if(pending & SDMMC_INT_DATA_OVER) {
+		    mci_writel(RINTSTS,SDMMC_INT_DATA_OVER);  // clear interrupt
+		    if (!host->data_status)
+			host->data_status = status;
+		    smp_wmb();
+		    if(host->dir_status == LPC313x_MCI_RECV_STATUS) {
+			if(host->sg != NULL) 
+				lpc313x_mci_read_data_pio(host);
+		    }
+		    lpc313x_mci_set_pending(host, EVENT_DATA_COMPLETE);
+		    tasklet_schedule(&host->tasklet);
+		}
+
+		if (pending & SDMMC_INT_RXDR) {
+		    mci_writel(RINTSTS,SDMMC_INT_RXDR);  //  clear interrupt
+		    if(host->sg) 
+			    lpc313x_mci_read_data_pio(host);
+		}
+
+		if (pending & SDMMC_INT_TXDR) {
+		    mci_writel(RINTSTS,SDMMC_INT_TXDR);  //  clear interrupt
+		    if(host->sg) {
+			lpc313x_mci_write_data_pio(host);
+		    }
+		}
+
+		if (pending & SDMMC_INT_CMD_DONE) {
+		    mci_writel(RINTSTS,SDMMC_INT_CMD_DONE);  //  clear interrupt
+		    lpc313x_mci_cmd_interrupt(host, status);
+		}
+	} while (pass_count++ < 5);
+	
+	spin_unlock(&host->lock);
+
+	return pass_count ? IRQ_HANDLED : IRQ_NONE;
+}
+
+/*
+ *
+ * MMC card detect thread, kicked off from detect interrupt, 1 timer per slot
+ *
+ */
+static void lpc313x_mci_detect_change(unsigned long slot_data)
+{
+	struct lpc313x_mci_slot *slot = (struct lpc313x_mci_slot *) slot_data;
+	struct lpc313x_mci *host;
+	struct mmc_request *mrq;
+	bool present;
+	bool present_old;
+
+	host = slot->host;
+	/*
+	 * lpc313x_mci_cleanup_slot() sets the ATMCI_SHUTDOWN flag before
+	 * freeing the interrupt. We must not re-enable the interrupt
+	 * if it has been freed, and if we're shutting down, it
+	 * doesn't really matter whether the card is present or not.
+	 */
+	smp_rmb();
+	if (test_bit(LPC313x_MMC_SHUTDOWN, &slot->flags))
+		return;
+
+	enable_irq(slot->irq);
+	present = !host->pdata->get_cd(slot->id);
+	present_old = test_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
+	dev_vdbg(&slot->mmc->class_dev, "detect change: %d (was %d)\n",
+			present, present_old);
+
+	if (present != present_old) {
+
+		dev_info(&slot->mmc->class_dev, "card %s\n",
+			present ? "inserted" : "removed");
+
+		spin_lock(&host->lock);
+
+		/* Power up slot */
+		if (present != 0) {
+			if (host->pdata->setpower)
+				host->pdata->setpower(slot->id, slot->mmc->ocr_avail);
+
+			set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
+		} else {
+			if (host->pdata->setpower)
+				host->pdata->setpower(slot->id, 0);
+
+			clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
+		}			
+
+
+		/* Clean up queue if present */
+		mrq = slot->mrq;
+		if (mrq) {
+			if (mrq == host->mrq) {
+			  	/* reset all blocks */
+			  	mci_writel(CTRL,(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+			  	/* wait till resets clear */
+			  	while (mci_readl(CTRL) & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+
+				host->data = NULL;
+				host->cmd = NULL;
+
+				switch (host->state) {
+				case STATE_IDLE:
+					break;
+				case STATE_SENDING_CMD:
+					mrq->cmd->error = -ENOMEDIUM;
+					if (!mrq->data)
+						break;
+					/* fall through */
+				case STATE_SENDING_DATA:
+					mrq->data->error = -ENOMEDIUM;
+					lpc313x_mci_stop_dma(host);
+					break;
+				case STATE_DATA_BUSY:
+				case STATE_DATA_ERROR:
+					if (mrq->data->error == -EINPROGRESS)
+						mrq->data->error = -ENOMEDIUM;
+					if (!mrq->stop)
+						break;
+					/* fall through */
+				case STATE_SENDING_STOP:
+					mrq->stop->error = -ENOMEDIUM;
+					break;
+				}
+
+				lpc313x_mci_request_end(host, mrq);
+			} else {
+				list_del(&slot->queue_node);
+				mrq->cmd->error = -ENOMEDIUM;
+				if (mrq->data)
+					mrq->data->error = -ENOMEDIUM;
+				if (mrq->stop)
+					mrq->stop->error = -ENOMEDIUM;
+
+				spin_unlock(&host->lock);
+				mmc_request_done(slot->mmc, mrq);
+				spin_lock(&host->lock);
+			}
+
+		}
+
+		spin_unlock(&host->lock);
+		mmc_detect_change(slot->mmc, 0);
+	}
+}
+
+static irqreturn_t lpc313x_mci_detect_interrupt(int irq, void *dev_id)
+{
+	struct lpc313x_mci_slot	*slot = dev_id;
+
+	/*
+	 * Disable interrupts until the pin has stabilized and check
+	 * the state then. Use mod_timer() since we may be in the
+	 * middle of the timer routine when this interrupt triggers.
+	 */
+	disable_irq_nosync(irq);
+	mod_timer(&slot->detect_timer, jiffies + msecs_to_jiffies(20));
+
+	return IRQ_HANDLED;
+}
+
+static int __init
+lpc313x_mci_init_slot(struct lpc313x_mci *host, unsigned int id)
+{
+	struct mmc_host			*mmc;
+	struct lpc313x_mci_slot		*slot;
+
+	mmc = mmc_alloc_host(sizeof(struct lpc313x_mci_slot), &host->pdev->dev);
+
+	if (!mmc)
+		return -ENOMEM;
+
+	slot = mmc_priv(mmc);
+	slot->id = id;
+	slot->mmc = mmc;
+	slot->host = host;
+
+	mmc->ops = &lpc313x_mci_ops;
+	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
+	mmc->f_max = host->bus_hz/2; //max f is clock to mmc_clk/2
+	if (host->pdata->get_ocr)
+		mmc->ocr_avail = host->pdata->get_ocr(id);
+	else
+		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	/* Start with slot power disabled, will be enabled when card is detected */
+	if (host->pdata->setpower)
+		host->pdata->setpower(id, 0);
+
+	mmc->caps = 0;
+	if (host->pdata->get_bus_wd)
+		if (host->pdata->get_bus_wd(slot->id) >= 4)
+			mmc->caps |= MMC_CAP_4_BIT_DATA;
+
+	mmc->max_phys_segs = 64;
+	mmc->max_hw_segs = 64;
+	mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits*/
+	mmc->max_blk_count = 512;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_req_size;
+
+	/* call board init */
+	slot->irq = host->pdata->init(id, lpc313x_mci_detect_interrupt, slot);
+	/* Assume card is present initially */
+	if(!host->pdata->get_cd(id))
+		set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
+	else
+		clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
+
+	host->slot[id] = slot;
+	mmc_add_host(mmc);
+
+
+#if defined (CONFIG_DEBUG_FS)
+	lpc313x_mci_init_debugfs(slot);
+#endif
+
+	/* Create card detect handler thread for the slot */
+	setup_timer(&slot->detect_timer, lpc313x_mci_detect_change,
+			(unsigned long)slot);
+
+	return 0;
+}
+
+static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
+		unsigned int id)
+{
+	/* Shutdown detect IRQ and kill detect thread */
+	if (slot->host->pdata->exit)
+		slot->host->pdata->exit(id);
+	del_timer_sync(&slot->detect_timer);
+
+	/* Debugfs stuff is cleaned up by mmc core */
+	set_bit(LPC313x_MMC_SHUTDOWN, &slot->flags);
+	smp_wmb();
+	mmc_remove_host(slot->mmc);
+	slot->host->slot[id] = NULL;
+	mmc_free_host(slot->mmc);
+}
+
+
+static int lpc313x_mci_probe(struct platform_device *pdev)
+{
+	struct lpc313x_mci		*host;
+	struct resource			*regs;
+	struct lpc313x_mci_board	*pdata;
+	int				irq;
+	int				ret = 0;
+	int i;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	host = kzalloc(sizeof(struct lpc313x_mci), GFP_KERNEL);
+	if (!host)
+		return -ENOMEM;
+
+	host->pdev = pdev;
+	host->pdata = pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "Platform data missing\n");
+		ret = -ENODEV;
+		goto err_freehost;
+	}
+
+	if (((pdata->num_slots > 1) && !(pdata->select_slot)) ||
+	     !(pdata->get_ro) || !(pdata->get_cd) || !(pdata->init)) {
+		dev_err(&pdev->dev, "Platform data wrong\n");
+		ret = -ENODEV;
+		goto err_freehost;
+	}
+
+	spin_lock_init(&host->lock);
+	INIT_LIST_HEAD(&host->queue);
+
+	ret = -ENOMEM;
+	host->regs = ioremap(regs->start, regs->end - regs->start);
+	if (!host->regs)
+	    goto err_freehost;
+
+	/* enable the clock to MCI module */
+	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 1);
+
+	/* reset SD/MMC/MCI modules through CGU */
+	/* clear and set the register */
+	CGU_CFG->resetn_soft[SD_MMC_PNRES_SOFT] = 0;
+	CGU_CFG->resetn_soft[SD_MMC_NRES_CCLK_IN_SOFT] = 0;
+	/* introduce some delay */
+	udelay(1);
+	CGU_CFG->resetn_soft[SD_MMC_NRES_CCLK_IN_SOFT] = CGU_CONFIG_SOFT_RESET;
+	CGU_CFG->resetn_soft[SD_MMC_PNRES_SOFT] = CGU_CONFIG_SOFT_RESET;
+
+#ifdef USE_DMA
+	host->dma_chn = dma_request_sg_channel("MCI",  lpc313x_mci_dma_complete, host, 1);
+	host->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
+	if (host->sg_cpu == NULL) {
+		dev_err(&pdev->dev,
+			 "%s: could not alloc dma memory \n", __func__);
+		goto err_freemap;
+	}
+#endif
+	host->bus_hz = cgu_get_clk_freq(CGU_SB_SD_MMC_CCLK_IN_ID); //40000000;
+
+	/* Set IOCONF to MCI pins */
+	SYS_SDMMC_DELAYMODES = 0;
+	SYS_MUX_GPIO_MCI = 1;
+
+	/* set the pins as driven by IP in IOCONF */
+	GPIO_DRV_IP(IOCONF_EBI_MCI, 0xF0000003);
+
+	/* set delay gates */
+	SYS_SDMMC_DELAYMODES = 0x1B;
+
+  	/* reset all blocks */
+  	mci_writel(CTRL,(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+  	/* wait till resets clear */
+  	while (mci_readl(CTRL) & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+
+	 /* Clear the interrupts for the host controller */
+	mci_writel(RINTSTS, 0xFFFFFFFF);
+	mci_writel(INTMASK, 0); // disable all mmc interrupt first
+
+  	/* Put in max timeout */
+  	mci_writel(TMOUT, 0xFFFFFFFF);
+
+  	/* FIFO threshold settings  */
+#ifdef BURST_DMA
+	mci_writel(FIFOTH, ((0x1 << 28) | (0xB << 16) | (0xC << 0))); // RXMark = 11, TXMark = 12, DMA Size = 4
+#else
+  	mci_writel(FIFOTH, ((0x2 << 28) | (0x10 << 16) | (0x10 << 0))); // RXMark = 16, TXMark = 16, DMA Size = 8
+#endif
+
+	/* disable clock to CIU */
+	mci_writel(CLKENA,0);
+	mci_writel(CLKSRC,0);
+
+	tasklet_init(&host->tasklet, lpc313x_mci_tasklet_func, (unsigned long)host);
+	ret = request_irq(irq, lpc313x_mci_interrupt, 0, dev_name(&pdev->dev), host);
+	if (ret)
+	    goto err_dmaunmap;
+
+	platform_set_drvdata(pdev, host);
+
+	/* We need at least one slot to succeed ####pd####*/
+	for (i = 0; i < host->pdata->num_slots; i++) {
+		ret = lpc313x_mci_init_slot(host, i);
+		if (ret) {
+		    ret = -ENODEV;
+		    goto err_init_slot;
+		}
+	}
+
+	// enable interrupt for command done, data over, data empty, receive ready and error such as transmit, receive timeout, crc error
+	mci_writel(RINTSTS, 0xFFFFFFFF);
+	mci_writel(INTMASK,SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_TXDR | SDMMC_INT_RXDR | LPC313x_MCI_ERROR_FLAGS);
+	mci_writel(CTRL,SDMMC_CTRL_INT_ENABLE); // enable mci interrupt
+
+
+	dev_info(&pdev->dev, "LPC313x MMC controller at irq %d\n", irq);
+
+	return 0;
+
+err_init_slot:
+	/* De-init any initialized slots */
+	while (i > 0) {
+		if (host->slot[i])
+			lpc313x_mci_cleanup_slot(host->slot[i], i);
+		i--;
+	}
+	free_irq(irq, host);
+err_dmaunmap:
+#ifdef USE_DMA
+	dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
+	dma_release_sg_channel(host->dma_chn);
+err_freemap:
+#endif
+	iounmap(host->regs);
+err_freehost:
+	kfree(host);
+	return ret;
+}
+
+
+
+static int __exit lpc313x_mci_remove(struct platform_device *pdev)
+{
+	struct lpc313x_mci *host = platform_get_drvdata(pdev);
+	int i;
+
+	mci_writel(RINTSTS, 0xFFFFFFFF);
+	mci_writel(INTMASK, 0); // disable all mmc interrupt first
+
+	platform_set_drvdata(pdev, NULL);
+
+	for (i = 0; i < host->pdata->num_slots; i++) {
+		dev_dbg(&pdev->dev, "remove slot %d\n", i);
+		if (host->slot[i])
+			lpc313x_mci_cleanup_slot(host->slot[i], i);
+	}
+
+	/* disable clock to CIU */
+	mci_writel(CLKENA,0);
+	mci_writel(CLKSRC,0);
+
+	/*  turn off the mci clock here */
+	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 0);
+
+	free_irq(platform_get_irq(pdev, 0), host);
+#ifdef USE_DMA
+	dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
+	dma_release_sg_channel(host->dma_chn);
+#endif
+	iounmap(host->regs);
+
+	kfree(host);
+	return 0;
+}
+
+static int lpc313x_mci_suspend(struct platform_device *pdev, pm_message_t state)
+{
+#ifdef CONFIG_PM
+	/* Disable Card clock */
+	mci_writel(CLKENA,0);
+
+	/* Disable IP clocks */
+	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 0);
+#endif
+	return 0;
+}
+
+static int lpc313x_mci_resume(struct platform_device *pdev)
+{
+#ifdef CONFIG_PM
+	/* Enable IP Clocks */
+	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 1);
+
+	/* Enable Card clock */
+	mci_writel(CLKENA ,SDMMC_CLKEN_ENABLE);
+#endif
+	return 0;
+}
+
+static struct platform_driver lpc313x_mci_driver = {
+	.suspend    = lpc313x_mci_suspend,
+	.resume     = lpc313x_mci_resume,
+	.remove		= __exit_p(lpc313x_mci_remove),
+	.driver		= {
+		.name		= "lpc313x_mmc",
+	},
+};
+
+static int __init lpc313x_mci_init(void)
+{
+	return platform_driver_probe(&lpc313x_mci_driver, lpc313x_mci_probe);
+}
+
+static void __exit lpc313x_mci_exit(void)
+{
+	platform_driver_unregister(&lpc313x_mci_driver);
+}
+
+module_init(lpc313x_mci_init);
+module_exit(lpc313x_mci_exit);
+
+MODULE_DESCRIPTION("LPC313x Multimedia Card Interface driver");
+MODULE_AUTHOR("NXP Semiconductor VietNam");
+MODULE_LICENSE("GPL v2");
diff -purN linux-2.6.28.2/drivers/mmc/host/lpc313x_mmc.h work_2.6.28.2/drivers/mmc/host/lpc313x_mmc.h
--- linux-2.6.28.2/drivers/mmc/host/lpc313x_mmc.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/drivers/mmc/host/lpc313x_mmc.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,20 @@
+/* LPC313x MultiMedia Card Interface driver
+ *
+ * Copyright (C)2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __DRIVERS_MMC_LPC313x_MCI_H__
+#define __DRIVERS_MMC_LPC313x_MCI_H__
+
+#define MCI_SLOT 0
+
+/* Register access macros */
+#define mci_readl(reg)				\
+	__raw_readl(&SDMMC_##reg)
+#define mci_writel(reg,value)			\
+	__raw_writel((value),&SDMMC_##reg)
+
+#endif
diff -purN linux-2.6.28.2/drivers/mmc/host/Makefile work_2.6.28.2/drivers/mmc/host/Makefile
--- linux-2.6.28.2/drivers/mmc/host/Makefile	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/mmc/host/Makefile	2010-03-15 16:57:43.000000000 -0700
@@ -22,4 +22,4 @@ obj-$(CONFIG_MMC_SPI)		+= mmc_spi.o
 obj-$(CONFIG_MMC_S3C)   	+= s3cmci.o
 obj-$(CONFIG_MMC_SDRICOH_CS)	+= sdricoh_cs.o
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
-
+obj-$(CONFIG_MMC_LPC313x)	+= lpc313x_mmc.o
diff -purN linux-2.6.28.2/drivers/mtd/nand/Kconfig work_2.6.28.2/drivers/mtd/nand/Kconfig
--- linux-2.6.28.2/drivers/mtd/nand/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/mtd/nand/Kconfig	2010-03-16 11:12:14.000000000 -0700
@@ -419,5 +419,11 @@ config MTD_NAND_SH_FLCTL
 	help
 	  Several Renesas SuperH CPU has FLCTL. This option enables support
 	  for NAND Flash using FLCTL. This driver support SH7723.
+	  
+config MTD_NAND_LPC313X
+	tristate "Support for NAND Controller on NXP LPC313x"
+	depends on ARCH_LPC313X
+	help
+	  This enables the NAND flash controller on the LPC313x
 
 endif # MTD_NAND
diff -purN linux-2.6.28.2/drivers/mtd/nand/lpc313x_nand.c work_2.6.28.2/drivers/mtd/nand/lpc313x_nand.c
--- linux-2.6.28.2/drivers/mtd/nand/lpc313x_nand.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/drivers/mtd/nand/lpc313x_nand.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,1575 @@
+/*
+ * LPC313x NAND Controller Interface driver
+ *
+ * drivers/mtd/nand/lpc313x_nand.c
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * TODO
+ * Verify BB check code - I don't think it's working for all device sizes
+ * Huge block support may not work due to kernel limitations
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#include <mach/irqs.h>
+#include <mach/registers.h>
+#include <linux/mmc/host.h>
+#include <mach/gpio.h>
+#include <mach/cgu.h>
+#include <mach/board.h>
+/* for time being use arch specific DMA framework
+ * instead of generic framework
+ * */
+#include <mach/dma.h>
+
+/*  Enable DMA transfer for better throughput
+ * */
+#define USE_DMA
+
+/* Maximum number of DMA descritpors in SG table
+ * */
+#define NAND_DMA_MAX_DESC 4
+
+/* Register access macros */
+#define nand_readl(reg)		__raw_readl(&NAND_##reg)
+#define nand_writel(reg,value)	__raw_writel((value),&NAND_##reg)
+#define sys_writel(reg,value)	__raw_writel((value),&SYS_##reg)
+
+#define OOB_FREE_OFFSET 4
+
+/* Enable for polling support only. Polling support will compile the
+   code without interrupts during read and write cycles. Device ready
+   status, buffer status, and ECC status are all polled. This may give
+   a slight performance improvement at the expense of CPU usage. For
+   very slow NAND devices, you wouldn't want to use polling. */
+//#define STATUS_POLLING
+
+/* Huge block support not working in 2.6.28.2 kernel, don't use this! */
+//#define HUGE_BLOCK_SUPPORT
+
+/* Device specific MTD structure, 1 per chip select */
+struct lpc313x_nand_mtd {
+	struct mtd_info mtd;
+	struct nand_chip chip;
+	struct lpc313x_nand_info *host;
+};
+
+/* Local driver data structure */
+struct lpc313x_nand_info {
+	struct nand_hw_control controller;
+	struct lpc313x_nand_cfg *platform;
+	struct lpc313x_nand_mtd *mtds;
+	struct device *dev;
+	u32 nandconfig;
+	int current_cs;
+#ifdef USE_DMA
+	int	dma_chn;
+	dma_addr_t sg_dma;
+	dma_sg_ll_t *sg_cpu;
+	wait_queue_head_t dma_waitq;
+	volatile u32 dmapending;
+#endif
+	int irq;
+	wait_queue_head_t irq_waitq;
+	volatile u32 intspending;
+};
+
+/* Chip select specific ready check masks */
+static const int rdymasks[4] = {
+	NAND_NANDCHECKSTS_RB1_LVL,
+	NAND_NANDCHECKSTS_RB2_LVL,
+	NAND_NANDCHECKSTS_RB3_LVL,
+	NAND_NANDCHECKSTS_RB4_LVL
+};
+
+/* Decode and encode buffer ECC status masks */
+static const u32 nand_buff_dec_mask[2] = {
+	NAND_NANDIRQSTATUS1_ECC_DEC_RAM0, NAND_NANDIRQSTATUS1_ECC_DEC_RAM1};
+static const u32 nand_buff_enc_mask[2] = {
+	NAND_NANDIRQSTATUS1_ECC_ENC_RAM0, NAND_NANDIRQSTATUS1_ECC_ENC_RAM1};
+static const u32 nand_buff_wr_mask[2] = {NAND_NANDIRQSTATUS1_WR_RAM0,
+	NAND_NANDIRQSTATUS1_WR_RAM1};
+
+/* Decode buffer addresses */
+static const void *nand_buff_addr[2] = {
+	(void *) &NAND_BUFFER_ADRESS, (void *) (&NAND_BUFFER_ADRESS + 256)};
+
+#ifdef USE_DMA
+/* Decode buffer physical addresses */
+static const u32 nand_buff_phys_addr[2] = {
+	IO_NAND_BUF_PHYS, (IO_NAND_BUF_PHYS + 0x400)};
+#endif
+
+/*
+ *
+ * OOB data placement structures for small/large/huge block FLASH
+ *
+ */
+
+/*
+ * Autoplacement pattern for 512+16 bytes small block NAND FLASH
+ */
+static struct nand_ecclayout nand_hw_eccoob_16 = {
+	.eccbytes	= 12,
+	.eccpos		= {
+				4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
+			  },
+	.oobfree	= {
+				{0, 4},
+			  }
+};
+
+/*
+ * Autoplacement pattern for 2048+64 bytes large block NAND FLASH
+ */
+static struct nand_ecclayout nand_hw_eccoob_64 = {
+	.eccbytes	= 48,
+	.eccpos		= {
+				4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+				20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+				36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+				52, 53, 54, 55, 56, 67, 58, 59, 60, 61, 62, 63
+			  },
+	.oobfree	= {
+				{0, 4},
+				{16, 4},
+				{32, 4},
+				{48, 4}
+			  }
+};
+
+#ifdef HUGE_BLOCK_SUPPORT
+/*
+ * Autoplacement pattern for 4096+128 bytes large block NAND FLASH
+ */
+static struct nand_ecclayout nand_hw_eccoob_128 = {
+	.eccbytes	= 96,
+	.eccpos		= {
+				4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+				20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+				36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+				52, 53, 54, 55, 56, 67, 58, 59, 60, 61, 62, 63,
+				68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
+				84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
+				100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
+				116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127
+			  },
+	.oobfree	= {
+				{0, 4},
+				{16, 4},
+				{32, 4},
+				{48, 4},
+				{64, 4},
+				{80, 4},
+				{96, 4},
+				{112, 4}
+			  }
+};
+#endif
+
+/*
+ *
+ * Bad block descriptors for small/large/huge block FLASH
+ *
+ */
+/*
+ *	hardware specific flash bbt decriptors
+ */
+static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr lpc313x_bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 32,
+	.len = 4,
+	.veroffs = 48,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr lpc313x_bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 32,
+	.len = 4,
+	.veroffs = 48,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+// Dummies bytes for bad block ( just for HARDWARE ECC: inaccurate )
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+static struct nand_bbt_descr lpc313x_largepage_flashbased = {
+	.options = NAND_BBT_SCAN2NDPAGE,
+	.offs = 50,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+#ifdef USE_DMA
+/*
+ * DMA transfer callback function
+ * @ chn: Channel number
+ * @ type: Interrupt type
+ * @ arg: Function argument
+ */
+static void lpc313x_nand_dma_irq(int chn, dma_irq_type_t type,
+		void *arg)
+{
+	struct lpc313x_nand_info *host = (struct lpc313x_nand_info *)arg;
+
+	/* SG Table ended */
+	if (type == DMA_IRQ_SOFTINT)
+	{
+		/* Flag event and wakeup */
+		host->dmapending = 1;
+		wake_up(&host->dma_waitq);
+	}
+	else if (type == DMA_IRQS_ABORT)
+	{
+		/* DMA data abort - this might not be a
+		   error for this channel. Ignore */
+	}
+
+	return;
+}
+
+/*
+ * DMA mapping function
+ * host : Pointer to ilpc313x_nand_info structure
+ * addr : Address to be DMA mapped
+ * size : Size of the buffer
+ * rd : DMA direction (1: read operation, 0: Write operation
+ */
+static dma_addr_t lpc313x_nand_dma_map(struct lpc313x_nand_info *host,
+		u32 addr, u32 size, int rd)
+{
+	void *addr_map;
+	dma_addr_t dma_addr;
+	enum dma_data_direction dir = rd ? DMA_FROM_DEVICE :
+								DMA_TO_DEVICE;
+
+	if ((void *)addr >= high_memory) {
+		/* For vmalloced buffers, check if buffer is within PAGE_SIZE.
+	 	* If buffer is not within PAGE_SIZE, DMA map will not work
+		* If buffer not within PAGE_SIZE, return with 0 (mapping failed)
+		* Else DMA map the buffer.
+	 	* */
+		struct page *p1;
+
+		if (((size_t)addr & PAGE_MASK) !=
+				((size_t)(addr + size - 1) & PAGE_MASK)) {
+			dev_err(host->dev, "Buffer not within page \r\n");
+			return 0;
+		}
+
+		/* Get page address address */
+		p1 = vmalloc_to_page((void *)addr);
+		if (!p1) {
+			dev_err(host->dev, "vmalloc_to_page failure \r\n");
+			return 0;
+		}
+		addr_map = page_address(p1) + ((size_t)addr & ~PAGE_MASK);
+	}
+	else {
+		/* kmalloced buffer */
+		addr_map = (void *)addr;
+	}
+
+	/* Get DMA mapping */
+	dma_addr = (u32) dma_map_single(host->dev, (void *) addr_map,
+				size, dir);
+	if (dma_mapping_error(host->dev, dma_addr))
+	{
+		dev_err(host->dev, "DMA mapping failure \r\n");
+		return 0;
+	}
+
+	return dma_addr;
+}
+
+/*
+ * DMA Scatter Gather transfer function
+ * mtd : Pointer to mtd_info structure
+ * chip : Pointer to nand_chip structure
+ * bufrdy : SRAM buffer index
+ * pay_load : Pay load buffer physical address
+ * oob_data : OOB data buffer physical address
+ * rd : read flag (1: read operation 0: write operation)
+ */
+static void lpc313x_nand_dma_sg_tfr(struct mtd_info *mtd,
+		struct nand_chip *chip, int bufrdy,	u32 pay_load, u32 oob_data, int rd)
+{
+	struct lpc313x_nand_mtd *nmtd;
+	struct lpc313x_nand_info *host;
+	int eccsize = chip->ecc.size;
+	int oob_size = rd ? chip->ecc.bytes : OOB_FREE_OFFSET;
+
+	nmtd = chip->priv;
+	host = nmtd->host;
+
+	/* SG entry to transfer pay load */
+	host->sg_cpu[0].setup.src_address = rd ? nand_buff_phys_addr[bufrdy] :
+			pay_load;
+	host->sg_cpu[0].setup.dest_address = rd ? pay_load :
+			nand_buff_phys_addr[bufrdy];
+	host->sg_cpu[0].setup.trans_length = (eccsize >> 2) - 1;
+	host->sg_cpu[0].setup.cfg = DMA_CFG_CMP_CH_EN |
+			DMA_CFG_CMP_CH_NR(host->dma_chn) | DMA_CFG_TX_WORD;
+	host->sg_cpu[0].next_entry = host->sg_dma + sizeof(dma_sg_ll_t);
+
+	/* SG entry to transfer OOB data */
+	host->sg_cpu[1].setup.src_address = rd ? (nand_buff_phys_addr[bufrdy] +
+			eccsize) : oob_data;
+	host->sg_cpu[1].setup.dest_address = rd ? oob_data :
+			(nand_buff_phys_addr[bufrdy] + eccsize);
+	host->sg_cpu[1].setup.trans_length = (oob_size >> 2) - 1;
+	host->sg_cpu[1].setup.cfg = DMA_CFG_CMP_CH_EN |
+		      DMA_CFG_CMP_CH_NR(host->dma_chn) | DMA_CFG_TX_WORD;
+	host->sg_cpu[1].next_entry = host->sg_dma + (sizeof(dma_sg_ll_t) * 2);
+
+	/* SG entry to transfer OOB data */
+	host->sg_cpu[2].setup.src_address = host->sg_dma;
+	host->sg_cpu[2].setup.dest_address = DMACH_SOFT_INT_PHYS;
+	host->sg_cpu[2].setup.trans_length = 1;
+	host->sg_cpu[2].setup.cfg = DMA_CFG_TX_WORD;
+	host->sg_cpu[2].next_entry = 0;
+
+	/* Program the SG channel */
+	dma_prog_sg_channel(host->dma_chn, host->sg_dma);
+
+	/* Enable FINISHED interrupt */
+	dma_set_irq_mask(host->dma_chn, 1, 0);
+	dma_set_irq_mask((host->dma_chn - 1), 1, 0);
+
+	/* Set counter to 0 */
+	dma_write_counter((host->dma_chn - 1), 0);
+
+	/* Start the transfer */
+	host->dmapending = 0;
+	dma_start_channel(host->dma_chn);
+
+	/* Wait for FINISHED interrupt */
+	wait_event(host->dma_waitq, host->dmapending);
+
+	/* Mask all the interrupts for the channel */
+	dma_set_irq_mask(host->dma_chn, 1, 1);
+	dma_set_irq_mask((host->dma_chn - 1), 1, 1);
+
+	/* Stop the channel */
+	dma_stop_channel(host->dma_chn);
+
+	return;
+}
+#endif
+
+/*
+ *
+ * NAND controller hardware support functions
+ *
+ */
+
+/* Enable or disable NAND controller clocks */
+static void lpc313x_nand_clocks_disen(int en) {
+	/* Enable or disable clocks for NAND Controller */
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_S0_CLK_ID, en);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_ECC_CLK_ID, en);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_NAND_CLK_ID, en);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_PCLK_ID, en);
+
+	/* Needed for LPC3143/54 chips only */
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_AES_CLK_ID, en);
+}
+
+/*
+ * Setup NAND interface timing
+ */
+static void lpc313x_nand_setrate(struct lpc313x_nand_timing *timing) {
+	u32 tmp, timing1, timing2, srcclk;
+
+	/* Get the NAND controller base clock rate */
+	srcclk = cgu_get_clk_freq(CGU_SB_NANDFLASH_NAND_CLK_ID);
+
+	/* Compute number of clocks for timing1 parameters */
+	tmp = srcclk / (1000000000 / timing->ns_trsd);
+	if (tmp > 0x3)
+		tmp = 0x3;
+	timing1 = NAND_NANDTIMING1_TSRD(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tals);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing1 |= NAND_NANDTIMING1_TALS(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_talh);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing1 |= NAND_NANDTIMING1_TALH(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tcls);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing1 |= NAND_NANDTIMING1_TCLS(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tclh);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing1 |= NAND_NANDTIMING1_TCLH(tmp);
+	nand_writel(TIMING1, timing1);
+
+
+	/* Compute number of clocks for timing2 parameters */
+	tmp = srcclk / (1000000000 / timing->ns_tdrd);
+	if (tmp > 0x3)
+		tmp = 0x3;
+	timing2 = NAND_NANDTIMING2_TDRD(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tebidel);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_NANDTIMING2_TEBI(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tch);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_NANDTIMING2_TCH(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tcs);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_NANDTIMING2_TCS(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_treh);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_NANDTIMING2_TRH(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_trp);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_NANDTIMING2_TRP(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_trw);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_NANDTIMING2_TWH(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_twp);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_NANDTIMING2_TWP(tmp);
+	nand_writel(TIMING2, timing2);
+}
+
+/*
+ * Initialize the NAND interface
+ */
+static int lpc313x_nand_inithw(struct lpc313x_nand_info *host) {
+	unsigned long reg;
+
+	/* Disable all NAND interrupts */
+	nand_writel(IRQMASK1, ~0);
+	nand_writel(IRQMASK2, ~0);
+
+	/* Setup device and controller timing */
+	lpc313x_nand_setrate(host->platform->timing);
+
+	/* enable the controller and de-assert nFCE */
+	reg = nand_readl(CONFIG) | host->nandconfig;
+	nand_writel(CONFIG, reg);
+
+	return 0;
+}
+
+/*
+ * Enable NAND interrupts
+ */
+static inline void lpc313x_nand_int_en(u32 mask) {
+#if !defined(STATUS_POLLING)
+	u32 tmp = nand_readl(IRQMASK1) & ~mask;
+
+	nand_writel(IRQMASK1, tmp);
+#endif
+}
+
+/*
+ * Disable NAND interrupts
+ */
+static inline void lpc313x_nand_int_dis(u32 mask) {
+#if !defined(STATUS_POLLING)
+	u32 tmp = nand_readl(IRQMASK1) | mask;
+
+	nand_writel(IRQMASK1, tmp);
+#endif
+}
+
+/*
+ * Clear NAND interrupts
+ */
+static inline void lpc313x_nand_int_clear(u32 mask) {
+	nand_writel(IRQSTATUSRAW1, mask);
+}
+
+/*
+ * Return pending NAND interrupts status
+ */
+static inline u32 lpc313x_nand_int_get(void) {
+	return nand_readl(IRQSTATUS1);
+}
+
+/*
+ * Return raw NAND interrupts status
+ */
+static inline u32 lpc313x_nand_raw_get(void) {
+	return nand_readl(IRQSTATUSRAW1);
+}
+
+/*
+ * Wait for NAND event
+ */
+static inline void lpc313x_wait_irq(struct lpc313x_nand_info *host) {
+	wait_event(host->irq_waitq, host->intspending);
+}
+
+/*
+ * Handle the NAND interrupt
+ */
+static irqreturn_t lpc313x_nandc_irq(int irq, void *dev_id)
+{
+	/* IRQs not working yet */
+	struct lpc313x_nand_info *host = (struct lpc313x_nand_info *) dev_id;
+
+	/* Disable interrupts for now, but don't clear status yet */
+	host->intspending = lpc313x_nand_int_get();
+	lpc313x_nand_int_dis(~0);
+
+	/* Wakeup pending request */
+	wake_up(&host->irq_waitq);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Start a RAM read operation on RAM0 or RAM1
+ */
+static inline void lpc313x_ram_read(int bufnum) {
+	if (bufnum == 0) {
+		/* Use RAM buffer 0 */
+		nand_writel(CONTROLFLOW, NAND_CTRL_RD_RAM0);
+	}
+	else {
+		/* Use RAM buffer 1 */
+		nand_writel(CONTROLFLOW, NAND_CTRL_RD_RAM1);
+	}
+
+	lpc313x_nand_int_en(nand_buff_dec_mask[bufnum]);
+}
+
+/*
+ * Start a RAM write operation on RAM0 or RAM1
+ */
+static inline void lpc313x_ram_write(int bufnum) {
+	if (bufnum == 0) {
+		/* Use RAM buffer 0 */
+		nand_writel(CONTROLFLOW, NAND_CTRL_WR_RAM0);
+	}
+	else {
+		/* Use RAM buffer 1 */
+		nand_writel(CONTROLFLOW, NAND_CTRL_WR_RAM1);
+	}
+
+	lpc313x_nand_int_en(nand_buff_wr_mask[bufnum]);
+}
+
+/*
+ *
+ * NAND driver callbacks
+ *
+ */
+
+/*
+ * Asserts and deasserts chip selects (callback)
+ */
+static void lpc313x_nand_select_chip(struct mtd_info *mtd, int chip_sel) {
+	struct nand_chip *chip = mtd->priv;
+	struct lpc313x_nand_mtd *nmtd;
+	struct lpc313x_nand_info *host;
+	int i = 0, cssel = -1;
+
+	nmtd = chip->priv;
+	host = nmtd->host;
+
+	if (chip_sel == -1) {
+		/* De-assert all the chip selects */
+		nand_writel(SETCE, NAND_NANDSETCE_CV_MASK);
+	}
+	else {
+		/* We can determine which chip select should be used by
+		   examining the MTD pointer */
+		while (i < host->platform->nr_devices) {
+			if (mtd == &host->mtds[i].mtd) {
+				/* Match */
+				cssel = i;
+				break;
+			}
+
+			i++;
+		}
+
+		if (cssel >= 0) {
+			host->current_cs = cssel;
+			nand_writel(SETCE,
+				(NAND_NANDSETCE_CV_MASK & NAND_NANDSETCE_CV(cssel)));
+		}
+	}
+}
+
+/*
+ * Issue command and address cycles to the chip (callback)
+ */
+static void lpc313x_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl) {
+	(void) mtd;
+	(void) ctrl;
+
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	if (ctrl & NAND_CLE) {
+		nand_writel(SETCMD, (u32) cmd);
+	}
+	else if (ctrl & NAND_ALE) {
+		nand_writel(SETADDR, (u32) cmd);
+	}
+}
+
+/*
+ * Returns NAND busy(0)/ready(!0) status callback
+ */
+
+static int lpc313x_nand_devready(struct mtd_info *mtd) {
+	struct nand_chip *chip = mtd->priv;
+	struct lpc313x_nand_mtd *nmtd;
+	struct lpc313x_nand_info *host;
+
+	nmtd = chip->priv;
+	host = nmtd->host;
+
+	return nand_readl(CHECKSTS) & rdymasks[host->current_cs];
+}
+
+/*
+ * MTD hardware ECC enable callback
+ */
+static void lpc313x_nand_enable_hwecc(struct mtd_info *mtd, int mode) {
+	(void) mtd;
+	(void) mode;
+
+	/* Nothing to really do here, ECC is enabled and used by default */
+}
+
+/*
+ * MTD ECC data correction callback
+ */
+static int lpc313x_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	u32 tmp;
+	int errs_corrected = 0;
+
+	(void) mtd;
+	(void) dat;
+	(void) calc_ecc;
+
+	/* Data is corrected in hardware, just verify that data is correct per HW */
+	if ((nand_readl(IRQSTATUSRAW1) & NAND_NANDIRQSTATUS1_ERR_UNR_RAM0) &
+		(read_ecc[OOB_FREE_OFFSET] != 0xFF)) {
+		return -1;
+	}
+
+	/* Generate correction statistics */
+	tmp = lpc313x_nand_raw_get();
+	if (!(tmp & (NAND_NANDIRQSTATUS1_NOERR_RAM0 | NAND_NANDIRQSTATUS1_NOERR_RAM1))) {
+		if (tmp & (NAND_NANDIRQSTATUS1_ERR1_RAM0 | NAND_NANDIRQSTATUS1_ERR1_RAM1)) {
+			errs_corrected = 1;
+		}
+		else if (tmp & (NAND_NANDIRQSTATUS1_ERR2_RAM0 | NAND_NANDIRQSTATUS1_ERR2_RAM1)) {
+			errs_corrected = 2;
+		}
+		else if (tmp & (NAND_NANDIRQSTATUS1_ERR3_RAM0 | NAND_NANDIRQSTATUS1_ERR3_RAM1)) {
+			errs_corrected = 3;
+		}
+		else if (tmp & (NAND_NANDIRQSTATUS1_ERR4_RAM0 | NAND_NANDIRQSTATUS1_ERR4_RAM1)) {
+			errs_corrected = 4;
+		}
+		else if (tmp & (NAND_NANDIRQSTATUS1_ERR5_RAM0 | NAND_NANDIRQSTATUS1_ERR5_RAM1)) {
+			errs_corrected = 5;
+		}
+
+		mtd->ecc_stats.corrected += errs_corrected;
+	}
+	else if (tmp & (NAND_NANDIRQSTATUS1_ERR_UNR_RAM0 | NAND_NANDIRQSTATUS1_ERR_UNR_RAM1)) {
+		mtd->ecc_stats.failed++;
+	}
+
+	return 0;
+}
+
+/*
+ * MTD calculate ECC callback
+ */
+static int lpc313x_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	(void) mtd;
+	(void) dat;
+	(void) ecc_code;
+
+	/* ECC is calculated automatically in hardware, nothing to do */
+	return 0;
+}
+
+/*
+ * Verify a buffer written to hardware against the passed buffer (callback)
+ */
+static int lpc313x_nand_verify_hwecc(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc313x_nand_mtd *nmtd;
+	struct lpc313x_nand_info *host;
+	int i, status = 0, curbuf = 0, bufrdy = -1;
+
+	nmtd = chip->priv;
+	host = nmtd->host;
+
+	/* Read back the data stored in the hardware and check it against the buffer */
+	for (i = 0; i < len; i += chip->ecc.size) {
+		/* Clear all current statuses */
+		lpc313x_nand_int_clear(~0);
+
+		/* Start read into RAM0 or RAM1 */
+#if !defined(STATUS_POLLING)
+		host->intspending = 0;
+#endif
+		lpc313x_ram_read(curbuf);
+
+		/* Compare current buffer while next buffer is loading */
+		if (bufrdy >= 0) {
+			if (memcmp(buf, nand_buff_addr[bufrdy], chip->ecc.size) != 0) {
+				status = -EIO;
+			}
+
+			buf += chip->ecc.size;
+		}
+
+#if defined(STATUS_POLLING)
+		/* Polling for buffer loaded and decoded */
+		while (!((nand_readl(IRQSTATUSRAW1)) & nand_buff_dec_mask[curbuf]));
+
+#else
+		/* Interrupt based wait operation */
+		lpc313x_wait_irq(host);
+#endif
+
+		bufrdy = curbuf;
+		curbuf = 1 - curbuf;
+	}
+
+	/* Compare against buffer */
+	if (memcmp(buf, nand_buff_addr[bufrdy], chip->ecc.size) != 0) {
+		status = -EIO;
+	}
+
+	/* Disable all interrupts */
+	lpc313x_nand_int_dis(~0);
+
+	return status;
+}
+
+/*
+ * 8-bit direct NAND interface read callback
+ */
+static void lpc313x_nand_read_buf8(struct mtd_info *mtd, u_char *buf, int len) {
+	struct nand_chip *chip = mtd->priv;
+
+	__raw_readsb(chip->IO_ADDR_R, buf, len);
+}
+
+/*
+ * 16-bit direct NAND interface read callback
+ */
+static void lpc313x_nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len) {
+	struct nand_chip *chip = mtd->priv;
+
+	len >>= 1;
+	__raw_readsw(chip->IO_ADDR_R, buf, len);
+}
+
+/*
+ * 8-bit direct NAND interface write callback
+ */
+static void lpc313x_nand_write_buf8(struct mtd_info *mtd, const u_char *buf,
+		int len) {
+	struct nand_chip *chip = mtd->priv;
+
+	__raw_writesb(chip->IO_ADDR_W, buf, len);
+}
+
+/*
+ * 16-bit direct NAND interface write callback
+ */
+static void lpc313x_nand_write_buf16(struct mtd_info *mtd, const u_char *buf,
+		int len) {
+	struct nand_chip *chip = mtd->priv;
+
+	len >>= 1;
+	__raw_writesw(chip->IO_ADDR_W, buf, len);
+}
+
+/*
+ * Read the payload and OOB data from the device in the hardware storage format
+ */
+static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+				   uint8_t *buf)
+{
+	int i, curbuf = 0, bufrdy = -1, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *p = buf;
+	uint8_t *oob = chip->oob_poi;
+#ifdef USE_DMA
+	int use_dma = 0;
+	dma_addr_t pmapped = 0, oobmapped = 0;
+	u32 p1 = 0, oob1 = 0;
+#endif
+
+#if !defined(STATUS_POLLING)
+	struct lpc313x_nand_mtd *nmtd;
+	struct lpc313x_nand_info *host;
+
+	nmtd = chip->priv;
+	host = nmtd->host;
+#endif
+
+#ifdef USE_DMA
+	/* Get DMA mappings for buffers */
+	pmapped = lpc313x_nand_dma_map(host, (u32) p, (eccsize * eccsteps), 1);
+	oobmapped = lpc313x_nand_dma_map(host, (u32) oob, (eccbytes * eccsteps), 1);
+	if((oobmapped) && (pmapped)) {
+		p1 = pmapped;
+		oob1 = oobmapped;
+		use_dma = 1;
+	}
+#endif
+
+	for (i = eccsteps; i > 0; i--) {
+		/* Clear all current statuses */
+		lpc313x_nand_int_clear(~0);
+
+		/* Start read into RAM0 or RAM1 */
+#if !defined(STATUS_POLLING)
+		host->intspending = 0;
+#endif
+		lpc313x_ram_read(curbuf);
+
+		/* Read current buffer while next buffer is loading */
+		if (bufrdy >= 0) {
+
+#ifdef USE_DMA
+			/* If DMA mapping succesful, use DMA for transfer.
+			 * Else use memcpy for transfer
+			 * */
+			if(use_dma) {
+				/* Read payload & oob using DMA */
+				lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 1);
+
+				/* Update buffers offsets */
+				p1 += eccsize;
+				oob1 += eccbytes;
+			}
+			else
+#endif
+			{
+				/* Read payload portion of the transfer */
+				memcpy((void *)p, nand_buff_addr[bufrdy], eccsize);
+				p += eccsize;
+
+				/* Read OOB data portion of the transfer */
+				memcpy((void *)oob, nand_buff_addr[bufrdy] + eccsize, eccbytes);
+				oob += eccbytes;
+			}
+		}
+
+#if defined(STATUS_POLLING)
+		/* Polling for buffer loaded and decoded */
+		while (!((nand_readl(IRQSTATUSRAW1)) & nand_buff_dec_mask[curbuf]));
+
+#else
+		/* Interrupt based wait operation */
+		lpc313x_wait_irq(host);
+#endif
+
+		bufrdy = curbuf;
+		curbuf = 1 - curbuf;
+
+		chip->ecc.correct(mtd, p, oob, NULL);
+	}
+
+#ifdef USE_DMA
+	if(use_dma) {
+		/* Transfer payload & oob using DMA */
+		lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 1);
+
+		/* Unmap DMA mappings */
+		dma_unmap_single(host->dev, pmapped, (eccsize * eccsteps),
+				DMA_FROM_DEVICE);
+		dma_unmap_single(host->dev, oobmapped, (eccbytes * eccsteps),
+				DMA_FROM_DEVICE);
+	}
+	else
+#endif
+	{
+		/* Read payload portion of the transfer */
+		memcpy((void *)p, nand_buff_addr[bufrdy], eccsize);
+
+		/* Read OOB data portion of the transfer */
+		memcpy((void *)oob, nand_buff_addr[bufrdy] + eccsize, eccbytes);
+	}
+
+	/* Disable all interrupts */
+	lpc313x_nand_int_dis(~0);
+
+	return 0;
+}
+
+/*
+ * Read the OOB data from the device in the hardware storage format
+ */
+static int lpc313x_nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+				  int page, int sndcmd)
+{
+	uint8_t *buf = chip->oob_poi;
+	int length = mtd->oobsize;
+	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
+	int eccsize = chip->ecc.size, eccsteps = chip->ecc.steps;
+	uint8_t *bufpoi = buf;
+	int i, toread, sndrnd = sndcmd, pos;
+
+	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
+	for (i = eccsteps; i > 0; i--) {
+		/* Random position read needed? */
+		if (sndrnd) {
+			pos = eccsize + i * (eccsize + chunk);
+			if (mtd->writesize > 512)
+				chip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);
+			else
+				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
+		} else {
+			sndrnd = 1;
+		}
+
+		toread = min_t(int, length, chunk);
+		chip->read_buf(mtd, bufpoi, toread);
+		bufpoi += toread;
+		length -= toread;
+	}
+	if (length > 0)
+		chip->read_buf(mtd, bufpoi, length);
+
+	return 1;
+}
+
+/*
+ * Write the payload and OOB data to the device in the hardware storage format
+ */
+static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
+				    struct nand_chip *chip, const uint8_t *buf)
+{
+	int i, curbuf = 0, bufrdy = 0, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *oob = chip->oob_poi;
+#ifdef USE_DMA
+	dma_addr_t pmapped, oobmapped;
+	u32 p1 = 0, oob1 = 0;
+	int use_dma = 0;
+#endif
+
+#if !defined(STATUS_POLLING)
+	struct lpc313x_nand_mtd *nmtd;
+	struct lpc313x_nand_info *host;
+
+	nmtd = chip->priv;
+	host = nmtd->host;
+#endif
+
+#ifdef USE_DMA
+	pmapped = lpc313x_nand_dma_map(host, (u32) p, (eccsize * eccsteps), 0);
+	oobmapped = lpc313x_nand_dma_map(host, (u32) oob, (eccbytes * eccsteps), 0);
+	if((pmapped) && (oobmapped)) {
+		use_dma = 1;
+		p1 = pmapped;
+		oob1 = oobmapped;
+	}
+#endif
+
+	/* Clear all current statuses */
+	lpc313x_nand_int_clear(~0);
+#ifdef USE_DMA
+	/* If DMA mapping succesful, use DMA for transfer.
+	 * Else use memcpy for transfer
+	 * */
+	if(use_dma) {
+		/* Transfer pay load & OOB using DMA */
+		lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 0);
+
+		/* Update buffer offsets */
+		p1 += eccsize;
+		oob1 += eccbytes;
+	}
+	else
+#endif
+	{
+		/* Copy payload and OOB data to the buffer */
+		memcpy((void *) nand_buff_addr[bufrdy], p, eccsize);
+		memcpy((void *) nand_buff_addr[bufrdy] + eccsize, oob, OOB_FREE_OFFSET);
+		p += eccsize;
+		oob += eccbytes;
+	}
+
+	while(!((nand_readl(IRQSTATUSRAW1)) & nand_buff_enc_mask[bufrdy]));
+
+	for (i = eccsteps; i > 0; i--) {
+		/* Buffer management */
+		curbuf = bufrdy;
+		bufrdy = 1 - bufrdy;
+
+		/* Start the transfer to the device */
+		lpc313x_nand_int_clear(~0);
+#if !defined(STATUS_POLLING)
+		host->intspending = 0;
+#endif
+		lpc313x_ram_write(curbuf);
+
+		/* Copy next payload and OOB data to the buffer while current
+		   buffer is transferring */
+		if (i > 1) {
+
+#ifdef USE_DMA
+			/* If DMA mapping succesful, use DMA for transfer.
+			 * Else use memcpy for transfer
+			 * */
+			if(use_dma) {
+				/* Transfer pay load & OOB using DMA */
+				lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 0);
+
+				/* Update buffer offsets */
+				p1 += eccsize;
+				oob1 += eccbytes;
+			}
+			else
+#endif
+			{
+				memcpy((void *) nand_buff_addr[bufrdy], p, eccsize);
+				memcpy((void *) nand_buff_addr[bufrdy] + eccsize, oob, OOB_FREE_OFFSET);
+				p += eccsize;
+				oob += eccbytes;
+			}
+			while(!((nand_readl(IRQSTATUSRAW1)) & nand_buff_enc_mask[bufrdy]));
+		}
+
+#if defined(STATUS_POLLING)
+		/* Polling for buffer loaded and decoded */
+		while (!((nand_readl(IRQSTATUSRAW1)) & nand_buff_wr_mask[curbuf]));
+
+#else
+		/* Interrupt based wait operation */
+		lpc313x_wait_irq(host);
+#endif
+	}
+
+	/* Calculate remaining oob bytes */
+	i = mtd->oobsize - (oob - chip->oob_poi);
+	if (i)
+		chip->write_buf(mtd, oob, i);
+
+#ifdef USE_DMA
+	/* Unmap DMA mappings */
+	if(use_dma) {
+		dma_unmap_single(host->dev, pmapped, (eccsize * eccsteps),
+				DMA_TO_DEVICE);
+		dma_unmap_single(host->dev, oobmapped, (eccbytes * eccsteps),
+				DMA_TO_DEVICE);
+	}
+#endif
+
+	/* Disable all interrupts */
+	lpc313x_nand_int_dis(~0);
+}
+
+/*
+ * Write the OOB data to the device in the hardware storage format
+ */
+static int lpc313x_nand_write_oob_syndrome(struct mtd_info *mtd,
+				   struct nand_chip *chip, int page)
+{
+	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
+	int eccsize = chip->ecc.size, length = mtd->oobsize;
+	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
+	const uint8_t *bufpoi = chip->oob_poi;
+
+	pos = eccsize;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
+	for (i = 0; i < steps; i++) {
+		if (sndcmd) {
+			if (mtd->writesize <= 512) {
+				uint32_t fill = 0xFFFFFFFF;
+
+				len = eccsize;
+				while (len > 0) {
+					int num = min_t(int, len, 4);
+					chip->write_buf(mtd, (uint8_t *)&fill,
+							num);
+					len -= num;
+				}
+			} else {
+				pos = eccsize + i * (eccsize + chunk);
+				chip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);
+			}
+		} else {
+			sndcmd = 1;
+		}
+
+		len = min_t(int, length, chunk);
+		chip->write_buf(mtd, bufpoi, len);
+		bufpoi += len;
+		length -= len;
+	}
+	if (length > 0)
+		chip->write_buf(mtd, bufpoi, length);
+
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/*
+ * Add MTD partitions and a single MTD device
+ */
+static int lpc313x_nand_add_partition(struct lpc313x_nand_info *host,
+		struct lpc313x_nand_mtd *bmtd, struct lpc313x_nand_dev_info *device)
+{
+	struct mtd_info *mtd = &bmtd->mtd;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *partitions = NULL;
+	int num_partitions = 0;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	const char *part_probes[] = {"cmdlinepart", NULL};
+
+	/* Check for partitions from the CMDLINE first, these will override the
+	   board specific partitions */
+	mtd->name = "lpc313x_nand";
+	num_partitions = parse_mtd_partitions(mtd, part_probes,
+					      &partitions, 0);
+#endif
+
+	if ((num_partitions <= 0) && (device->partitions))
+	{
+		/* No CMDLINE partitions, try board specific partitions */
+		partitions = device->partitions;
+		num_partitions = device->nr_partitions;
+	}
+
+	if ((!partitions) || (num_partitions == 0)) {
+		dev_dbg(host->dev, "No parititions defined\n");
+		return ENXIO;
+	}
+
+	return add_mtd_partitions(mtd, partitions, num_partitions);
+
+#else
+	return add_mtd_device(mtd);
+#endif
+}
+
+/*
+ * Init a single instance of an chip
+ */
+static void lpc313x_nand_init_chip(struct lpc313x_nand_info *host,
+				struct lpc313x_nand_mtd *nmtd) {
+	struct nand_chip *chip = &nmtd->chip;
+
+	if (host->platform->support_16bit) {
+		chip->write_buf = lpc313x_nand_write_buf16;
+		chip->read_buf = lpc313x_nand_read_buf16;
+	}
+	else {
+		chip->write_buf = lpc313x_nand_write_buf8;
+		chip->read_buf = lpc313x_nand_read_buf8;
+	}
+	chip->select_chip = lpc313x_nand_select_chip;
+	chip->chip_delay = 20;
+	chip->priv = nmtd;
+	chip->controller = &host->controller;
+
+	chip->IO_ADDR_W = (void *) &NAND_WRITEDATA;
+	chip->cmd_ctrl = lpc313x_nand_hwcontrol;
+	chip->dev_ready = lpc313x_nand_devready;
+	chip->IO_ADDR_R = (void *) &NAND_READDATA;
+
+	nmtd->host = host;
+	nmtd->mtd.priv = chip;
+	nmtd->mtd.owner = THIS_MODULE;
+
+	chip->ecc.mode = NAND_ECC_HW_SYNDROME;
+	chip->ecc.read_page_raw = lpc313x_nand_read_page_syndrome;
+	chip->ecc.read_page = lpc313x_nand_read_page_syndrome;
+	chip->ecc.write_page = lpc313x_nand_write_page_syndrome;
+	chip->ecc.write_oob = lpc313x_nand_write_oob_syndrome;
+	chip->ecc.read_oob = lpc313x_nand_read_oob_syndrome;
+	chip->ecc.calculate = lpc313x_nand_calculate_ecc;
+	chip->ecc.correct   = lpc313x_nand_correct_data;
+	chip->ecc.hwctl = lpc313x_nand_enable_hwecc;
+
+	chip->verify_buf = lpc313x_nand_verify_hwecc;
+	chip->options |= NAND_USE_FLASH_BBT;
+	if (host->platform->support_16bit) {
+		chip->options |= NAND_BUSWIDTH_16;
+	}
+
+	/* Assume large block FLASH for now, will adjust after detection */
+	chip->ecc.layout = &nand_hw_eccoob_64;
+}
+
+/*
+ * Post-probe chip update, to change any items, such as the
+ * layout for large page nand
+ */
+static void lpc313x_nand_update_chip(struct lpc313x_nand_info *info,
+		struct lpc313x_nand_mtd *nmtd) {
+	struct nand_chip *chip = &nmtd->chip;
+
+	chip->bbt_td = &lpc313x_bbt_main_descr;
+	chip->bbt_md = &lpc313x_bbt_mirror_descr;
+
+	/* Select bad block algorithm and ECC layout based on whether
+	   small, large, or hig block FLASH is used */
+	if (chip->page_shift <= 10) {
+		/* Small block FLASH */
+		chip->ecc.layout = &nand_hw_eccoob_16;
+		// FIXME unknown if this works
+	}
+#ifdef HUGE_BLOCK_SUPPORT
+	else if (chip->page_shift >= 13) {
+		/* Huge block FLASH */
+		chip->ecc.layout = &nand_hw_eccoob_128;
+		// FIXME bad block descriptors for huge block FLASH not done
+	}
+#endif
+	else {
+		/* Large block FLASH */
+		chip->ecc.layout = &nand_hw_eccoob_64;
+		chip->bbt_td = &lpc313x_bbt_main_descr;
+		chip->bbt_md = &lpc313x_bbt_mirror_descr;
+		chip->badblock_pattern = &lpc313x_largepage_flashbased;
+	}
+
+	/* These sizes remain the same regardless of page/block size */
+	chip->ecc.size = 512;
+	chip->ecc.bytes = 16;
+	chip->ecc.prepad = 0;
+}
+
+/*
+ * Called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices.
+ */
+static int lpc313x_nand_probe(struct platform_device *pdev) {
+	struct lpc313x_nand_info *host = NULL;
+	struct lpc313x_nand_cfg *plat = pdev->dev.platform_data;
+	int irq, scan_res, mtdsize, i, err = 0;
+
+	/* Get required resources */
+	irq = platform_get_irq(pdev, 0);
+	if ((irq < 0) | (irq >= NR_IRQS))
+	{
+		return -EBUSY;
+	}
+
+	host = kmalloc(sizeof (struct lpc313x_nand_info), GFP_KERNEL);
+	if (host == NULL) {
+		dev_err(&pdev->dev, "No memory for flash info\n");
+		err = -ENOMEM;
+		goto exit_error;
+	}
+
+	memset(host, 0, sizeof(*host));
+	/* Register driver data with platform */
+	platform_set_drvdata(pdev, host);
+
+	host->dev = &pdev->dev;
+	host->platform = plat;
+	host->irq = irq;
+	host->current_cs = 0;
+
+	/* Exit if no platform data */
+	if (plat == NULL) {
+		dev_err(&pdev->dev, "No memory for flash info\n");
+		goto exit_error;
+	}
+
+	/* Initialize lock and queue used by higher level NAND driver */
+	spin_lock_init(&host->controller.lock);
+	init_waitqueue_head(&host->controller.wq);
+
+	/* Enable clocks for NAND Controller */
+	lpc313x_nand_clocks_disen(1);
+
+	/* Reset NAND controller */
+	cgu_soft_reset_module(NANDFLASH_CTRL_NAND_RESET_N_SOFT);
+	cgu_soft_reset_module(NANDFLASH_CTRL_ECC_RESET_N_SOFT);
+
+	/* Needed for LPC315x series only */
+	cgu_soft_reset_module(NANDFLASH_CTRL_AES_RESET_N_SOFT);
+
+	/* check NAND mux signals */
+	sys_writel(MUX_NAND_MCI, 0);
+
+	/* Setup NAND configuration */
+	if (plat->support_16bit) {
+		/* 16-bit mode */
+		host->nandconfig = NAND_NANDCONFIG_DC | NAND_NANDCONFIG_ECGC |
+			NAND_NANDCONFIG_EC | NAND_NANDCONFIG_WD;
+	}
+	else {
+		/* 8-bit mode */
+		host->nandconfig = NAND_NANDCONFIG_DC | NAND_NANDCONFIG_ECGC |
+			NAND_NANDCONFIG_EC;
+	}
+
+	/* Initialize the hardware */
+	err = lpc313x_nand_inithw(host);
+	if (err != 0)
+		goto exit_error;
+
+	/* Attach interrupt handler */
+	err = request_irq(host->irq, lpc313x_nandc_irq,
+		IRQF_DISABLED, "nandirq", host);
+	if (err)
+	{
+		goto exit_error;
+	}
+
+	/* IRQ event queue */
+	init_waitqueue_head(&host->irq_waitq);
+
+	/* Allocate space for the MTD data */
+	mtdsize = sizeof(struct lpc313x_nand_mtd) * host->platform->nr_devices;
+	host->mtds = kmalloc(mtdsize, GFP_KERNEL);
+	if (host->mtds == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate mtd storage\n");
+		err = -ENOMEM;
+		goto exit_error2;
+	}
+	memset(host->mtds, 0, mtdsize);
+
+#ifdef USE_DMA
+	/* Allocate sg channel for DMA transfers */
+	host->dma_chn = dma_request_sg_channel("NAND", lpc313x_nand_dma_irq,
+			host, 1);
+	if(host->dma_chn < 0) {
+		dev_err(&pdev->dev, "Failed to allocate DMA SG channel\n");
+		err = host->dma_chn;
+		goto exit_error3;
+	}
+
+	/* Allocate memory for SG Table */
+	host->sg_cpu = dma_alloc_coherent(&pdev->dev,
+			NAND_DMA_MAX_DESC * sizeof(dma_sg_ll_t), &host->sg_dma, GFP_KERNEL);
+	if (host->sg_cpu == NULL) {
+		dev_err(&pdev->dev, "could not alloc dma memory\n");
+		goto exit_error4;
+	}
+
+	/* Initialise DMA wait queue */
+	init_waitqueue_head(&host->dma_waitq);
+#endif
+
+	/* Add MTDs and partitions */
+	for (i = 0; i < host->platform->nr_devices; i++) {
+		dev_dbg(&pdev->dev, "Initializing NAND device on CS%d (%s)\n",
+			i, host->platform->devices[i].name);
+
+		/* Populdate device callbacks used by MTD driver */
+		lpc313x_nand_init_chip(host, &host->mtds[i]);
+
+		/* Scan NAND flash device */
+		scan_res = nand_scan_ident(&host->mtds[i].mtd, 1);
+
+		/* Continue if a device is found */
+		if (scan_res == 0) {
+			/* Update callbacks based on NAND sizing data */
+			lpc313x_nand_update_chip(host, &host->mtds[i]);
+
+			/* Post architecture MTD init */
+			nand_scan_tail(&host->mtds[i].mtd);
+
+			/* Add partitions and MTD device */
+			if (lpc313x_nand_add_partition(host, &host->mtds[i],
+				(plat->devices + i)) < 0) {
+				nand_release(&host->mtds[i].mtd);
+			}
+		}
+		else {
+			dev_dbg(&pdev->dev, "No device detected on CS%d (%s)\n",
+				i, host->platform->devices[i].name);
+		}
+	}
+
+	return 0;
+
+#ifdef USE_DMA
+exit_error4:
+	/* Release sg channel */
+	dma_release_sg_channel(host->dma_chn);
+
+exit_error3:
+	/* Release memory */
+	if(host->mtds != NULL)
+		kfree(host->mtds);
+#endif
+
+exit_error2:
+	/* Release IRQ */
+	free_irq(host->irq, pdev);
+
+exit_error:
+	if (host != NULL)
+		kfree(host);
+
+	/* Disable clocks for NAND Controller */
+	lpc313x_nand_clocks_disen(0);
+
+	return err;
+}
+
+/*
+ * Device removal
+ */
+static int lpc313x_nand_remove(struct platform_device *pdev) {
+	struct lpc313x_nand_info *host = platform_get_drvdata(pdev);
+	int i;
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (host == NULL)
+		return 0;
+
+	/* Release all the MTDs */
+	for (i = 0; i < host->platform->nr_devices; i++) {
+		dev_dbg(&pdev->dev, "Releasing mtd device %d (%s)\n", i,
+			host->platform->devices[i].name);
+		nand_release(&host->mtds[i].mtd);
+	}
+
+	/* Disable clocks for NAND Controller */
+	lpc313x_nand_clocks_disen(1);
+
+#ifdef USE_DMA
+	/* Release memory allocated for SG table */
+	dma_free_coherent(host->dev, NAND_DMA_MAX_DESC * sizeof(dma_sg_ll_t),
+			host->sg_cpu, host->sg_dma);
+
+	/* Release sg channel */
+	dma_release_sg_channel(host->dma_chn);
+#endif
+
+	/* Release IRQ */
+	free_irq(host->irq, pdev);
+
+	kfree(host->mtds);
+	kfree(host);
+
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+static int lpc313x_nand_resume(struct platform_device *pdev)
+{
+	/* Enables clocks for NAND Controller */
+	lpc313x_nand_clocks_disen(1);
+
+	return 0;
+}
+
+static int lpc313x_nand_suspend(struct platform_device *pdev, pm_message_t pm)
+{
+	/* Disable clocks for NAND Controller */
+	lpc313x_nand_clocks_disen(0);
+
+	return 0;
+}
+
+#else
+#define lpc313x_nand_resume NULL
+#define lpc313x_nand_suspend NULL
+#endif
+
+static struct platform_driver lpc313x_nand_driver = {
+	.probe		= lpc313x_nand_probe,
+	.remove		= lpc313x_nand_remove,
+	.resume		= lpc313x_nand_resume,
+	.suspend	= lpc313x_nand_suspend,
+	.driver = {
+		.name = "lpc313x_nand",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init lpc313x_nand_init(void)
+{
+	return platform_driver_register(&lpc313x_nand_driver);
+}
+
+static void __exit lpc313x_nand_exit(void)
+{
+	platform_driver_unregister(&lpc313x_nand_driver);
+}
+
+module_init( lpc313x_nand_init);
+module_exit( lpc313x_nand_exit);
+
+MODULE_DESCRIPTION("LPC313x NAND Controller driver");
+MODULE_AUTHOR("NXP Semiconductor VietNam");
+MODULE_LICENSE("GPL v2");
+
diff -purN linux-2.6.28.2/drivers/mtd/nand/Makefile work_2.6.28.2/drivers/mtd/nand/Makefile
--- linux-2.6.28.2/drivers/mtd/nand/Makefile	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/mtd/nand/Makefile	2010-03-15 16:58:23.000000000 -0700
@@ -36,5 +36,6 @@ obj-$(CONFIG_MTD_NAND_FSL_ELBC)		+= fsl_
 obj-$(CONFIG_MTD_NAND_FSL_UPM)		+= fsl_upm.o
 obj-$(CONFIG_MTD_NAND_SH_FLCTL)		+= sh_flctl.o
 obj-$(CONFIG_MTD_NAND_MXC)		+= mxc_nand.o
+obj-$(CONFIG_MTD_NAND_LPC313X)		+= lpc313x_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff -purN linux-2.6.28.2/drivers/net/cs89x0.c work_2.6.28.2/drivers/net/cs89x0.c
--- linux-2.6.28.2/drivers/net/cs89x0.c	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/net/cs89x0.c	2010-03-15 16:58:23.000000000 -0700
@@ -193,6 +193,13 @@ static unsigned int cs8900_irq_map[] = {
 #define CIRRUS_DEFAULT_IRQ	VH_INTC_INT_NUM_CASCADED_INTERRUPT_1 /* Event inputs bank 1 - ID 35/bit 3 */
 static unsigned int netcard_portlist[] __used __initdata = {CIRRUS_DEFAULT_BASE, 0};
 static unsigned int cs8900_irq_map[] = {CIRRUS_DEFAULT_IRQ, 0, 0, 0};
+#elif defined(CONFIG_MACH_VAL3153)
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#define CS8900_IOBARRIER	(*(volatile u16 __force*) io_p2v(INTC_PHYS))
+#define CIRRUS_DEFAULT_BASE	io_p2v(EXT_SRAM1_PHYS + 0x10000)	/* = Physical address 0x20030000 */
+static unsigned int netcard_portlist[] __used __initdata = {CIRRUS_DEFAULT_BASE, 0};
+static unsigned int cs8900_irq_map[] = {IRQ_CS8900_ETH_INT, 0, 0, 0};
 #elif defined(CONFIG_MACH_MX31ADS)
 #include <mach/board-mx31ads.h>
 static unsigned int netcard_portlist[] __used __initdata = {
@@ -332,6 +339,12 @@ struct net_device * __init cs89x0_probe(
 	if (net_debug)
 		printk("cs89x0:cs89x0_probe(0x%x)\n", io);
 
+#ifdef CONFIG_MACH_VAL3153
+	if(unit > 0) {
+		err = -ENODEV;
+		goto out;
+	}
+#endif
 	if (io > 0x1ff)	{	/* Check a single specified location. */
 		err = cs89x0_probe1(dev, io, 0);
 	} else if (io != 0) {	/* Don't probe at all. */
@@ -391,6 +404,24 @@ writeword(unsigned long base_addr, int p
 {
 	outw(value, base_addr + (portno << 1));
 }
+#elif defined(CONFIG_MACH_VAL3153)
+static u16
+readword(unsigned long base_addr, int portno)
+{
+	u16 v;
+	CS8900_IOBARRIER;
+	v = inw(base_addr + portno);
+	CS8900_IOBARRIER;
+	return v;
+}
+
+static void
+writeword(unsigned long base_addr, int portno, u16 value)
+{
+	CS8900_IOBARRIER;
+	outw(value, base_addr + portno);
+	CS8900_IOBARRIER;
+}
 #else
 static u16
 readword(unsigned long base_addr, int portno)
@@ -572,7 +603,7 @@ cs89x0_probe1(struct net_device *dev, in
 		goto out1;
 	}
 
-#ifdef CONFIG_SH_HICOSH4
+#if defined(CONFIG_SH_HICOSH4) || defined(CONFIG_MACH_VAL3153)
 	/* truely reset the chip */
 	writeword(ioaddr, ADD_PORT, 0x0114);
 	writeword(ioaddr, DATA_PORT, 0x0040);
@@ -674,9 +705,12 @@ cs89x0_probe1(struct net_device *dev, in
 		}
 	} else
 #endif
-
+/* quick hack for VAL3153 boards to reuse the mac address set by boot loader */
+#if !defined(CONFIG_MACH_VAL3153)
         if ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) ==
-	      (EEPROM_OK|EEPROM_PRESENT)) {
+	      (EEPROM_OK|EEPROM_PRESENT)) 
+#endif
+	{
 	        /* Load the MAC. */
 		for (i=0; i < ETH_ALEN/2; i++) {
 	                unsigned int Addr;
diff -purN linux-2.6.28.2/drivers/net/Kconfig work_2.6.28.2/drivers/net/Kconfig
--- linux-2.6.28.2/drivers/net/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/net/Kconfig	2010-03-15 16:57:43.000000000 -0700
@@ -1393,7 +1393,7 @@ config FORCEDETH_NAPI
 config CS89x0
 	tristate "CS89x0 support"
 	depends on NET_ETHERNET && (ISA || EISA || MACH_IXDP2351 \
-		|| ARCH_IXDP2X01 || ARCH_PNX010X || MACH_MX31ADS)
+		|| ARCH_IXDP2X01 || ARCH_PNX010X || MACH_MX31ADS || MACH_VAL3153)
 	---help---
 	  Support for CS89x0 chipset based Ethernet cards. If you have a
 	  network (Ethernet) card of this type, say Y and read the
@@ -1407,7 +1407,7 @@ config CS89x0
 config CS89x0_NONISA_IRQ
 	def_bool y
 	depends on CS89x0 != n
-	depends on MACH_IXDP2351 || ARCH_IXDP2X01 || ARCH_PNX010X || MACH_MX31ADS
+	depends on MACH_IXDP2351 || ARCH_IXDP2X01 || ARCH_PNX010X || MACH_MX31ADS || MACH_VAL3153
 
 config TC35815
 	tristate "TOSHIBA TC35815 Ethernet support"
diff -purN linux-2.6.28.2/drivers/serial/8250.c work_2.6.28.2/drivers/serial/8250.c
--- linux-2.6.28.2/drivers/serial/8250.c	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/serial/8250.c	2010-03-16 10:36:22.000000000 -0700
@@ -18,6 +18,76 @@
  *  membase is an 'ioremapped' cookie.
  */
 
+/*
+ * NXP UART driver DMA modifications notification
+ *
+ * This driver has been modifed to use DMA for transfer of the
+ * serial buffers. These modifications are specific to the
+ * LPC31XX version of the 8250 UART.
+ *
+ * Specific driver modifications
+ *  General modifications
+ *   1) 8250 RX/RX timeout/TX interrupts are no longer used.
+ *   2) 8250 error status and break interrupts are still used,
+ *      but 'per character' status doesn't work with DMA, so
+ *      an error status is applied to the last DMA'd character
+ *      when the error occurs. This may not always be accurate,
+ *      but it's generally used for statistics only.
+ *   3) Breaks requires a flush of the RX FIFO and toss the
+ *      current DMA buffer. Because of the nature of breaks,
+ *      this is generally ok.
+ *   4) TX timeout logic (timer) no longer used.
+ *
+ *  RX side modifications
+ *   1) RX FIFO based mechanism replaced with DMA based circ
+ *      buffer logic.The DMA nevers stops servicing the FIFO
+ *      event when the DMA buffer is 
+ *
+ *
+ *  TX side modifications
+ *   1) TX FIFO based logic removed. DMA block transfer of up
+ *      to 64 bytes per transfer occur now.
+ *   2) DMA transfer resets on empty TX FIFO transfer again
+ *      transferring up to 64 bytes. A single DMA transfer
+ *      will never exceed 64 bytes in a single transfer.
+ *   3) DMA TX transfers need to start when the UART TX FIFO
+ *      is empty, so the start od the DMA TX transfer is based
+ *      on the UART TX holding register empty interrupt.
+
+ *
+ * The serial core does not support DMA transfer. Transmit buffers
+ * can be easily sent as a DMA buffer, but RX buffers require special
+ * handling and still need to be sent to the serial core a byte at a
+ * time. DMA transfer sizes vary per application. The size of the
+ * circular buffer in the serial core is fixed. Maximum DMA RX
+ * transfer size is limited to the serial core buffer sizes, while
+ * DMA TX size is limited to the TX FIFO size.
+ *
+ * For TX, a DMA transfer is complete when the entire DMA transfer
+ * has been sent to the UART FIFO via the DMA channel. However,
+ * the TX transfer cannot be restarted until the TX FIFO is again
+ * empty. Because of this, the DMA completion interrupt is ignored
+ * and the UART TX holding register interrupt is used instead.
+ *
+ * For RX, a DMA transfer is more complicated. To maintain the
+ * 'per byte' RX status, the circular buffer in the serial core
+ * cannot be used. Although DMA is used to process the transfer,
+ * each individual char received still needs to be individually
+ * processed and submitted to the serial core. The RX FIFO and
+ * RX timeout interrupts are no longer used. The RX error and
+ * break status interrupts are still used, but no longer apply to
+ * the currently received character. Because of this, the RX
+ * handler always applies the accumulated status to the last DMA
+ * character received. Since the RX timeout interrupt is no
+ * longer used, a timer is used to emulate the RX timeouot check.
+ * As the DMA will only generate an interrupt on a full RX buffer,
+ * this timers purpose is important to periodically check if the
+ * DMA has received characters.
+ *
+ * Early console support is unchanged. Non-DMA mode will be used
+ * for early console support until the driver is initialized.
+ */
+
 #if defined(CONFIG_SERIAL_8250_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
 #define SUPPORT_SYSRQ
 #endif
@@ -38,9 +108,11 @@
 #include <linux/serial_8250.h>
 #include <linux/nmi.h>
 #include <linux/mutex.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <mach/dma.h>
 
 #include "8250.h"
 
@@ -124,6 +196,29 @@ static unsigned long probe_rsa[PORT_RSA_
 static unsigned int probe_rsa_count;
 #endif /* CONFIG_SERIAL_8250_RSA  */
 
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+struct LPC31XX_DMA {
+	dma_addr_t		dma_buff_p;
+	void			*dma_buff_v;
+	int			dmach;
+	struct tasklet_struct	tasklet;
+	int			count;
+	struct timer_list	timer;		/* "no irq" timer */
+	int			active;
+};
+
+static DEFINE_MUTEX(dma_mutex);
+#undef UART_FCR_ENABLE_FIFO
+#define UART_FCR_ENABLE_FIFO (0x9 | (1 << 6)) /* FIFO enable + DMA */
+#define UART_DMABUF_RX_SIZE (UART_XMIT_SIZE << 1)
+
+/*
+ * DMA RX character receive timeout in mS. 10mS is the best your
+ * going to get with a 100Hz tick clock.
+ */
+#define LPC31XX_UART_RX_TIMEOUT 10
+#endif
+
 struct uart_8250_port {
 	struct uart_port	port;
 	struct timer_list	timer;		/* "no irq" timer */
@@ -153,6 +248,12 @@ struct uart_8250_port {
 	 */
 	void			(*pm)(struct uart_port *port,
 				      unsigned int state, unsigned int old);
+
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	struct LPC31XX_DMA dma_rx;
+	struct LPC31XX_DMA dma_tx;
+	int buff_half_offs;
+#endif
 };
 
 struct irq_info {
@@ -279,6 +380,13 @@ static const struct serial8250_config ua
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
 		.flags		= UART_CAP_FIFO,
 	},
+	[PORT_NXP16750] = {
+		.name		= "NXP16750",
+		.fifo_size	= 64,
+		.tx_loadsz	= 64,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
+		.flags		= UART_CAP_FIFO,
+	},
 };
 
 #if defined (CONFIG_SERIAL_8250_AU1X00)
@@ -955,6 +1063,15 @@ static void autoconfig_16550a(struct uar
 		return;
 	}
 
+	/* Check if it is NXP IP 3106 UART */
+	serial_outp(up, UART_SCR, 0xDF);
+	status1 = serial_in(up, UART_SCR);
+	if(status1 == 0xDF) {
+		/*scratch register present */
+		up->port.type = PORT_NXP16750;
+		return;
+	}
+
 	/*
 	 * Try writing and reading the UART_IER_UUE bit (b6).
 	 * If it works, this is probably one of the Xscale platform's
@@ -1231,10 +1348,291 @@ static inline void __stop_tx(struct uart
 	}
 }
 
+static void transmit_chars(struct uart_8250_port *up);
+
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+static void lpc31xx_dma_lock(struct uart_8250_port *up)
+{
+	mutex_lock(&dma_mutex);
+}
+
+static void lpc31xx_dma_unlock(struct uart_8250_port *up)
+{
+	mutex_unlock(&dma_mutex);	
+}
+
+static void lpc31xx_uart_tx_dma_start(struct uart_8250_port *up);
+static void lpc31xx_dma_tx_tasklet_func(unsigned long data)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *) data;
+	struct circ_buf *xmit = &up->port.state->xmit;
+
+	if (dma_channel_enabled(up->dma_tx.dmach))
+		return;
+
+	lpc31xx_dma_lock(up);
+
+	dma_stop_channel(up->dma_tx.dmach);
+
+	xmit->tail = (xmit->tail + up->dma_tx.count) & (UART_XMIT_SIZE - 1);
+	up->port.icount.tx += up->dma_tx.count;
+
+	lpc31xx_uart_tx_dma_start(up);
+
+	lpc31xx_dma_unlock(up);
+}
+
+static int lpc31xx_get_readl_rx_dma_count(struct uart_8250_port *up)
+{
+	int count;
+
+	/* The DMA hardware returns the number of bytes currently
+	   transferred by the hardware. It will return 0 when the
+	   channel has stopped (full DMA transfer) or when nothing
+	   has been transferred. To tell the difference between
+	   empty 0 and full 0, we need to examine the DMA enable
+	   status. */
+
+	/* A race condition can exist where the DMA TCNT returns a
+	   value right as the DMA is stopping. In this case, the
+	   DMA is enabled during the check with a non-0 count
+	   value. To get around this issue, the DMA count value
+	   need to be verified again after disabling the DMA
+	   channel. If it is 0, then the DMA completed and the
+	   count is different. */
+	dma_read_counter(up->dma_rx.dmach, &count);
+	if ((!count) && (!dma_channel_enabled(up->dma_rx.dmach)))
+		count = UART_XMIT_SIZE;
+
+	return count;
+}
+
+static void serial8250_dma_rx_timer_check(unsigned long data)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *) data;
+
+	/* Emulate RX timeout when DMA buffer is not full */
+	if (lpc31xx_get_readl_rx_dma_count(up))
+		tasklet_schedule(&up->dma_rx.tasklet);
+	else
+		mod_timer(&up->dma_rx.timer, jiffies +
+			msecs_to_jiffies(LPC31XX_UART_RX_TIMEOUT));
+}
+
+void lcp31xx_dma_rx_setup(struct uart_8250_port *up)
+{
+	dma_setup_t dmarx;
+
+	up->buff_half_offs = UART_XMIT_SIZE - up->buff_half_offs;
+	dmarx.trans_length = UART_XMIT_SIZE - 1;
+	dmarx.src_address = (u32) up->port.mapbase;
+	dmarx.dest_address = (u32) up->dma_rx.dma_buff_p;
+	dmarx.dest_address += up->buff_half_offs;
+	dmarx.cfg = DMA_CFG_TX_BYTE | DMA_CFG_RD_SLV_NR(DMA_SLV_UART_RX) |
+		DMA_CFG_WR_SLV_NR(0);
+
+	dma_prog_channel(up->dma_rx.dmach, &dmarx);
+	dma_start_channel(up->dma_rx.dmach);
+}
+
+/*
+ * DMA RX tasklet
+ */
+static unsigned int check_modem_status(struct uart_8250_port *up);
+static void lpc31xx_dma_rx_tasklet_func(unsigned long data)
+{
+	unsigned int status, lsr;
+	int count, count2, i, maxcount = 64, breakflush = 0;
+	char ch, flag = TTY_NORMAL, *buf;
+	struct uart_8250_port *up = (struct uart_8250_port *) data;
+	int buffhalf = up->buff_half_offs;
+	u32 pbuf;
+
+	spin_lock(&up->port.lock);
+
+	/*
+	 * Per char stats don't work with DMA, so the status flags
+	 * don't apply to a specific character. We'll take a best
+	 * guess that the accumulated status only applies to the
+	 * last character in the DMA buffer.
+	 */
+	status = serial_inp(up, UART_LSR);
+	lsr = status | up->lsr_saved_flags;
+	up->lsr_saved_flags = 0;
+
+	if (unlikely(lsr & UART_LSR_BRK_ERROR_BITS)) {
+		/*
+		 * For statistics only
+		 */
+		if (lsr & UART_LSR_BI) {
+			lsr &= ~(UART_LSR_FE | UART_LSR_PE);
+			up->port.icount.brk++;
+			breakflush = 1;
+			/*
+			 * Breaks are trouble! Toss everything if
+			 * one occurs.
+			 */
+			uart_handle_break(&up->port);
+		} else if (lsr & UART_LSR_PE)
+			up->port.icount.parity++;
+		else if (lsr & UART_LSR_FE)
+			up->port.icount.frame++;
+		if (lsr & UART_LSR_OE)
+			up->port.icount.overrun++;
+
+		/*
+		 * Mask off conditions which should be ignored.
+		 */
+		lsr &= up->port.read_status_mask;
+
+		if (lsr & UART_LSR_BI) {
+			DEBUG_INTR("handling break....");
+			flag = TTY_BREAK;
+		} else if (lsr & UART_LSR_PE)
+			flag = TTY_PARITY;
+		else if (lsr & UART_LSR_FE)
+			flag = TTY_FRAME;
+	}
+
+	/* Disable DMA and get current DMA bytes transferred */
+	count = lpc31xx_get_readl_rx_dma_count(up);
+	dma_stop_channel(up->dma_rx.dmach);
+	count2 = lpc31xx_get_readl_rx_dma_count(up);
+	if (count != count2) {
+		if (count2 == 0)
+			count = UART_XMIT_SIZE;
+		else
+			count = count2;
+	}
+	dma_write_counter(up->dma_rx.dmach, 0);
+
+	/* Setup DMA again using unused buffer half */
+	lcp31xx_dma_rx_setup(up);
+	pbuf = (u32) up->dma_rx.dma_buff_p;
+	pbuf += buffhalf;
+	buf = (char *) up->dma_rx.dma_buff_v;
+	buf += buffhalf;
+
+	if (breakflush) {
+		/* Flush RX FIFO */
+		while ((serial_inp(up, UART_LSR) & UART_LSR_DR) &&
+			(maxcount-- > 0))
+			ch = serial_inp(up, UART_RX);
+	}
+	else {
+		dma_sync_single_for_device(up->port.dev, (u32) pbuf,
+			   count, DMA_FROM_DEVICE);
+
+		for (i = 0; i < (count - 1); i++) {
+			up->port.icount.rx++;
+			if (uart_handle_sysrq_char(&up->port, buf[i]))
+				continue;
+
+			uart_insert_char(&up->port, lsr, UART_LSR_OE, buf[i], TTY_NORMAL);
+		}
+
+		up->port.icount.rx++;
+		if (!uart_handle_sysrq_char(&up->port, buf[i]))
+			uart_insert_char(&up->port, lsr, UART_LSR_OE, buf[i], flag);
+	}
+
+	check_modem_status(up);
+
+	spin_unlock(&up->port.lock);
+	tty_flip_buffer_push(up->port.state->port.tty);
+	spin_lock(&up->port.lock);
+
+	mod_timer(&up->dma_rx.timer, jiffies +
+		msecs_to_jiffies(LPC31XX_UART_RX_TIMEOUT));
+
+	/* Clear any pending RX error status and re-enable TX status interrupt */
+	status = serial_inp(up, UART_LSR);
+	serial_outp(up, UART_IER, up->ier);
+
+	spin_unlock(&up->port.lock);
+}
+
+/*
+ * DMA UART TX completion interrupt - this interrupt is more of a spotholder
+ * as it is disabled and will never fire.
+ */
+static void lpc31xx_dma_tx_interrupt(int ch, dma_irq_type_t dtype, void *handle)
+{
+	struct uart_8250_port *up = handle;
+
+	printk(KERN_INFO "serial DMA TX interrupt unexpected\n");
+	tasklet_schedule(&up->dma_tx.tasklet);
+}
+
+/*
+ * DMA UART RX completion interrupt - fires when the DMA RX transfer
+ * is complete.
+ */
+static void lpc31xx_dma_rx_interrupt(int ch, dma_irq_type_t dtype, void *handle)
+{
+	struct uart_8250_port *up = handle;
+
+	tasklet_schedule(&up->dma_rx.tasklet);
+}
+
+static void lpc31xx_uart_tx_dma_start(struct uart_8250_port *up)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	dma_setup_t dmatx;
+
+	/* Start a DMA transfer, DMA is idle if this is called and
+	   TX is enabled. */
+	if (up->port.x_char) {
+		serial_outp(up, UART_TX, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+
+	if (!uart_circ_empty(xmit) && !uart_tx_stopped(&up->port)) {
+		dma_sync_single_for_device(up->port.dev,
+					   up->dma_tx.dma_buff_p,
+					   UART_XMIT_SIZE,
+					   DMA_TO_DEVICE);
+
+		up->dma_tx.count = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
+		if (up->dma_tx.count > 64)
+			up->dma_tx.count = 64;
+
+		/* Note TX buffer is loaned to the DMA so the TX bytes can't
+		   be released until the DMA transfer is complete. */
+		dmatx.trans_length = up->dma_tx.count - 1;
+		dmatx.src_address = (u32) up->dma_tx.dma_buff_p;
+		dmatx.src_address += xmit->tail;
+		dmatx.dest_address = (u32) up->port.mapbase;
+		dmatx.cfg = DMA_CFG_TX_BYTE | DMA_CFG_RD_SLV_NR(0) |
+			DMA_CFG_WR_SLV_NR(DMA_SLV_UART_TX);
+
+		dma_prog_channel(up->dma_tx.dmach, &dmatx);
+		up->dma_tx.active = 1;
+		dma_start_channel(up->dma_tx.dmach);
+
+		/* Enable TX interrupt on TX FIFO empty */
+		up->ier |= UART_IER_THRI;
+	}
+	else {
+		up->dma_tx.active = 0;
+		up->ier &= ~UART_IER_THRI;
+	}
+
+	serial_out(up, UART_IER, up->ier);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+}
+#endif
+
 static void serial8250_stop_tx(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
-
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	dma_stop_channel(up->dma_tx.dmach);
+#endif
 	__stop_tx(up);
 
 	/*
@@ -1246,12 +1644,21 @@ static void serial8250_stop_tx(struct ua
 	}
 }
 
-static void transmit_chars(struct uart_8250_port *up);
-
 static void serial8250_start_tx(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	lpc31xx_dma_lock(up);
 
+	/*
+	 * If a DMA TX transfer is currently in progress, then just
+	 * exit and let the TX DMA handler transfer it.
+	 */
+	if (!up->dma_tx.active)
+		lpc31xx_uart_tx_dma_start(up);
+
+	lpc31xx_dma_unlock(up);
+#else
 	if (!(up->ier & UART_IER_THRI)) {
 		up->ier |= UART_IER_THRI;
 		serial_out(up, UART_IER, up->ier);
@@ -1276,15 +1683,21 @@ static void serial8250_start_tx(struct u
 		up->acr &= ~UART_ACR_TXDIS;
 		serial_icr_write(up, UART_ACR, up->acr);
 	}
+#endif
 }
 
 static void serial8250_stop_rx(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	dma_stop_channel(up->dma_rx.dmach);
+
+#else
 	up->ier &= ~UART_IER_RLSI;
 	up->port.read_status_mask &= ~UART_LSR_DR;
 	serial_out(up, UART_IER, up->ier);
+#endif
 }
 
 static void serial8250_enable_ms(struct uart_port *port)
@@ -1475,6 +1888,40 @@ static void serial8250_handle_port(struc
  */
 static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 {
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	struct irq_info *i = dev_id;
+	struct uart_8250_port *up;
+	unsigned int iir, status;
+
+	/*
+	 * When using DMA, this interrupt only occurs on a RX status
+	 * condition (break, frame error, parity error). Unfortunately,
+	 * there is no way to clear the condition without popping the
+	 * FIFO, so the DMA handle needs to be notified that it needs
+	 * to wakeup and process the incoming data. Meanwhile, the
+	 * RX status interrupt is temporarily disabled so the interrupt
+	 * won't keep firing.
+	 */
+
+	up = list_entry(i->head, struct uart_8250_port, list);
+
+	iir = serial_in(up, UART_IIR) & 0xf;
+	if (!(iir & UART_IIR_NO_INT)) {
+		status = serial_inp(up, UART_LSR);
+		if (status & UART_LSR_THRE) {
+			up->ier &= ~UART_IER_THRI;
+			serial_out(up, UART_IER, up->ier);
+			tasklet_schedule(&up->dma_tx.tasklet);
+		} else {
+			up->ier &= ~UART_IER_RLSI;
+			serial_out(up, UART_IER, up->ier);
+			tasklet_schedule(&up->dma_rx.tasklet);
+		}
+	}
+
+	return IRQ_HANDLED;
+
+#else
 	struct irq_info *i = dev_id;
 	struct list_head *l, *end = NULL;
 	int pass_counter = 0, handled = 0;
@@ -1528,6 +1975,7 @@ static irqreturn_t serial8250_interrupt(
 	DEBUG_INTR("end.\n");
 
 	return IRQ_RETVAL(handled);
+#endif
 }
 
 /*
@@ -1563,6 +2011,10 @@ static int serial_link_irq_chain(struct 
 	struct hlist_node *n;
 	struct irq_info *i;
 	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	dma_addr_t dma_handle;
+	struct circ_buf *xmit = &up->port.state->xmit;
+#endif
 
 	mutex_lock(&hash_mutex);
 
@@ -1598,6 +2050,60 @@ static int serial_link_irq_chain(struct 
 		i->head = &up->list;
 		spin_unlock_irq(&i->lock);
 
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+		/* NOTE: The 31XX has only 1 UART channel, so the list head will
+		   always point to that channel. This logic isn't quite right,
+		   but its ok for a single UART */
+
+		/* Setup DMA channels */
+		up->dma_tx.dmach = dma_request_channel("uart_tx",
+			lpc31xx_dma_tx_interrupt, up);
+		if (up->dma_tx.dmach < 0)
+		{
+			printk(KERN_ERR "serial: error getting TX DMA channel.\n");
+			return -EBUSY;
+		}
+		up->dma_rx.dmach = dma_request_channel("uart_rx",
+			lpc31xx_dma_rx_interrupt, up);
+		if (up->dma_rx.dmach < 0)
+		{
+			printk(KERN_ERR "serial: error getting RX DMA channel.\n");
+			return -EBUSY;
+		}
+
+		/* dma_map_single() can be used for the TX buffer, but the RX
+		  buffer needs it's own buffer */
+		up->dma_rx.dma_buff_v = dma_alloc_coherent(NULL, UART_DMABUF_RX_SIZE,
+			&dma_handle, GFP_DMA);
+		if (up->dma_rx.dma_buff_v == NULL)
+		{
+			printk(KERN_ERR "serial: error getting DMA region.\n");
+			return -ENOMEM;
+		}
+		up->dma_rx.dma_buff_p = dma_handle;
+		printk(KERN_INFO "serial: UART RX buffer: P0x%08x, V0x%08x, size:%ld.\n",
+			(u32) up->dma_rx.dma_buff_p, (u32) up->dma_rx.dma_buff_v,
+			UART_DMABUF_RX_SIZE);
+
+		tasklet_init(&up->dma_tx.tasklet, lpc31xx_dma_tx_tasklet_func,
+				(unsigned long) up);
+		tasklet_init(&up->dma_rx.tasklet, lpc31xx_dma_rx_tasklet_func,
+				(unsigned long) up);
+
+		mutex_init(&dma_mutex);
+
+		/* Map DMA buffer to UART circular buffer */
+		up->dma_tx.dma_buff_p = dma_map_single(up->port.dev,
+					       (void*)xmit->buf,
+					       UART_XMIT_SIZE,
+					       DMA_TO_DEVICE);
+
+		printk(KERN_INFO "serual: UART TX buffer: P0x%08x, V0x%08x, size:%ld.\n",
+			(u32) up->dma_tx.dma_buff_p, (u32) xmit->buf, UART_XMIT_SIZE);
+
+		dma_set_irq_mask(up->dma_tx.dmach, 1, 1);
+		dma_set_irq_mask(up->dma_rx.dmach, 1, 0);
+#endif
 		ret = request_irq(up->port.irq, serial8250_interrupt,
 				  irq_flags, "serial", i);
 		if (ret < 0)
@@ -1609,7 +2115,7 @@ static int serial_link_irq_chain(struct 
 
 static void serial_unlink_irq_chain(struct uart_8250_port *up)
 {
-	struct irq_info *i;
+	struct irq_info *i = NULL;
 	struct hlist_node *n;
 	struct hlist_head *h;
 
@@ -1623,6 +2129,27 @@ static void serial_unlink_irq_chain(stru
 			break;
 	}
 
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	/* NOTE: The 31XX has only 1 UART channel, so the list head will
+	   always point to that channel. This logic isn't quite right,
+	   but its ok for a single UART */
+
+	/* Disable DMA channels */
+	dma_set_irq_mask(up->dma_tx.dmach, 0, 0);
+	dma_set_irq_mask(up->dma_rx.dmach, 0, 0);
+	dma_stop_channel(up->dma_tx.dmach);
+	dma_stop_channel(up->dma_rx.dmach);
+	dma_release_channel(up->dma_tx.dmach);
+	dma_release_channel(up->dma_rx.dmach);
+
+	dma_unmap_single(up->port.dev, up->dma_tx.dma_buff_p, UART_XMIT_SIZE,
+		DMA_TO_DEVICE);
+
+	dma_free_coherent(up->port.dev, UART_XMIT_SIZE,
+		(void *) up->dma_rx.dma_buff_v,
+		up->dma_rx.dma_buff_p);
+#endif
+
 	BUG_ON(n == NULL);
 	BUG_ON(i->head == NULL);
 
@@ -1655,7 +2182,7 @@ static void serial8250_timeout(unsigned 
 		serial8250_handle_port(up);
 	mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
 }
-
+#ifndef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
 static void serial8250_backup_timeout(unsigned long data)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)data;
@@ -1700,6 +2227,7 @@ static void serial8250_backup_timeout(un
 	mod_timer(&up->timer,
 		jiffies + poll_timeout(up->port.timeout) + HZ / 5);
 }
+#endif
 
 static unsigned int serial8250_tx_empty(struct uart_port *port)
 {
@@ -1975,6 +2503,7 @@ static int serial8250_startup(struct uar
 	 * The above check will only give an accurate result the first time
 	 * the port is opened so this value needs to be preserved.
 	 */
+#ifndef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
 	if (up->bugs & UART_BUG_THRE) {
 		up->timer.function = serial8250_backup_timeout;
 		up->timer.data = (unsigned long)up;
@@ -1982,6 +2511,13 @@ static int serial8250_startup(struct uar
 			  poll_timeout(up->port.timeout) + HZ / 5);
 	}
 
+#else
+	init_timer(&up->dma_rx.timer);
+	up->dma_rx.timer.function = serial8250_dma_rx_timer_check;
+	up->dma_rx.timer.data = (unsigned long)up;
+	mod_timer(&up->dma_rx.timer, jiffies + 5);
+#endif
+
 	/*
 	 * If the "interrupt" for this port doesn't correspond with any
 	 * hardware interrupt, we use a timer-based system.  The original
@@ -2052,7 +2588,12 @@ static int serial8250_startup(struct uar
 	 * are set via set_termios(), which will be occurring imminently
 	 * anyway, so we don't enable them here.
 	 */
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	up->ier = UART_IER_RLSI;
+
+#else
 	up->ier = UART_IER_RLSI | UART_IER_RDI;
+#endif
 	serial_outp(up, UART_IER, up->ier);
 
 	if (up->port.flags & UPF_FOURPORT) {
@@ -2144,6 +2685,12 @@ serial8250_set_termios(struct uart_port 
 	unsigned long flags;
 	unsigned int baud, quot;
 
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	dma_stop_channel(up->dma_rx.dmach);
+	dma_stop_channel(up->dma_tx.dmach);
+	up->dma_tx.active = 0;
+#endif
+
 	switch (termios->c_cflag & CSIZE) {
 	case CS5:
 		cval = UART_LCR_WLEN5;
@@ -2306,6 +2853,12 @@ serial8250_set_termios(struct uart_port 
 		serial_outp(up, UART_FCR, fcr);		/* set fcr */
 	}
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
+
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	dma_write_counter(up->dma_rx.dmach, 0);
+	lcp31xx_dma_rx_setup(up);
+#endif
+
 	spin_unlock_irqrestore(&up->port.lock, flags);
 	/* Don't rewrite B0 */
 	if (tty_termios_baud_rate(termios))
@@ -2320,6 +2873,15 @@ serial8250_pm(struct uart_port *port, un
 
 	serial8250_set_sleep(p, state != 0);
 
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	if (state == 0) {
+		dma_write_counter(p->dma_rx.dmach, 0);
+		lcp31xx_dma_rx_setup(p);
+	} else
+		dma_stop_channel(p->dma_rx.dmach);
+	 
+#endif
+
 	if (p->pm)
 		p->pm(port, state, oldstate);
 }
@@ -2831,7 +3393,9 @@ static int __devinit serial8250_probe(st
 				"(IO%lx MEM%llx IRQ%d): %d\n", i,
 				p->iobase, (unsigned long long)p->mapbase,
 				p->irq, ret);
-		}
+		} else 
+			serial8250_ports[ret].pm = p->pm;
+
 	}
 	return 0;
 }
@@ -3006,7 +3570,8 @@ void serial8250_unregister_port(int line
 		uart_add_one_port(&serial8250_reg, &uart->port);
 	} else {
 		uart->port.dev = NULL;
-	}
+	}	/* Setup DMA channels */
+
 	mutex_unlock(&serial_mutex);
 }
 EXPORT_SYMBOL(serial8250_unregister_port);
diff -purN linux-2.6.28.2/drivers/serial/Kconfig work_2.6.28.2/drivers/serial/Kconfig
--- linux-2.6.28.2/drivers/serial/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/serial/Kconfig	2010-03-15 16:58:23.000000000 -0700
@@ -70,6 +70,12 @@ config SERIAL_8250_CONSOLE
 
 	  If unsure, say N.
 
+config LPC31XX_SERIAL_DMA_SUPPORT
+	bool "DMA support for the LPC31XX RX/TX functions"
+	depends on SERIAL_8250=y
+	help
+	 Enables DMA support for the UART function
+
 config FIX_EARLYCON_MEM
 	bool
 	depends on X86
diff -purN linux-2.6.28.2/drivers/spi/Kconfig work_2.6.28.2/drivers/spi/Kconfig
--- linux-2.6.28.2/drivers/spi/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/spi/Kconfig	2010-03-15 16:57:43.000000000 -0700
@@ -204,6 +204,12 @@ config SPI_XILINX
 	  See the "OPB Serial Peripheral Interface (SPI) (v1.00e)"
 	  Product Specification document (DS464) for hardware details.
 
+config SPI_LPC313X
+	tristate "LPC313X SPI controller"
+	depends on SPI_MASTER && ARCH_LPC313X
+	help
+	  SPI controller for the LPC313X device with DMA support
+
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
diff -purN linux-2.6.28.2/drivers/spi/Makefile work_2.6.28.2/drivers/spi/Makefile
--- linux-2.6.28.2/drivers/spi/Makefile	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/spi/Makefile	2010-03-15 16:57:43.000000000 -0700
@@ -29,6 +29,7 @@ obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24x
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+obj-$(CONFIG_SPI_LPC313X)		+= spi_lpc313x.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
diff -purN linux-2.6.28.2/drivers/spi/spi_lpc313x.c work_2.6.28.2/drivers/spi/spi_lpc313x.c
--- linux-2.6.28.2/drivers/spi/spi_lpc313x.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/drivers/spi/spi_lpc313x.c	2010-03-15 16:58:23.000000000 -0700
@@ -0,0 +1,968 @@
+/*
+ * drivers/spi/spi_lpc313x.c
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * LPC313X SPI notes
+ *
+ * The LPC313X SPI Linux driver supports many chip selects using GPO based CS
+ * (hardware chip selects are not supported due to timing constraints), clock
+ * speeds up to 45MBps, data widths from 4 to 16 bits, DMA support, and full
+ * power management.
+ */
+
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+
+#include <mach/registers.h>
+#include <mach/dma.h>
+#include <mach/board.h>
+
+/* Register access macros */
+#define spi_readl(reg) __raw_readl(&SPI_##reg)
+#define spi_writel(reg,value) __raw_writel((value),&SPI_##reg)
+
+struct lpc313xspi
+{
+	spinlock_t lock;
+	struct platform_device *pdev;
+	struct workqueue_struct	*workqueue;
+	struct work_struct work;
+	struct list_head queue;
+	wait_queue_head_t waitq;
+	struct spi_master *master;
+	int irq;
+	int id;
+	u32 spi_base_clock;
+	struct lpc313x_spi_cfg *psppcfg;
+	u32 current_speed_hz [3]; /* Per CS */
+	u8 current_bits_wd [3]; /* Per CS */
+
+	/* DMA allocated regions */
+	u32 dma_base_v;
+	dma_addr_t dma_base_p;
+
+	/* DMA TX and RX physical and mapped spaces */
+	u32 dma_tx_base_v, dma_rx_base_v, dma_tx_base_p, dma_rx_base_p;
+
+	/* Allocated DMA channels */
+	int tx_dma_ch, rx_dma_ch;
+
+	/* DMA event flah */
+	volatile int rxdmaevent;
+};
+
+/*
+ * Enable or disable the SPI clocks
+ */
+static void lpc313x_spi_clks_disen(struct lpc313xspi *spidat, int enable)
+{
+	int en = (enable != 0);
+
+	cgu_clk_en_dis(CGU_SB_SPI_PCLK_ID, en);
+	cgu_clk_en_dis(CGU_SB_SPI_PCLK_GATED_ID, en);
+	cgu_clk_en_dis(CGU_SB_SPI_CLK_ID, en);
+	cgu_clk_en_dis(CGU_SB_SPI_CLK_GATED_ID, en);
+}
+
+/*
+ * Flush the TX and RX FIFOs
+ */
+static void lpc313x_fifo_flush(struct lpc313xspi *spidat)
+{
+	volatile u32 tmp;
+
+	/* Clear TX FIFO first */
+	spi_writel(TXF_FLUSH_REG, SPI_TXFF_FLUSH);
+
+	/* Clear RX FIFO */
+	while (!(spi_readl(STS_REG) & SPI_ST_RX_EMPTY))
+	{
+		tmp = spi_readl(FIFO_DATA_REG);
+	}
+}
+
+/*
+ * Clear a latched SPI interrupt
+ */
+static inline void lpc313x_int_clr(struct lpc313xspi *spidat, u32 ints)
+{
+	spi_writel(INT_CLRS_REG, ints);
+}
+
+/*
+ * Disable a SPI interrupt
+ */
+static inline void lpc313x_int_dis(struct lpc313xspi *spidat, u32 ints)
+{
+	spi_writel(INT_CLRE_REG, ints);
+}
+
+/*
+ * Enable a SPI interrupt
+ */
+static inline void lpc313x_int_en(struct lpc313xspi *spidat, u32 ints)
+{
+	spi_writel(INT_SETE_REG, ints);
+}
+
+/*
+ * Set a SPI chip select state
+ */
+static inline void spi_force_cs(struct lpc313xspi *spidat, u8 cs, uint cs_state)
+{
+	spidat->psppcfg->spics_cfg[cs].spi_cs_set((int) cs, (int) cs_state);
+}
+
+/*
+ * Set data width for the SPI chip select
+ */
+static void lpc313x_set_cs_data_bits(struct lpc313xspi *spidat, u8 cs, u8 data_width)
+{
+	if (spidat->current_bits_wd[cs] != data_width)
+	{
+		u32 tmp = spi_readl(SLV_SET2_REG(0));
+		tmp &= ~SPI_SLV2_WD_SZ(0x1F);
+		tmp |= SPI_SLV2_WD_SZ((u32) (data_width - 1));
+		spi_writel(SLV_SET2_REG(0), tmp);
+
+		spidat->current_bits_wd[cs] = data_width;
+	}
+}
+
+/*
+ * Set clock rate and delays for the SPI chip select
+ */
+static void lpc313x_set_cs_clock(struct lpc313xspi *spidat, u8 cs, u32 clockrate)
+{
+	u32 reg, div, ps, div1;
+
+	if (clockrate != spidat->current_speed_hz[cs])
+	{
+		reg = spi_readl(SLV_SET1_REG(0));
+		reg &= ~0xFFFF;
+
+		div = (spidat->spi_base_clock + clockrate / 2) / clockrate;
+		if (div > SPI_MAX_DIVIDER)
+			div = SPI_MAX_DIVIDER;
+		if (div < SPI_MIN_DIVIDER)
+			div = SPI_MIN_DIVIDER;
+
+		ps = (((div - 1) / 512) + 1) * 2;
+		div1 = (((div + ps / 2) / ps) - 1);
+
+		spi_writel(SLV_SET1_REG(0),
+			(reg | SPI_SLV1_CLK_PS(ps) | SPI_SLV1_CLK_DIV1(div1)));
+
+		spidat->current_speed_hz[cs] = clockrate;
+	}
+}
+
+/*
+ * Setup the initial state of the SPI interface
+ */
+static void lpc313x_spi_prep(struct lpc313xspi *spidat)
+{
+	u32 tmp;
+
+	/* Reset SPI block */
+	spi_writel(CONFIG_REG, SPI_CFG_SW_RESET);
+
+	/* Clear FIFOs */
+	lpc313x_fifo_flush(spidat);
+
+	/* Clear latched interrupts */
+	lpc313x_int_dis(spidat, SPI_ALL_INTS);
+	lpc313x_int_clr(spidat, SPI_ALL_INTS);
+
+	/* Setup master mode, normal transmit mode, and interslave delay */
+	spi_writel(CONFIG_REG, SPI_CFG_INTER_DLY(1));
+
+	/* Make sure all 3 chip selects are initially disabled */
+	spi_writel(SLV_ENAB_REG, 0);
+	spi_writel(CONFIG_REG, (spi_readl(CONFIG_REG) | SPI_CFG_UPDATE_EN));
+
+	/* FIFO trip points at 50% */
+	spi_writel(INT_TRSH_REG, (SPI_INT_TSHLD_TX(0x20) | SPI_INT_TSHLD_RX(0x20)));
+
+	/* Only chip select 0 is used in this driver. However, the timings for this
+	   chip select effect transfer speed and need to be adjusted for each GPO
+	   based chip select. Use a default value to start with for now. */
+	/* Inter-transfer delay is 0 (not used) */
+	tmp = spi_readl(SLV_SET1_REG(0));
+	tmp &= ~SPI_SLV1_INTER_TX_DLY(0xFF);
+	spi_writel(SLV_SET1_REG(0), (tmp | SPI_SLV1_INTER_TX_DLY(0)));
+
+	/* Configure enabled chip select slave setting 2 */
+	tmp = SPI_SLV2_PPCS_DLY(0) | SPI_SLV2_CS_HIGH | SPI_SLV2_SPO;
+	spi_writel(SLV_SET2_REG(0), tmp);
+
+	/* Use a default of 8 data bits and a 100K clock for now */
+	lpc313x_set_cs_data_bits(spidat, 0, 8);
+	lpc313x_set_cs_clock(spidat, 0, 100000);
+
+	/* We'll always use CS0 for this driver. Since the chip select is generated
+	   by a GPO, it doesn't matter which one we use */
+	spi_writel(SLV_ENAB_REG, SPI_SLV_EN(0));
+	spi_writel(CONFIG_REG, (spi_readl(CONFIG_REG) | SPI_CFG_UPDATE_EN));
+
+	/* Controller stays disabled until a transfer occurs */
+}
+
+/*
+ * Setup a SPI transfer
+ */
+static int lpc313x_spi_setup(struct spi_device *spi)
+{
+	unsigned int bits = spi->bits_per_word;
+
+	/* There really isn't anuthing to do in this function, so verify the
+	   parameters are correct for the transfer */
+	if (spi->chip_select > spi->master->num_chipselect)
+	{
+		dev_dbg(&spi->dev,
+			"setup: invalid chipselect %u (%u defined)\n",
+			spi->chip_select, spi->master->num_chipselect);
+		return -EINVAL;
+	}
+
+	if (bits == 0)
+	{
+		bits = 8;
+	}
+	if ((bits < 4) || (bits > 16))
+	{
+		dev_dbg(&spi->dev,
+			"setup: invalid bits_per_word %u (8 to 16)\n", bits);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Handle the SPI interrupt
+ */
+static irqreturn_t lpc313x_spi_irq(int irq, void *dev_id)
+{
+	struct lpc313xspi *spidat = dev_id;
+
+	/* Disable interrupts for now, do not clear the interrupt states */
+	lpc313x_int_dis(spidat, SPI_ALL_INTS);
+	spidat->rxdmaevent = 1;
+
+	wake_up(&spidat->waitq);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * SPI DMA TX callback
+ */
+static void lpc313x_dma_tx_spi_irq(int ch, dma_irq_type_t dtype, void *handle)
+{
+	/* Nothing really needs to be done with the DMA TX interrupt, all the work
+	   is done with RX, so just return and let the DMA handler clear it. The
+	   SPI will stall the clock if the TX FIFO becomes empty so there is no
+	   chance of some type of underflow. */
+}
+
+/*
+ * SPI DMA RX callback
+ */
+static void lpc313x_dma_rx_spi_irq(int ch, dma_irq_type_t dtype, void *handle)
+{
+	struct lpc313xspi *spidat = (struct lpc313xspi *) handle;
+
+	if (dtype == DMA_IRQ_FINISHED)
+	{
+		/* Disable interrupts for now */
+		dma_set_irq_mask(spidat->rx_dma_ch, 1, 1);
+
+		/* Flag event and wakeup */
+		spidat->rxdmaevent = 1;
+		wake_up(&spidat->waitq);
+	}
+	else if (dtype == DMA_IRQS_ABORT)
+	{
+		/* DMA data abort - this is global for the entire DMA
+		   peripheral. Do nothing, as this might not be a
+		   error for this channel. */
+	}
+}
+
+/*
+ * Handle a DMA transfer
+ */
+static int lpc313x_spi_dma_transfer(struct lpc313xspi *spidat, struct spi_transfer *t,
+					u8 bits_per_word, int dmamapped)
+{
+	dma_setup_t dmarx, dmatx;
+	int status = 0;
+	u32 src, dest, srcmapped = 0, destmapped = 0;
+	struct device *dev = &spidat->pdev->dev;
+
+	/* Set the FIFO trip level to the transfer size */
+	spi_writel(INT_TRSH_REG, (SPI_INT_TSHLD_TX(16) |
+		SPI_INT_TSHLD_RX(1)));
+	spi_writel(DMA_SET_REG, (SPI_DMA_TX_EN | SPI_DMA_RX_EN));
+	lpc313x_int_dis(spidat, SPI_ALL_INTS);
+	lpc313x_int_en(spidat, SPI_OVR_INT);
+
+	/* Setup transfer */
+	if (bits_per_word > 8)
+	{
+		dmarx.cfg = DMA_CFG_TX_HWORD | DMA_CFG_RD_SLV_NR(DMA_SLV_SPI_RX) |
+			DMA_CFG_WR_SLV_NR(0);
+		dmatx.cfg = DMA_CFG_TX_HWORD | DMA_CFG_RD_SLV_NR(0) |
+			DMA_CFG_WR_SLV_NR(DMA_SLV_SPI_TX);
+	}
+	else
+	{
+		dmarx.cfg = DMA_CFG_TX_BYTE | DMA_CFG_RD_SLV_NR(DMA_SLV_SPI_RX) |
+			DMA_CFG_WR_SLV_NR(0);
+		dmatx.cfg = DMA_CFG_TX_BYTE | DMA_CFG_RD_SLV_NR(0) |
+			DMA_CFG_WR_SLV_NR(DMA_SLV_SPI_TX);
+	}
+
+	/* Determine the DMA source and destination addresses. If DMA buffers weren't
+	   passed to this handler, they need to be mapped */
+	if (dmamapped)
+	{
+		src = t->tx_dma;
+		dest = t->rx_dma;
+		if ((src == 0) && (dest == 0))
+		{
+			/* DMA mapped flag set, but not mapped */
+			status = -ENOMEM;
+			goto exit;
+		}
+
+		/* At least one of the DMA buffers are already mapped */
+		if (src == 0)
+		{
+			/* Use temporary buffer for TX */
+			src = spidat->dma_tx_base_p;
+		}
+		else
+		{
+			dest = spidat->dma_rx_base_p;
+		}
+	}
+	else
+	{
+		/* Does TX buffer need to be DMA mapped */
+		if (t->tx_buf == NULL)
+		{
+			/* Use the temporary buffer for this transfer */
+			src = spidat->dma_tx_base_p;
+		}
+		else
+		{
+			/* Map DMA buffer */
+			src = (u32) dma_map_single(dev, (void *) t->tx_buf,
+				t->len, DMA_TO_DEVICE);
+			if (dma_mapping_error(dev, src))
+			{
+				status = -ENOMEM;
+				goto exit;
+			}
+
+			srcmapped = src;
+		}
+
+		/* Does RX buffer need to be DMA mapped */
+		if (t->rx_buf == NULL)
+		{
+			/* Use the temporary buffer for this transfer */
+			dest = spidat->dma_rx_base_p;
+		}
+		else
+		{
+			/* Map DMA buffer */
+			dest = (u32) dma_map_single(dev, (void *) t->rx_buf,
+				t->len, DMA_FROM_DEVICE);
+			if (dma_mapping_error(dev, dest))
+			{
+				status = -ENOMEM;
+				goto exit;
+			}
+
+			destmapped = dest;
+		}
+	}
+
+	/* Setup transfer data for DMA */
+	dmarx.trans_length = (t->len - 1);
+	dmarx.src_address = (SPI_PHYS + 0x0C);
+	dmarx.dest_address = dest;
+	dmatx.trans_length = (t->len - 1);
+	dmatx.src_address = src;
+	dmatx.dest_address = (SPI_PHYS + 0x0C);
+
+	/* Setup the channels */
+	dma_prog_channel(spidat->rx_dma_ch, &dmarx);
+	dma_prog_channel(spidat->tx_dma_ch, &dmatx);
+
+	/* Make sure the completion interrupt is enabled for RX, TX disabled */
+	dma_set_irq_mask(spidat->rx_dma_ch, 1, 0);
+	dma_set_irq_mask(spidat->tx_dma_ch, 1, 1);
+
+	/* Start the transfer */
+	spidat->rxdmaevent = 0;
+	dma_start_channel(spidat->rx_dma_ch);
+	dma_start_channel(spidat->tx_dma_ch);
+
+	/* Wait for DMA to complete */
+	wait_event_interruptible(spidat->waitq, spidat->rxdmaevent);
+
+exit:
+	dma_stop_channel(spidat->tx_dma_ch);
+	dma_stop_channel(spidat->rx_dma_ch);
+
+	/* Unmap buffers */
+	if (srcmapped != 0)
+	{
+		dma_unmap_single(dev, srcmapped, t->len, DMA_TO_DEVICE);
+	}
+	if (destmapped != 0)
+	{
+		dma_unmap_single(dev, destmapped, t->len, DMA_FROM_DEVICE);
+	}
+
+	return status;
+}
+
+/*
+ * The bulk of the transfer work is done in this function. Based on the transfer
+ * size, either FIFO (PIO) or DMA mode may be used.
+ */
+static void lpc313x_work_one(struct lpc313xspi *spidat, struct spi_message *m)
+{
+	struct spi_device *spi = m->spi;
+	struct spi_transfer *t;
+	unsigned int wsize, cs_change = 1;
+	int status = 0;
+	unsigned long flags;
+	u32 tmp;
+
+	/* Enable SPI clock and interrupts */
+	spin_lock_irqsave(&spidat->lock, flags);
+	lpc313x_spi_clks_disen(spidat, 1);
+	enable_irq(spidat->irq);
+
+	/* Make sure FIFO is flushed and clear any pending interrupts */
+	lpc313x_fifo_flush(spidat);
+	/* lpc313x_int_clr(spidat, SPI_ALL_INTS); ***fix from JPP*** */
+
+	/* Process each transfer in the message */
+	list_for_each_entry (t, &m->transfers, transfer_list) {
+		const void *txbuf = t->tx_buf;
+		void *rxbuf = t->rx_buf;
+		u32 data;
+		unsigned int rlen, tlen = t->len;
+		u32 speed_hz = t->speed_hz ? : spi->max_speed_hz;
+		u8 bits_per_word = t->bits_per_word ? : spi->bits_per_word;
+
+		/* Bits per word, data transfer size, and transfer counter */
+		bits_per_word = bits_per_word ? : 8;
+		wsize = bits_per_word >> 3;
+		rlen = tlen;
+
+		/* Setup the appropriate chip select */
+		lpc313x_set_cs_clock(spidat, spi->chip_select, speed_hz);
+		lpc313x_set_cs_data_bits(spidat, spi->chip_select, bits_per_word);
+ 
+		/* Setup timing and levels before initial chip select */
+		tmp = spi_readl(SLV_SET2_REG(0)) & ~(SPI_SLV2_SPO | SPI_SLV2_SPH);
+		if (spidat->psppcfg->spics_cfg[spi->chip_select].spi_spo != 0)
+		{
+			/* Clock high between transfers */
+			tmp |= SPI_SLV2_SPO;
+		}
+		if (spidat->psppcfg->spics_cfg[spi->chip_select].spi_sph != 0)
+		{
+			/* Data captured on 2nd clock edge */
+			tmp |= SPI_SLV2_SPH;
+		}
+		spi_writel(SLV_SET2_REG(0), tmp);
+
+		lpc313x_int_clr(spidat, SPI_ALL_INTS);  /****fix from JPP*** */
+
+		/* Make sure FIFO is flushed, clear pending interrupts, DMA
+		   initially disabled, and then enable SPI interface */
+		spi_writel(CONFIG_REG, (spi_readl(CONFIG_REG) | SPI_CFG_ENABLE));
+
+		/* Assert selected chip select */
+		if (cs_change)
+		{
+			/* Force CS assertion */
+			spi_force_cs(spidat, spi->chip_select, 0);
+		}
+		cs_change = t->cs_change;
+
+		/* The driver will pick the best transfer method based on the
+		   current transfer size. For sizes smaller than the FIFO depth,
+		   the FIFOs are used without DMA support. For transfers larger
+		   than the FIFO depth, DMA is used. When dealing with fast SPI
+		   clock rates and transfers larger than the FIFO depth, DMA is
+		   required. The higher level SPI functions will limit transfer
+		   sizes to 4Kbytes. */
+		/***Fix from JPP ******/
+		/*if (tlen < (SPI_FIFO_DEPTH * wsize)) {*/
+		if (0) { //***MOD: Non-DMA SPI code broken -> possibly off-by-one bit error.
+			if ((txbuf == NULL) && (rxbuf == NULL))
+			{
+				/* A PIO mode DMA transfer requires mapped
+				   memory. Something is wrong. DMA transfer? */
+				dev_err(&spidat->pdev->dev, "No mapped buffers\n");
+				status = -EIO;
+				goto exit;
+			}
+
+			/* Set the FIFO trip level to the transfer size */
+			spi_writel(INT_TRSH_REG, (SPI_INT_TSHLD_TX(0) |
+				SPI_INT_TSHLD_RX(tlen - 1)));
+			spi_writel(DMA_SET_REG, 0);
+
+			/* Fill TX FIFO */
+			while ((!(spi_readl(STS_REG) & SPI_ST_TX_FF)) && (tlen > 0))
+			{
+				/* Fill FIFO */
+				if (txbuf)
+			{
+					data = (wsize == 1)
+						? *(const u8 *) txbuf
+						: *(const u16 *) txbuf;
+					spi_writel(FIFO_DATA_REG, data);
+					txbuf += wsize;
+				}
+				else
+				{
+					/* Send dummy data */
+					spi_writel(FIFO_DATA_REG, 0xFFFF);
+				}
+
+				tlen--;
+			}
+
+			/* Wait for data */
+			lpc313x_int_en(spidat, (SPI_RX_INT | SPI_TO_INT | SPI_OVR_INT));
+			spin_unlock_irqrestore(&spidat->lock, flags);
+			wait_event_interruptible(spidat->waitq,
+				(spi_readl(INT_STS_REG) & (SPI_RX_INT | SPI_OVR_INT)));
+			spin_lock_irqsave(&spidat->lock, flags);
+
+			/* Has an overflow occurred? */
+			if (unlikely(spi_readl(INT_STS_REG) & SPI_OVR_INT))
+			{
+				/* RX FIFO overflow */
+				dev_err(&spidat->pdev->dev, "RX FIFO overflow.\n");
+				status = -EIO;
+				goto exit;
+			}
+
+			/* Is there any data to read? */
+			while (!(spi_readl(STS_REG) & SPI_ST_RX_EMPTY))
+			{
+				data = spi_readl(FIFO_DATA_REG);
+				/* The data can be tossed if there is no RX buffer */
+				if (rxbuf)
+				{
+					if (wsize == 1)
+					{
+						*(u8 *)rxbuf = (u8) data;
+					}
+					else
+					{
+						*(u16 *)rxbuf = (u16) data;
+					}
+
+					rxbuf += wsize;
+				}
+
+				rlen--;
+			}
+		}
+		else {
+			/* DMA will be used for the transfer */
+			spin_unlock_irqrestore(&spidat->lock, flags);
+			status = lpc313x_spi_dma_transfer(spidat, t, bits_per_word,
+				m->is_dma_mapped);
+			spin_lock_irqsave(&spidat->lock, flags);
+			if (status < 0)
+				goto exit;
+		}
+
+		m->actual_length += t->len;
+		if (t->delay_usecs)
+		{
+			udelay(t->delay_usecs);
+		}
+
+		if (!cs_change)
+			continue;
+
+		if (t->transfer_list.next == &m->transfers)
+			break;
+	}
+
+exit:
+	if (!(status == 0 && cs_change))
+	{
+		spi_force_cs(spidat, spi->chip_select, 1);
+	}
+
+	/* Disable SPI, stop SPI clock to save power */
+	spi_writel(CONFIG_REG, (spi_readl(CONFIG_REG) & ~SPI_CFG_ENABLE));
+	disable_irq(spidat->irq);
+	lpc313x_spi_clks_disen(spidat, 0);
+
+	spin_unlock_irqrestore(&spidat->lock, flags);
+	m->status = status;
+	m->complete(m->context);
+}
+
+/*
+ * Work queue function
+ */
+static void lpc313x_work(struct work_struct *work)
+{
+	struct lpc313xspi *spidat = container_of(work, struct lpc313xspi, work);
+	unsigned long flags;
+
+	spin_lock_irqsave(&spidat->lock, flags);
+
+	while (!list_empty(&spidat->queue))
+	{
+		struct spi_message *m;
+
+		m = container_of(spidat->queue.next, struct spi_message, queue);
+		list_del_init(&m->queue);
+
+		spin_unlock_irqrestore(&spidat->lock, flags);
+		lpc313x_work_one(spidat, m);
+		spin_lock_irqsave(&spidat->lock, flags);
+	}
+
+	spin_unlock_irqrestore(&spidat->lock, flags);
+}
+
+/*
+ * Kick off a SPI transfer
+ */
+static int lpc313x_spi_transfer(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_master *master = spi->master;
+	struct lpc313xspi *spidat = spi_master_get_devdata(master);
+	//struct device *controller = spi->master->dev.parent;
+	struct spi_transfer *t;
+	unsigned long flags;
+
+	m->actual_length = 0;
+
+	/* check each transfer's parameters */
+	list_for_each_entry (t, &m->transfers, transfer_list)
+	{
+		u8 bits_per_word = t->bits_per_word ? : spi->bits_per_word;
+
+		bits_per_word = bits_per_word ? : 8;
+		if ((!t->tx_buf) && (!t->rx_buf) && (t->len))
+		{
+			return -EINVAL;
+		}
+		if ((bits_per_word < 4) || (bits_per_word > 16))
+		{
+			return -EINVAL;
+		}
+
+		/*dev_dbg(controller,
+			"  xfer %p: len %u tx %p/%08x rx %p/%08x DMAmapped=%d\n",
+			t, t->len, t->tx_buf, t->tx_dma,
+			t->rx_buf, t->rx_dma, m->is_dma_mapped); */   //***MOD-
+	}
+
+	spin_lock_irqsave(&spidat->lock, flags);
+	list_add_tail(&m->queue, &spidat->queue);
+	queue_work(spidat->workqueue, &spidat->work);
+	spin_unlock_irqrestore(&spidat->lock, flags);
+
+	return 0;
+}
+
+/*
+ * SPI driver probe
+ */
+static int __init lpc313x_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct lpc313xspi *spidat;
+	int ret, irq, i;
+	dma_addr_t dma_handle;
+
+	/* Get required resources */
+	irq = platform_get_irq(pdev, 0);
+	if ((irq < 0) | (irq >= NR_IRQS))
+	{
+		return -EBUSY;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct lpc313xspi));
+	if (!master)
+	{
+		return -ENODEV;
+	}
+	spidat = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, master);
+
+	/* Is a board specific configuration available? */
+	spidat->psppcfg = (struct lpc313x_spi_cfg *) pdev->dev.platform_data;
+	if (spidat->psppcfg == NULL)
+	{
+		/* No platform data, exit */
+		ret = -ENODEV;
+		goto errout;
+	}
+	if (spidat->psppcfg->num_cs < 1)
+	{
+		/* No chip selects supported in board structure, exit */
+		ret = -ENODEV;
+		goto errout;
+	}
+	for (i = 0; i < spidat->psppcfg->num_cs; i++)
+	{
+		if (spidat->psppcfg->spics_cfg[i].spi_cs_set == NULL)
+		{
+			/* Missing hardware CS control callback, exit */
+			ret = -ENODEV;
+			goto errout;
+		}
+	}
+
+	/* Save ID for this device */
+	spidat->pdev = pdev;
+	spidat->id = pdev->id;
+	spidat->irq = irq;
+	spin_lock_init(&spidat->lock);
+
+	INIT_WORK(&spidat->work, lpc313x_work);
+	INIT_LIST_HEAD(&spidat->queue);
+	init_waitqueue_head(&spidat->waitq);
+	spidat->workqueue = create_singlethread_workqueue(dev_name(master->dev.parent));	//***MOD:Fix from JPP to compile to latest versions of Linux
+	if (!spidat->workqueue)
+	{
+		ret = -ENOMEM;
+		goto errout;
+	}
+
+	/* Enable clocks */
+	lpc313x_spi_clks_disen(spidat, 1);
+	cgu_soft_reset_module(SPI_PNRES_APB_SOFT);
+	cgu_soft_reset_module(SPI_PNRES_IP_SOFT);
+
+	ret = request_irq(spidat->irq, lpc313x_spi_irq,
+		IRQF_DISABLED, "spiirq", spidat);
+	if (ret)
+	{
+		ret = -EBUSY;
+		goto errout2;
+	}
+	disable_irq(spidat->irq);
+
+	master->bus_num = spidat->id;
+	master->setup = lpc313x_spi_setup;
+	master->transfer = lpc313x_spi_transfer;
+	master->num_chipselect = spidat->psppcfg->num_cs;
+
+	/* Setup several work DMA buffers for dummy TX and RX data. These buffers just
+	   hold the temporary TX or RX data for the unused half of the transfer and have
+	   a size of 4K (the maximum size of a transfer) */
+	spidat->dma_base_v = (u32) dma_alloc_coherent(&pdev->dev, (4096 << 1),
+		&dma_handle, GFP_KERNEL);
+	if (spidat->dma_base_v == (u32) NULL)
+	{
+		dev_err(&pdev->dev, "error getting DMA region.\n");
+		ret = -ENOMEM;
+		goto errout3;
+	}
+	spidat->dma_base_p = dma_handle;;
+
+	spidat->dma_tx_base_p = (u32) spidat->dma_base_p;
+	spidat->dma_tx_base_v = spidat->dma_base_v;
+	spidat->dma_rx_base_p = (u32) spidat->dma_base_p + 4096;
+	spidat->dma_rx_base_v = spidat->dma_base_v + 4096;
+
+	/* Fill dummy TX buffer with 0 */
+	memset((void *) spidat->dma_tx_base_v, 0, 4096);
+
+	/* Initial setup of SPI */
+	spidat->spi_base_clock = cgu_get_clk_freq(CGU_SB_SPI_CLK_ID);
+	lpc313x_spi_prep(spidat);
+
+	/* Keep SPI clocks off until a transfer is performed to save power */
+	lpc313x_spi_clks_disen(spidat, 0);
+
+	/* Request RX and TX DMA channels */
+	spidat->tx_dma_ch = spidat->rx_dma_ch = -1;
+	spidat->tx_dma_ch = dma_request_channel("spi_tx", lpc313x_dma_tx_spi_irq, spidat);
+	if (spidat->tx_dma_ch < 0)
+	{
+		dev_err(&pdev->dev, "error getting TX DMA channel.\n");
+		ret = -EBUSY;
+		goto errout4;
+	}
+	spidat->rx_dma_ch = dma_request_channel("spi_rx", lpc313x_dma_rx_spi_irq, spidat);
+	if (spidat->rx_dma_ch < 0)
+	{
+		dev_err(&pdev->dev, "error getting RX DMA channel.\n");
+		ret = -EBUSY;
+		goto errout4;
+	}
+
+	ret = spi_register_master(master);
+	if (ret)
+	{
+		goto errout4;
+	}
+
+	dev_info(&pdev->dev, "LPC313x SPI driver\n");
+
+	return 0;
+
+errout4:
+	if (spidat->tx_dma_ch != -1)
+		dma_release_channel(spidat->tx_dma_ch);
+	if (spidat->rx_dma_ch != -1)
+		dma_release_channel(spidat->rx_dma_ch);
+	dma_free_coherent(&pdev->dev, (4096 << 1), (void *) spidat->dma_base_v,
+		spidat->dma_base_p);
+errout3:
+	free_irq(spidat->irq, pdev);
+errout2:
+	lpc313x_spi_clks_disen(spidat, 0);
+	destroy_workqueue(spidat->workqueue);
+errout:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(master);
+
+	return ret;
+}
+
+/*
+ * SPI driver removal
+ */
+static int __devexit lpc313x_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = spi_master_get(platform_get_drvdata(pdev));
+	struct lpc313xspi *spidat = spi_master_get_devdata(master);
+
+	/* Disable SPI interface */
+	spi_writel(CONFIG_REG, (spi_readl(CONFIG_REG) & ~SPI_CFG_ENABLE));
+	lpc313x_spi_clks_disen(spidat, 0);
+
+	spi_unregister_master(master);
+	platform_set_drvdata(pdev, NULL);
+
+	if (spidat->tx_dma_ch != -1)
+		dma_release_channel(spidat->tx_dma_ch);
+	if (spidat->rx_dma_ch != -1)
+		dma_release_channel(spidat->rx_dma_ch);
+
+	dma_free_coherent(&pdev->dev, (4096 << 1), (void *) spidat->dma_base_v,
+		spidat->dma_base_p);
+
+	/* Free resources */
+	free_irq(spidat->irq, pdev);
+
+	destroy_workqueue(spidat->workqueue);
+	spi_master_put(master);
+
+	return 0;
+}
+
+/**
+ * Suspend SPI by switching off the IP clocks
+ **/
+static int lpc313x_spi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+#ifdef CONFIG_PM
+	struct spi_master *master = spi_master_get(platform_get_drvdata(pdev));
+	struct lpc313xspi *spidat = spi_master_get_devdata(master);
+
+	/* Check if SPI is idle before we pull off the clock */
+	if (unlikely(!list_empty(&spidat->queue)))
+		return 0;
+
+	/* Pull the clocks off */
+	lpc313x_spi_clks_disen(spidat, 0);
+#endif
+	return 0;
+}
+
+/**
+ * Resume SPI by switching on the IP clocks
+ **/
+static int lpc313x_spi_resume(struct platform_device *pdev)
+{
+#ifdef CONFIG_PM
+	struct spi_master *master = spi_master_get(platform_get_drvdata(pdev));
+	struct lpc313xspi *spidat = spi_master_get_devdata(master);
+
+	/* Switch on the clocks */
+	lpc313x_spi_clks_disen(spidat, 1);
+#endif
+	return 0;
+}
+
+static struct platform_driver lpc313x_spi_driver = {
+	.probe		= lpc313x_spi_probe,
+	.remove		= __devexit_p(lpc313x_spi_remove),
+	.suspend    = lpc313x_spi_suspend,
+	.resume     = lpc313x_spi_resume,
+	.driver		= {
+		.name	= "spi_lpc313x",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lpc313x_spi_init(void)
+{
+	return platform_driver_register(&lpc313x_spi_driver);
+}
+
+static void __exit lpc313x_spi_exit(void)
+{
+	platform_driver_unregister(&lpc313x_spi_driver);
+}
+
+module_init(lpc313x_spi_init);
+module_exit(lpc313x_spi_exit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com");
+MODULE_DESCRIPTION("LPC313X SPI Driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.28.2/drivers/usb/core/hub.c work_2.6.28.2/drivers/usb/core/hub.c
--- linux-2.6.28.2/drivers/usb/core/hub.c	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/core/hub.c	2010-03-15 16:58:23.000000000 -0700
@@ -1143,7 +1143,7 @@ static int hub_probe(struct usb_interfac
 
 #ifdef	CONFIG_USB_OTG_BLACKLIST_HUB
 	if (hdev->parent) {
-		dev_warn(&intf->dev, "ignoring external hub\n");
+		dev_warn(&intf->dev, "External hub not Supported\n");
 		return -ENODEV;
 	}
 #endif
@@ -1489,7 +1489,7 @@ static void announce_device(struct usb_d
 static inline void announce_device(struct usb_device *udev) { }
 #endif
 
-#ifdef	CONFIG_USB_OTG
+#ifdef	CONFIG_USB_OTG_WHITELIST
 #include "otg_whitelist.h"
 #endif
 
@@ -1563,8 +1563,16 @@ static int usb_configure_device_otg(stru
 		err = -ENOTSUPP;
 		goto fail;
 	}
-fail:
+#elif defined(CONFIG_USB_OTG_WHITELIST)
+	if (!is_targeted(udev)) {
+
+		dev_warn(&udev->dev, "This device is not Supported\n");
+		err = -ENOTSUPP;
+		goto fail;
+	}
+
 #endif
+fail:
 	return err;
 }
 
diff -purN linux-2.6.28.2/drivers/usb/core/Kconfig work_2.6.28.2/drivers/usb/core/Kconfig
--- linux-2.6.28.2/drivers/usb/core/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/core/Kconfig	2010-03-15 16:58:23.000000000 -0700
@@ -103,7 +103,7 @@ config USB_SUSPEND
 	  If you are unsure about this, say N here.
 
 config USB_OTG
-	bool
+	bool "OTG Support"
 	depends on USB && EXPERIMENTAL
 	select USB_SUSPEND
 	default n
diff -purN linux-2.6.28.2/drivers/usb/core/otg_whitelist.h work_2.6.28.2/drivers/usb/core/otg_whitelist.h
--- linux-2.6.28.2/drivers/usb/core/otg_whitelist.h	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/core/otg_whitelist.h	2010-03-15 16:58:23.000000000 -0700
@@ -21,6 +21,7 @@ static struct usb_device_id whitelist_ta
 /* hubs are optional in OTG, but very handy ... */
 { USB_DEVICE_INFO(USB_CLASS_HUB, 0, 0), },
 { USB_DEVICE_INFO(USB_CLASS_HUB, 0, 1), },
+{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 2), },
 
 #ifdef	CONFIG_USB_PRINTER		/* ignoring nonstatic linkage! */
 /* FIXME actually, printers are NOT supposed to use device classes;
@@ -42,7 +43,6 @@ static struct usb_device_id whitelist_ta
 /* gadget zero, for testing */
 { USB_DEVICE(0x0525, 0xa4a0), },
 #endif
-
 { }	/* Terminating entry */
 };
 
@@ -50,14 +50,22 @@ static int is_targeted(struct usb_device
 {
 	struct usb_device_id	*id = whitelist_table;
 
-	/* possible in developer configs only! */
+#if defined(CONFIG_USB_OTG)
+  /* possible in developer configs only! */
 	if (!dev->bus->otg_port)
 		return 1;
-
-	/* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
+	
+  /* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
 	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&
 	     le16_to_cpu(dev->descriptor.idProduct) == 0xbadd))
 		return 0;
+#endif
+
+#if defined(CONFIG_USB_EHCI_EHSET)
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a))
+		return 1;
+
+#endif
 
 	/* NOTE: can't use usb_match_id() since interface caches
 	 * aren't set up yet. this is cut/paste from that code.
diff -purN linux-2.6.28.2/drivers/usb/gadget/fsl_usb2_udc.c work_2.6.28.2/drivers/usb/gadget/fsl_usb2_udc.c
--- linux-2.6.28.2/drivers/usb/gadget/fsl_usb2_udc.c	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/gadget/fsl_usb2_udc.c	2010-03-15 16:57:43.000000000 -0700
@@ -38,6 +38,7 @@
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/dmapool.h>
+#include <linux/delay.h>
 
 #include <asm/byteorder.h>
 #include <asm/io.h>
@@ -57,7 +58,9 @@ static const char driver_name[] = "fsl-u
 static const char driver_desc[] = DRIVER_DESC;
 
 static struct usb_dr_device *dr_regs;
+#ifndef CONFIG_ARCH_MXC
 static struct usb_sys_interface *usb_sys_regs;
+#endif
 
 /* it is initialized in probe()  */
 static struct fsl_udc *udc_controller = NULL;
@@ -72,6 +75,8 @@ fsl_ep0_desc = {
 };
 
 static void fsl_ep_fifo_flush(struct usb_ep *_ep);
+static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state);
+static int fsl_udc_resume(struct platform_device *pdev);
 
 #ifdef CONFIG_PPC32
 #define fsl_readl(addr)		in_le32(addr)
@@ -237,9 +242,11 @@ static int dr_controller_setup(struct fs
 	fsl_writel(portctrl, &dr_regs->portsc1);
 
 	/* Config control enable i/o output, cpu endian register */
+#ifndef CONFIG_ARCH_MXC
 	ctrl = __raw_readl(&usb_sys_regs->control);
 	ctrl |= USB_CTRL_IOENB;
 	__raw_writel(ctrl, &usb_sys_regs->control);
+#endif
 
 #if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
 	/* Turn on cache snooping hardware, since some PowerPC platforms
@@ -287,6 +294,17 @@ static void dr_controller_stop(struct fs
 {
 	unsigned int tmp;
 
+	/* if we're in OTG mode, and the Host is currently using the port,
+	 * stop now and don't rip the controller out from under the
+	 * ehci driver
+	 */
+	if (gadget_is_otg(&udc->gadget)) {
+		if (!(dr_regs->otgsc & OTGSC_STS_USB_ID)) {
+			VDBG("udc: Leaving early\n");
+			return;
+		}
+	}
+
 	/* disable all INTR */
 	fsl_writel(0, &dr_regs->usbintr);
 
@@ -405,6 +423,8 @@ static void struct_ep_qh_setup(struct fs
 	if (zlt)
 		tmp |= EP_QUEUE_HEAD_ZLT_SEL;
 	p_QH->max_pkt_length = cpu_to_le32(tmp);
+	p_QH->next_dtd_ptr = 1;
+	p_QH->size_ioc_int_sts = 0;
 
 	return;
 }
@@ -1789,17 +1809,36 @@ int usb_gadget_register_driver(struct us
 		goto out;
 	}
 
-	/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
-	dr_controller_run(udc_controller);
-	udc_controller->usb_state = USB_STATE_ATTACHED;
-	udc_controller->ep0_state = WAIT_FOR_SETUP;
-	udc_controller->ep0_dir = 0;
+	if (udc_controller->transceiver) {
+		VDBG("udc: suspend udc for OTG auto detect \n");
+		udc_controller->stopped = 0;
+		/* Export udc suspend/resume call to OTG */
+		//udc_controller->gadget.dev.parent->driver->suspend = fsl_udc_suspend;
+		//udc_controller->gadget.dev.parent->driver->resume = fsl_udc_resume;
+
+		/* connect to bus through transceiver */
+		retval = otg_set_peripheral(udc_controller->transceiver, &udc_controller->gadget);
+		if (retval < 0) {
+			VDBG("udc: can't bind to transceiver\n");
+			driver->unbind(&udc_controller->gadget);
+			udc_controller->gadget.dev.driver = 0;
+			udc_controller->driver = 0;
+			return retval;
+		}
+	} else {
+		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+		dr_controller_run(udc_controller);
+		udc_controller->usb_state = USB_STATE_ATTACHED;
+		udc_controller->ep0_state = WAIT_FOR_SETUP;
+		udc_controller->ep0_dir = 0;
+	}
 	printk(KERN_INFO "%s: bind to driver %s\n",
 			udc_controller->gadget.name, driver->driver.name);
 
 out:
 	if (retval)
-		printk("gadget driver register failed %d\n", retval);
+		printk(KERN_WARNING "gadget driver register failed %d\n",
+		       retval);
 	return retval;
 }
 EXPORT_SYMBOL(usb_gadget_register_driver);
@@ -1844,7 +1883,8 @@ int usb_gadget_unregister_driver(struct 
 	udc_controller->gadget.dev.driver = NULL;
 	udc_controller->driver = NULL;
 
-	printk("unregistered gadget driver '%s'\n", driver->driver.name);
+	printk(KERN_WARNING "unregistered gadget driver '%s'\n",
+	       driver->driver.name);
 	return 0;
 }
 EXPORT_SYMBOL(usb_gadget_unregister_driver);
@@ -2038,6 +2078,7 @@ static int fsl_proc_read(char *page, cha
 	size -= t;
 	next += t;
 
+#ifndef CONFIG_ARCH_MXC
 	tmp_reg = usb_sys_regs->snoop1;
 	t = scnprintf(next, size, "Snoop1 Reg : = [0x%x]\n\n", tmp_reg);
 	size -= t;
@@ -2048,6 +2089,7 @@ static int fsl_proc_read(char *page, cha
 			tmp_reg);
 	size -= t;
 	next += t;
+#endif
 
 	/* ------fsl_udc, fsl_ep, fsl_request structure information ----- */
 	ep = &udc->eps[0];
@@ -2258,14 +2300,21 @@ static int __init fsl_udc_probe(struct p
 		goto err_kfree;
 	}
 
-	dr_regs = ioremap(res->start, res->end - res->start + 1);
+	dr_regs = ioremap(res->start, resource_size(res));
 	if (!dr_regs) {
 		ret = -ENOMEM;
 		goto err_release_mem_region;
 	}
 
+#ifndef CONFIG_ARCH_MXC
 	usb_sys_regs = (struct usb_sys_interface *)
 			((u32)dr_regs + USB_DR_SYS_OFFSET);
+#endif
+
+	/* Initialize USB clocks */
+	ret = fsl_udc_clk_init(pdev);
+	if (ret < 0)
+		goto err_iounmap_noclk;
 
 	/* Read Device Controller Capability Parameters register */
 	dccparams = fsl_readl(&dr_regs->dccparams);
@@ -2278,6 +2327,11 @@ static int __init fsl_udc_probe(struct p
 	/* DEN is bidirectional ep number, max_ep doubles the number */
 	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
 
+#ifdef CONFIG_USB_OTG
+	udc_controller->transceiver = otg_get_transceiver();
+	VDBG("udc: otg_get_transceiver returns 0x%p", udc_controller->transceiver);
+#endif
+
 	udc_controller->irq = platform_get_irq(pdev, 0);
 	if (!udc_controller->irq) {
 		ret = -ENODEV;
@@ -2301,7 +2355,13 @@ static int __init fsl_udc_probe(struct p
 
 	/* initialize usb hw reg except for regs for EP,
 	 * leave usbintr reg untouched */
+	if (!udc_controller->transceiver) {
 	dr_controller_setup(udc_controller);
+	} else {
+		udc_controller->gadget.is_otg = 1;
+	}
+
+	fsl_udc_clk_finalize(pdev);
 
 	/* Setup gadget structure */
 	udc_controller->gadget.ops = &fsl_gadget_ops;
@@ -2357,6 +2417,8 @@ err_unregister:
 err_free_irq:
 	free_irq(udc_controller->irq, udc_controller);
 err_iounmap:
+	fsl_udc_clk_release();
+err_iounmap_noclk:
 	iounmap(dr_regs);
 err_release_mem_region:
 	release_mem_region(res->start, res->end - res->start + 1);
@@ -2379,6 +2441,14 @@ static int __exit fsl_udc_remove(struct 
 		return -ENODEV;
 	udc_controller->done = &done;
 
+	fsl_udc_clk_release();
+
+#ifdef CONFIG_USB_OTG
+	if (udc_controller->transceiver) {
+		otg_put_transceiver(udc_controller->transceiver);
+		udc_controller->transceiver = 0;
+	}
+#endif
 	/* DR has been stopped in usb_gadget_unregister_driver() */
 	remove_proc_file();
 
@@ -2452,7 +2522,7 @@ module_init(udc_init);
 static void __exit udc_exit(void)
 {
 	platform_driver_unregister(&udc_driver);
-	printk("%s unregistered\n", driver_desc);
+	printk(KERN_WARNING "%s unregistered\n", driver_desc);
 }
 
 module_exit(udc_exit);
diff -purN linux-2.6.28.2/drivers/usb/gadget/fsl_usb2_udc.h work_2.6.28.2/drivers/usb/gadget/fsl_usb2_udc.h
--- linux-2.6.28.2/drivers/usb/gadget/fsl_usb2_udc.h	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/gadget/fsl_usb2_udc.h	2010-03-15 16:57:43.000000000 -0700
@@ -563,4 +563,22 @@ static void dump_msg(const char *label, 
 					* 2 + ((windex & USB_DIR_IN) ? 1 : 0))
 #define get_pipe_by_ep(EP)	(ep_index(EP) * 2 + ep_is_in(EP))
 
+struct platform_device;
+#ifdef CONFIG_ARCH_MXC
+int fsl_udc_clk_init(struct platform_device *pdev);
+void fsl_udc_clk_finalize(struct platform_device *pdev);
+void fsl_udc_clk_release(void);
+#else
+static inline int fsl_udc_clk_init(struct platform_device *pdev)
+{
+	return 0;
+}
+static inline void fsl_udc_clk_finalize(struct platform_device *pdev)
+{
+}
+static inline void fsl_udc_clk_release(void)
+{
+}
+#endif
+
 #endif
diff -purN linux-2.6.28.2/drivers/usb/gadget/gadget_chips.h work_2.6.28.2/drivers/usb/gadget/gadget_chips.h
--- linux-2.6.28.2/drivers/usb/gadget/gadget_chips.h	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/gadget/gadget_chips.h	2010-03-15 16:57:43.000000000 -0700
@@ -65,6 +65,12 @@
 #define	gadget_is_lh7a40x(g)	0
 #endif
 
+#ifdef CONFIG_USB_GADGET_LPC313x
+#define	gadget_is_lpc313x(g)	!strcmp("lpc313x_udc", (g)->name)
+#else
+#define	gadget_is_lpc313x(g)	0
+#endif
+
 /* handhelds.org tree (?) */
 #ifdef CONFIG_USB_GADGET_MQ11XX
 #define	gadget_is_mq11xx(g)	!strcmp("mq11xx_udc", (g)->name)
@@ -225,6 +231,8 @@ static inline int usb_gadget_controller_
 		return 0x21;
 	else if (gadget_is_fsl_qe(gadget))
 		return 0x22;
+	else if (gadget_is_lpc313x(gadget))
+		return 0x23;
 	return -ENOENT;
 }
 
diff -purN linux-2.6.28.2/drivers/usb/gadget/Kconfig work_2.6.28.2/drivers/usb/gadget/Kconfig
--- linux-2.6.28.2/drivers/usb/gadget/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/gadget/Kconfig	2010-03-15 17:48:56.000000000 -0700
@@ -155,12 +155,12 @@ config USB_ATMEL_USBA
 	select USB_GADGET_SELECTED
 
 config USB_GADGET_FSL_USB2
-	boolean "Freescale Highspeed USB DR Peripheral Controller"
-	depends on FSL_SOC
+	boolean "Freescale/LPC313x Highspeed USB DR Peripheral Controller"
+	depends on FSL_SOC || ARCH_MXC || ARCH_LPC313X
 	select USB_GADGET_DUALSPEED
 	help
-	   Some of Freescale PowerPC processors have a High Speed
-	   Dual-Role(DR) USB controller, which supports device mode.
+	   Some of Freescale PowerPC processorsand LPC313x have a High 
+	   Speed Dual-Role(DR) USB controller, which supports device mode.
 
 	   The number of programmable endpoints is different through
 	   SOC revisions.
diff -purN linux-2.6.28.2/drivers/usb/host/ehci.h work_2.6.28.2/drivers/usb/host/ehci.h
--- linux-2.6.28.2/drivers/usb/host/ehci.h	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/host/ehci.h	2010-03-15 16:58:39.000000000 -0700
@@ -123,6 +123,12 @@ struct ehci_hcd {			/* one per controlle
 
 	u8			sbrn;		/* packed release number */
 
+	/*
+	 * OTG controllers and transceivers need software interaction;
+	 * other external transceivers should be software-transparent 
+	 */
+	struct otg_transceiver   *transceiver;
+
 	/* irq statistics */
 #ifdef EHCI_STATS
 	struct ehci_stats	stats;
diff -purN linux-2.6.28.2/drivers/usb/host/ehci-hcd.c work_2.6.28.2/drivers/usb/host/ehci-hcd.c
--- linux-2.6.28.2/drivers/usb/host/ehci-hcd.c	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/host/ehci-hcd.c	2010-03-15 16:57:43.000000000 -0700
@@ -1034,6 +1034,12 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_LPC
+#include "ehci-lpc.c"
+#define	PLATFORM_DRIVER		ehci_lpc_driver
+#endif
+
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
diff -purN linux-2.6.28.2/drivers/usb/host/ehci-lpc.c work_2.6.28.2/drivers/usb/host/ehci-lpc.c
--- linux-2.6.28.2/drivers/usb/host/ehci-lpc.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/drivers/usb/host/ehci-lpc.c	2010-03-16 10:35:26.000000000 -0700
@@ -0,0 +1,357 @@
+/*
+ * LPC313x & LPC315x EHCI Host Controller Driver
+ *
+ * Author: Durgesh Pattamatta <durgesh.pattamatta@nxp.com>
+ *
+ * Based on "ehci-fsl.c" by Randy Vinson <rvinson@mvista.com>
+ *
+ * 2009 (c) NXP Semiconductors. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <mach/board.h>
+
+static struct platform_driver ehci_lpc_driver;
+
+static int lpc_ehci_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval = 0;
+
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100
+		+ HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	/* data structure init */
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+	
+	hcd->has_tt = 1;
+
+	ehci->sbrn = 0x20;
+	ehci_reset(ehci);
+
+	ehci_port_power(ehci, 0);
+	/* board vbus power */
+	//lpc313x_vbus_power(0);
+
+	return retval;
+}
+
+static const struct hc_driver lpc_ehci_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "LPC EHCI Host Controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+	.reset			= lpc_ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.get_frame_number	= ehci_get_frame,
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+};
+
+static int lpc_ehci_probe(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	struct usb_hcd *hcd;
+	const struct hc_driver *driver = &lpc_ehci_hc_driver;
+	struct resource *res;
+	int irq;
+	int retval;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	/* Need platform data for setup */
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	/*
+	 * This is a host mode driver, verify that we're supposed to be
+	 * in host mode.
+	 */
+	if (!((pdata->operating_mode == FSL_USB2_DR_HOST) ||
+	      (pdata->operating_mode == FSL_USB2_DR_OTG))) {
+		dev_err(&pdev->dev,
+			"Non Host Mode configured for %s. Wrong driver linked.\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto fail_create_hcd;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		retval = -ENODEV;
+		goto fail_request_resource;
+	}
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+/*	
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+				driver->description)) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto fail_request_resource;
+	}
+*/
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (hcd->regs == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto fail_ioremap;
+	}
+
+	/* Set to Host mode */
+	writel(readl(hcd->regs + 0x1a8) | 0x3, (hcd->regs + 0x1a8));
+
+	
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto fail_add_hcd;
+
+#if defined(CONFIG_USB_OTG)
+	if (pdata->operating_mode == FSL_USB2_DR_OTG) {
+		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+		dbg("pdev=0x%p  hcd=0x%p  ehci=0x%p\n", pdev, hcd, ehci);
+
+		ehci->transceiver = otg_get_transceiver();
+
+		printk(KERN_INFO "ehci->transceiver=0x%p, driver=0x%p\n", (void*)ehci->transceiver, (void*)&ehci_lpc_driver);
+
+		if (ehci->transceiver) {
+			retval = otg_set_host(ehci->transceiver,
+					      &ehci_to_hcd(ehci)->self);
+			if (retval) {
+				if (ehci->transceiver)
+					otg_put_transceiver(ehci->transceiver);
+				goto fail_add_hcd;
+			}
+		} else {
+			printk(KERN_ERR "can't find transceiver\n");
+			retval = -ENODEV;
+			goto fail_add_hcd;
+		}
+	}
+#endif
+	return retval;
+
+fail_add_hcd:
+	iounmap(hcd->regs);
+fail_ioremap:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+fail_request_resource:
+	usb_put_hcd(hcd);
+fail_create_hcd:
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
+	return retval;
+}
+
+static int lpc_ehci_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+#if defined(CONFIG_USB_OTG)
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	if (ehci->transceiver) {
+		(void)otg_set_host(ehci->transceiver, 0);
+		otg_put_transceiver(ehci->transceiver);
+	}
+#endif
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_OTG
+volatile static struct ehci_regs usb_ehci_regs;
+
+/* suspend/resume, section 4.3 */
+
+/* These routines rely on the bus (pci, platform, etc)
+ * to handle powerdown and wakeup, and currently also on
+ * transceivers that don't need any software attention to set up
+ * the right sort of wakeup.
+ *
+ * They're also used for turning on/off the port when doing OTG.
+ */
+static int lpc_ehci_suspend(struct device *dev, pm_message_t state)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 cmd;
+
+	dev_dbg(dev, "%s pdev=0x%p  ehci=0x%p  hcd=0x%p\n",
+		 __FUNCTION__, pdev, ehci, hcd);
+	dev_dbg(dev, "%s ehci->regs=0x%p  hcd->regs=0x%p  hcd->state=%d\n",
+		 __FUNCTION__, ehci->regs, hcd->regs, hcd->state);
+
+	hcd->state = HC_STATE_SUSPENDED;
+	pdev->dev.power.power_state = PMSG_SUSPEND;
+
+	/* ignore non-host interrupts */
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	cmd = ehci_readl(ehci, &ehci->regs->command);
+	cmd &= ~CMD_RUN;
+	ehci_writel(ehci, cmd, &ehci->regs->command);
+
+	memcpy((void *)&usb_ehci_regs, ehci->regs, sizeof(struct ehci_regs));
+	usb_ehci_regs.port_status[0] &=
+	    cpu_to_le32(~(PORT_PEC | PORT_OCC | PORT_CSC));
+
+	/* put the device in idele mode */
+	writel(0, (hcd->regs + 0x1a8));
+	/* board vbus power */
+	//lpc313x_vbus_power(0);
+
+	return 0;
+}
+
+static int lpc_ehci_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 tmp;
+
+	dbg("%s pdev=0x%p  pdata=0x%p  ehci=0x%p  hcd=0x%p\n",
+	    __FUNCTION__, pdev, pdata, ehci, hcd);
+
+	vdbg("%s ehci->regs=0x%p  hcd->regs=0x%p  usbmode=0x%x\n",
+	     __FUNCTION__, ehci->regs, hcd->regs, pdata->usbmode);
+
+	/* Set to Host mode */
+	writel(USBMODE_CM_HC, (hcd->regs + 0x1a8));
+
+	memcpy(ehci->regs, (void *)&usb_ehci_regs, sizeof(struct ehci_regs));
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	hcd->state = HC_STATE_RUNNING;
+	pdev->dev.power.power_state = PMSG_ON;
+
+	tmp = ehci_readl(ehci, &ehci->regs->command);
+	tmp |= CMD_RUN;
+	ehci_writel(ehci, tmp, &ehci->regs->command);
+
+	/* board vbus power */
+	//lpc313x_vbus_power(1);
+
+
+	usb_hcd_resume_root_hub(hcd);
+
+	return 0;
+}
+#endif				/* CONFIG_USB_OTG */
+/**
+ * FIXME: This should get into a common header
+ * currently declared in arch/arm/mach-lpc313x/usb.c
+ **/
+#define USB_DEV_PORTSC1			__REG(USBOTG_PHYS + 0x184)
+#define USBPRTS_PLPSCD	_BIT(23)
+static int lpc313x_ehci_suspend(struct platform_device *pdev, pm_message_t state)
+{
+#ifdef CONFIG_PM
+	disable_irq(IRQ_VBUS_OVRC);
+	/* Shutoff vbus power */
+	lpc313x_vbus_power(0);
+	/* Bring PHY to low power state */
+	USB_DEV_PORTSC1 |= USBPRTS_PLPSCD;
+	/* Bring PLL to low power state */
+	SYS_USB_ATX_PLL_PD_REG = 0x1;
+	/* Shutoff IP Clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 0);
+#endif
+	return 0;
+}
+
+static int lpc313x_ehci_resume(struct platform_device * pdev)
+{
+#ifdef CONFIG_PM
+	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	int tout = 100;
+
+	/* Turn on IP Clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 1);
+	/* Bring PLL to low power state */
+	SYS_USB_ATX_PLL_PD_REG = 0x0;
+	/* wait for PLL to lock */
+	while (!(EVRT_RSR(bank) & _BIT(bit_pos))){
+		udelay(5);
+		if (!tout--)
+			break;
+	}
+	/* Bring PHY to active state */
+	USB_DEV_PORTSC1 &= ~USBPRTS_PLPSCD;
+	lpc313x_vbus_power(1);
+	enable_irq(IRQ_VBUS_OVRC);
+#endif
+	return 0;
+}
+
+static struct platform_driver ehci_lpc_driver = {
+	.probe = lpc_ehci_probe,
+	.remove = lpc_ehci_remove,
+	.suspend = lpc313x_ehci_suspend,
+	.resume = lpc313x_ehci_resume,
+	.driver = {
+		.name = "lpc-ehci",
+#ifdef CONFIG_USB_OTG
+		.suspend = lpc_ehci_suspend,
+		.resume  = lpc_ehci_resume,
+#endif
+	},
+};
+
+MODULE_ALIAS("platform:lpc-ehci");
diff -purN linux-2.6.28.2/drivers/usb/host/Kconfig work_2.6.28.2/drivers/usb/host/Kconfig
--- linux-2.6.28.2/drivers/usb/host/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/host/Kconfig	2010-03-15 16:58:39.000000000 -0700
@@ -42,6 +42,21 @@ config USB_EHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
+config USB_EHCI_EHSET
+	bool "Embedded High-speed Host Electrical Test Support (EXPERIMENTAL)"
+	depends on USB_EHCI_HCD && EXPERIMENTAL
+	---help---
+	  This option is only used if you are developing firmware for
+	  an embedded device with a Hi-speed USB Host or OTG port.
+
+	  If you say Y here, software support for the Embedded High-speed
+	  Host Electrical Tests will be added to the EHCI driver. This is
+	  one of the tests performed during High-speed USB Host certification
+	  testing.
+
+	  If you are at all unsure then say N here.
+
+
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators"
 	depends on USB_EHCI_HCD
@@ -96,6 +111,13 @@ config USB_EHCI_HCD_PPC_OF
 	  Enables support for the USB controller present on the PowerPC
 	  OpenFirmware platform bus.
 
+config USB_EHCI_LPC
+	bool "Support for NXP on-chip EHCI USB controller"
+	depends on USB_EHCI_HCD && ARCH_LPC313X
+	select USB_EHCI_ROOT_HUB_TT
+	---help---
+	  Variation of ARC USB block used in some NXP chips.
+
 config USB_ISP116X_HCD
 	tristate "ISP116X HCD support"
 	depends on USB
diff -purN linux-2.6.28.2/drivers/usb/host/lpc-ehset.c work_2.6.28.2/drivers/usb/host/lpc-ehset.c
--- linux-2.6.28.2/drivers/usb/host/lpc-ehset.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/drivers/usb/host/lpc-ehset.c	2010-03-15 16:58:39.000000000 -0700
@@ -0,0 +1,353 @@
+/* linux/arch/arm/mach-lpc313x/usb.c -- platform level USB initialization
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * USB initialization code.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/usb.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include "../core/usb.h"
+#include "../core/hcd.h"
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <mach/hardware.h>
+
+/****************************************************************************
+* USBOTG register definition
+****************************************************************************/
+#define USB_DEV_PORTSC1			__REG(USBOTG_PHYS + 0x184)
+
+/*-------------------------------------------------------------------------*/
+
+#define USB_PORT_TEST_DISABLE			0x00
+#define USB_PORT_TEST_J				0x01
+#define USB_PORT_TEST_K				0x02
+#define USB_PORT_TEST_SE0_NAK			0x03
+#define USB_PORT_TEST_PACKET			0x04
+#define USB_PORT_TEST_FORCE_ENABLE_HS		0x05
+#define USB_PORT_TEST_FORCE_ENABLE_FS		0x06
+#define USB_PORT_TEST_FORCE_ENABLE_LS		0x07
+
+/*---------------------------------------------------------------------------*/
+/* This is the list of VID/PID that the HS OPT card will use. */
+static struct usb_device_id hset_table [] = {
+	{ USB_DEVICE(6666, 0x0101) },	/* TEST_SE0_NAK */
+	{ USB_DEVICE(6666, 0x0102) },	/* TEST_J */
+	{ USB_DEVICE(6666, 0x0103) },	/* TEST_K */
+	{ USB_DEVICE(6666, 0x0104) },	/* TEST_PACKET */
+	{ USB_DEVICE(6666, 0x0105) },	/* TEST_FORCE_ENABLE */
+	{ USB_DEVICE(6666, 0x0106) },	/* HS_HOST_PORT_SUSPEND_RESUME */
+	{ USB_DEVICE(6666, 0x0107) },	/* SINGLE_STEP_GET_DEV_DESC */
+	{ USB_DEVICE(6666, 0x0108) },	/* SINGLE_STEP_SET_FEATURE */
+	{ }				/* Terminating entry */
+};
+MODULE_DEVICE_TABLE (usb, hset_table);
+
+/* Structure to hold all of our device specific stuff */
+struct usb_hset {
+	struct usb_device *	udev;	/* the usb device for this device */
+	struct usb_interface *	interface; /* the interface for this device */
+	struct kref		kref;
+	struct usb_hcd *	hcd;
+};
+#define to_hset_dev(d) container_of(d, struct usb_hset, kref)
+
+static struct usb_hset *the_hset;
+static struct usb_driver hset_driver;
+
+/*---------------------------------------------------------------------------*/
+/* Test routines */
+static inline void test_se0_nak(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_SE0_NAK << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static inline void test_j(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_J << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static inline void test_k(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_K << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static inline void test_packet(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_PACKET << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static inline void test_force_enable(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_FORCE_ENABLE_HS << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static void suspend(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	USB_DEV_PORTSC1 |= (1 << 7);
+}
+
+static void resume(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	USB_DEV_PORTSC1 |= (1 << 6);
+}
+
+static void test_suspend_resume(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	suspend(hset);
+	msleep(15000);	/* Wait for 15 sec */
+	resume(hset);
+}
+
+static void test_single_step_get_dev_desc(struct usb_hset *hset)
+{
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(hset->hcd);
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_DEBUG "No device connected.\n");
+		return;
+	}
+	usb_get_device_descriptor(udev, sizeof(struct usb_device_descriptor));
+}
+
+static void test_single_step_set_feature(struct usb_hset *hset)
+{
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(hset->hcd);
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_DEBUG "No device connected.\n");
+		return;
+	}
+	usb_control_msg(udev,
+			usb_sndctrlpipe(udev, 0),
+			USB_REQ_SET_FEATURE, 0, 0,
+			0, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
+}
+
+static void enumerate_bus(struct work_struct *ignored)
+{
+	struct usb_hset *hset = the_hset;
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(hset->hcd);
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (udev)
+		usb_reset_device(udev);
+}
+
+DECLARE_WORK(enumerate, enumerate_bus);
+
+/*---------------------------------------------------------------------------*/
+
+/* This function can be called either by musb_init_hset() or usb_hset_probe().
+ * musb_init_hset() is called by the controller driver during its init(),
+ * while usb_hset_probe() is called when an OPT is attached. We take care not
+ * to allocate the usb_hset structure twice.
+ */
+static struct usb_hset* init_hset_dev(void *controller)
+{
+	struct usb_hset *hset = NULL;
+
+	/* if already allocated, just increment use count and return */
+	if (the_hset) {
+		kref_get(&the_hset->kref);
+		return the_hset;
+	}
+
+	hset = kmalloc(sizeof(*hset), GFP_KERNEL);
+	if (hset == NULL) {
+		err("Out of memory");
+		return NULL;
+	}
+	memset(hset, 0x00, sizeof(*hset));
+	hset->hcd = (struct usb_hcd *)(controller);
+
+	kref_init(&hset->kref);
+	the_hset = hset;
+	return hset;
+}
+
+static void hset_delete(struct kref *kref)
+{
+	struct usb_hset *dev = to_hset_dev(kref);
+
+	kfree (dev);
+}
+/*---------------------------------------------------------------------------*/
+/* Usage of HS OPT */
+
+
+/* Called when the HS OPT is attached as a device */
+static int hset_probe(struct usb_interface *interface,
+		      const struct usb_device_id *id)
+{
+	struct usb_hset *hset;
+	struct usb_device *udev;
+	struct usb_hcd *hcd;
+	int retval = -ENOMEM;
+
+	udev = usb_get_dev(interface_to_usbdev(interface));
+	hcd = udev->bus->controller->driver_data;
+	hset = init_hset_dev(hcd);
+	if (!hset)
+		return retval;
+
+	hset->udev = udev;
+	hset->interface = interface;
+	usb_set_intfdata(interface, hset);
+
+	switch(id->idProduct) {
+	case 0x0101:
+		test_se0_nak(hset);
+		break;
+	case 0x0102:
+		test_j(hset);
+		break;
+	case 0x0103:
+		test_k(hset);
+		break;
+	case 0x0104:
+		test_packet(hset);
+		break;
+	case 0x0105:
+		test_force_enable(hset);
+		break;
+	case 0x0106:
+		test_suspend_resume(hset);
+		break;
+	case 0x0107:
+		msleep(15000);	/* SOFs for 15 sec */
+		test_single_step_get_dev_desc(hset);
+		break;
+	case 0x0108:
+		test_single_step_get_dev_desc(hset);
+		msleep(15000);	/* SOFs for 15 sec */
+		test_single_step_set_feature(hset);
+		break;
+	};
+	return 0;
+}
+
+static void hset_disconnect(struct usb_interface *interface)
+{
+	struct usb_hset *hset;
+
+	/* prevent hset_open() from racing hset_disconnect() */
+	//lock_kernel();
+	hset = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+	//unlock_kernel();
+
+	usb_put_dev(hset->udev);
+	kref_put(&hset->kref, hset_delete);
+}
+
+static struct usb_driver hset_driver = {
+//	.owner =	THIS_MODULE,
+	.name =		"hset",
+	.probe =	hset_probe,
+	.disconnect =	hset_disconnect,
+	.id_table =	hset_table,
+};
+
+static int __init usb_hset_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&hset_driver);
+	if (result)
+		err("usb_register failed. Error number %d", result);
+
+	return result;
+}
+
+static void __exit usb_hset_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&hset_driver);
+}
+
+module_init (usb_hset_init);
+module_exit (usb_hset_exit);
+
+MODULE_LICENSE("GPL");
+
diff -purN linux-2.6.28.2/drivers/usb/host/Makefile work_2.6.28.2/drivers/usb/host/Makefile
--- linux-2.6.28.2/drivers/usb/host/Makefile	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/host/Makefile	2010-03-15 16:58:39.000000000 -0700
@@ -22,3 +22,5 @@ obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
 obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
 obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
 obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
+
+obj-$(CONFIG_USB_EHCI_EHSET)	+= lpc-ehset.o
diff -purN linux-2.6.28.2/drivers/usb/Kconfig work_2.6.28.2/drivers/usb/Kconfig
--- linux-2.6.28.2/drivers/usb/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/usb/Kconfig	2010-03-15 16:58:39.000000000 -0700
@@ -56,6 +56,7 @@ config USB_ARCH_HAS_EHCI
 	default y if PPC_83xx
 	default y if SOC_AU1200
 	default y if ARCH_IXP4XX
+	default y if ARCH_LPC313X
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff -purN linux-2.6.28.2/drivers/watchdog/Kconfig work_2.6.28.2/drivers/watchdog/Kconfig
--- linux-2.6.28.2/drivers/watchdog/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/watchdog/Kconfig	2010-03-15 16:58:39.000000000 -0700
@@ -235,6 +235,15 @@ config ORION5X_WATCHDOG
 
 # ARM26 Architecture
 
+config LPC313X_WATCHDOG
+	tristate "NXP LPC313x watchdog"
+	depends on ARCH_LPC313X
+	help
+	  Say Y here if to include support for the watchdog timer
+	  for the NXP's LPC313x uC SoC.
+	  To compile this driver as a module, choose M here: the
+	  module will be called wdt_lpc313x.
+
 # AVR32 Architecture
 
 config AT32AP700X_WDT
diff -purN linux-2.6.28.2/drivers/watchdog/Makefile work_2.6.28.2/drivers/watchdog/Makefile
--- linux-2.6.28.2/drivers/watchdog/Makefile	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/drivers/watchdog/Makefile	2010-03-15 17:08:40.000000000 -0700
@@ -41,6 +41,7 @@ obj-$(CONFIG_PNX4008_WATCHDOG) += pnx400
 obj-$(CONFIG_IOP_WATCHDOG) += iop_wdt.o
 obj-$(CONFIG_DAVINCI_WATCHDOG) += davinci_wdt.o
 obj-$(CONFIG_ORION5X_WATCHDOG) += orion5x_wdt.o
+obj-$(CONFIG_LPC313X_WATCHDOG) += wdt_lpc313x.o
 
 # ARM26 Architecture
 
diff -purN linux-2.6.28.2/drivers/watchdog/wdt_lpc313x.c work_2.6.28.2/drivers/watchdog/wdt_lpc313x.c
--- linux-2.6.28.2/drivers/watchdog/wdt_lpc313x.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/drivers/watchdog/wdt_lpc313x.c	2010-03-15 16:58:39.000000000 -0700
@@ -0,0 +1,391 @@
+/*
+ * LPC313x Watchdog timer driver
+ *
+ * drivers/watchdog/wdt_lpc313x.c
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/watchdog.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/interrupt.h>
+
+#include <mach/hardware.h>
+#include <mach/cgu.h>
+
+#define MAX_HEARTBEAT 120
+#define DEFAULT_HEARTBEAT 25
+#define WDT_IN_USE        0
+#define WDT_OK_TO_CLOSE   1
+
+/* Offset of WDT registers */
+#define LPC313x_WDT_IR       0x00
+#define LPC313x_WDT_TCR      0x04
+#define LPC313x_WDT_TC       0x08
+#define LPC313x_WDT_PR       0x0C
+#define LPC313x_WDT_PC       0x10
+#define LPC313x_WDT_MCR      0x14
+#define LPC313x_WDT_MR0      0x18
+#define LPC313x_WDT_MR1      0x1C
+#define LPC313x_WDT_EMR      0x3C
+
+#define INTR_M0      0x01
+#define INTR_M1      0x02
+
+#define TCR_EN       0x01
+#define TCR_RST      0x02
+
+#define INTEN_MR0    (1 << 0)
+#define RESET_MR0    (1 << 1)
+#define STOP_MR0     (1 << 2)
+#define INTEN_MR1    (1 << 3)
+#define RESET_MR1    (1 << 4)
+#define STOP_MR1     (1 << 5)
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+static int heartbeat = DEFAULT_HEARTBEAT;
+
+static struct lpc313x_wdt
+{
+	spinlock_t lock;
+	void __iomem * base;
+	int irq;
+	unsigned long status;
+	unsigned long boot_status;
+	struct device * dev;
+}lpc313x_wdt;
+
+static void lpc313x_wdt_stop(struct lpc313x_wdt * wdt)
+{
+	void __iomem * base = wdt->base;
+
+	/* Disable watchdog clock */
+	cgu_clk_en_dis(CGU_SB_WDOG_PCLK_ID, 0);
+
+	/* Disable and reset counter */
+	writel(TCR_RST, base + LPC313x_WDT_TCR);
+
+	/* Clear interrupts */
+	writel(INTR_M0 | INTR_M1, base + LPC313x_WDT_TCR);
+	writel(0, base + LPC313x_WDT_MCR);
+	writel(0, base + LPC313x_WDT_PC);
+	writel(0, base + LPC313x_WDT_PR);
+
+	/* Bring counter out of reset */
+	writel(0, base + LPC313x_WDT_TCR);
+}
+
+static void lpc313x_wdt_start(struct lpc313x_wdt * wdt)
+{
+	uint32_t freq;
+	void __iomem * base = wdt->base;
+
+	/* Enable WDOG_PCLK and get its frequency */
+	cgu_clk_en_dis(CGU_SB_WDOG_PCLK_ID, 1);
+	freq = cgu_get_clk_freq(CGU_SB_WDOG_PCLK_ID);
+	writel(freq-1, base + LPC313x_WDT_PR);
+	writel(heartbeat, base + LPC313x_WDT_MR0);
+	writel(INTEN_MR0 | STOP_MR0, base + LPC313x_WDT_MCR);
+
+	/* Start WDT */
+	writel(TCR_EN, base + LPC313x_WDT_TCR);
+}
+
+static void lpc313x_wdt_keepalive(struct lpc313x_wdt * wdt)
+{
+	void __iomem * base = wdt->base;
+	writel(0, base + LPC313x_WDT_PC);
+	writel(0, base + LPC313x_WDT_TC);
+}
+
+/**
+ *	wdt_open:
+ *	@inode: inode of device
+ *	@file: file handle to device
+ *
+ *	The watchdog device has been opened. The watchdog device is single
+ *	open and on opening we load the counters. Counter zero is a 100Hz
+ *	cascade, into counter 1 which downcounts to reboot. When the counter
+ *	triggers counter 2 downcounts the length of the reset pulse which
+ *	set set to be as long as possible.
+ */
+
+static int lpc313x_wdt_open(struct inode *inode, struct file *file)
+{
+	struct lpc313x_wdt *wdt = &lpc313x_wdt;
+	if (test_and_set_bit(WDT_IN_USE, &wdt->status))
+		return -EBUSY;
+	clear_bit(WDT_OK_TO_CLOSE, &wdt->status);
+
+	/*
+	 *	Activate
+	 */
+	lpc313x_wdt_start(wdt);
+	return nonseekable_open(inode, file);
+}
+
+static ssize_t lpc313x_wdt_write(struct file *file, const char *data,
+					size_t len, loff_t *ppos)
+{
+	struct lpc313x_wdt *wdt = &lpc313x_wdt;
+	if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			clear_bit(WDT_OK_TO_CLOSE, &wdt->status);
+
+			for (i = 0; i != len; i++) {
+				char c;
+
+				if (get_user(c, data + i))
+					return -EFAULT;
+				if (c == 'V')
+					set_bit(WDT_OK_TO_CLOSE, &wdt->status);
+			}
+		}
+		lpc313x_wdt_keepalive(wdt);
+	}
+
+	return len;
+}
+
+static const struct watchdog_info ident = {
+	.options = WDIOF_CARDRESET | WDIOF_MAGICCLOSE |
+	    WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	.identity = "LPC313x Watchdog",
+};
+
+static long lpc313x_wdt_ioctl(struct file *file, unsigned int cmd,
+				unsigned long arg)
+{
+	int ret = -ENOTTY;
+	int time;
+	struct lpc313x_wdt * wdt = &lpc313x_wdt;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		ret = copy_to_user((struct watchdog_info *)arg, &ident,
+				   sizeof(ident)) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETSTATUS:
+		ret = put_user(0, (int *)arg);
+		break;
+
+	case WDIOC_GETBOOTSTATUS:
+		ret = put_user(wdt->boot_status, (int *)arg);
+		break;
+
+	case WDIOC_KEEPALIVE:
+		lpc313x_wdt_keepalive(wdt);
+		dev_vdbg(wdt->dev, "Hearbeat received.\n");
+		ret = 0;
+		break;
+
+	case WDIOC_SETTIMEOUT:
+		ret = get_user(time, (int *)arg);
+		if (ret)
+			break;
+
+		if (time <= 0 || time > MAX_HEARTBEAT) {
+			dev_err(wdt->dev, "Timeout value should be an "
+					"integer between 1 to %d\n", MAX_HEARTBEAT);
+			ret = -EINVAL;
+			break;
+		}
+
+		heartbeat = time;
+		lpc313x_wdt_keepalive(wdt);
+		dev_vdbg(wdt->dev, "Timeout set to: %d\n", time);
+		/* Fall through */
+
+	case WDIOC_GETTIMEOUT:
+		ret = put_user(heartbeat, (int *)arg);
+		break;
+	}
+	return ret;
+}
+
+static int lpc313x_wdt_release(struct inode *inode, struct file *file)
+{
+	struct lpc313x_wdt * wdt = &lpc313x_wdt;
+	if (!test_bit(WDT_OK_TO_CLOSE, &wdt->status))
+		dev_warn(wdt->dev, "Watchdog timer closed unexpectedly\n");
+
+	lpc313x_wdt_stop(wdt);
+	clear_bit(WDT_IN_USE, &wdt->status);
+	clear_bit(WDT_OK_TO_CLOSE, &wdt->status);
+
+	return 0;
+}
+
+static const struct file_operations lpc313x_wdt_fops = {
+	.owner 		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.unlocked_ioctl	= lpc313x_wdt_ioctl,
+	.open 		= lpc313x_wdt_open,
+	.write 		= lpc313x_wdt_write,
+	.release 	= lpc313x_wdt_release,
+};
+
+static struct miscdevice lpc313x_wdt_misc = {
+	.minor 	= WATCHDOG_MINOR,
+	.name 	= "watchdog",
+	.fops 	= &lpc313x_wdt_fops,
+};
+
+/**
+ *	lpc313x_wdt_isr:
+ *	@irq:		Interrupt number
+ *	@dev_id:	Unused as we don't allow multiple devices.
+ *
+ *	Handle an interrupt from the board. These are raised when the status
+ *	map changes in what the board considers an interesting way. That means
+ *	a failure condition occurring.
+ */
+
+static irqreturn_t lpc313x_wdt_isr(int irq, void *dev_id)
+{
+	/*
+	 *	Read the status register see what is up and
+	 *	then printk it.
+	 */
+	uint32_t status;
+	struct lpc313x_wdt * wdt = &lpc313x_wdt;
+
+	spin_lock(&wdt->lock);
+	status = readl(wdt->base + LPC313x_WDT_IR);
+
+	dev_vdbg(wdt->dev, "WDT status %d\n", status);
+
+	dev_crit(wdt->dev, "WDT timedout\n");
+
+	writel(status, wdt->base + LPC313x_WDT_IR);
+	spin_unlock(&wdt->lock);
+	return IRQ_HANDLED;
+}
+
+static int lpc313x_wdt_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct resource * res;
+	struct lpc313x_wdt * wdt = &lpc313x_wdt;
+	uint32_t size;
+
+	spin_lock_init(&wdt->lock);
+	wdt->dev = &pdev->dev;
+	wdt->irq = platform_get_irq(pdev, 0);
+	if (wdt->irq < 0) {
+		dev_err(&pdev->dev, "No IRQ resource found\n");
+		return -ENXIO;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "Unable to get resources.\n");
+		return -ENXIO;
+	}
+
+	size = res->end - res->start + 1;
+	if(devm_request_mem_region(&pdev->dev, 
+			res->start, size, pdev->name) == NULL) {
+		dev_err (&pdev->dev, "Requested memory region unavailable\n");
+		return -EBUSY;
+	}
+
+	wdt->base = devm_ioremap(&pdev->dev, res->start, size);
+	if (wdt->base == NULL) {
+		dev_err (&pdev->dev, "Unable to remap memory region\n");
+		return -ENOMEM;
+	}
+
+	ret = devm_request_irq(&pdev->dev, wdt->irq, lpc313x_wdt_isr, 
+			IRQF_DISABLED, pdev->name, NULL);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Unable to request IRQ%d\n", wdt->irq);
+		return ret;
+	}
+
+	ret = misc_register(&lpc313x_wdt_misc);
+	if (ret < 0) {
+		dev_err(&pdev->dev, " lpc313x_wdt : failed to register\n");
+		return ret;
+	}
+	platform_set_drvdata(pdev, wdt);
+
+	wdt->boot_status = (readl((void __iomem *) io_p2v(CGU_SB_PHYS)) & 0x1) ?
+		WDIOF_CARDRESET : 0;
+	lpc313x_wdt_stop(wdt);
+	dev_info(&pdev->dev, "Watchdog device driver initialized.\n");
+	return 0;
+}
+
+static int lpc313x_wdt_remove(struct platform_device *pdev)
+{
+	struct lpc313x_wdt * wdt = &lpc313x_wdt;
+
+	/* Stop the hardware */
+	lpc313x_wdt_stop(wdt);
+
+	misc_deregister(&lpc313x_wdt_misc);
+	/* All other resources are automatically de-allocated */
+	return 0;
+}
+
+static struct platform_driver lpc313x_wdt_driver = {
+	.probe = lpc313x_wdt_probe,
+	.remove = __devexit_p(lpc313x_wdt_remove),
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lpc313x-wdt",
+	},
+};
+
+static int __init lpc313x_wdt_init(void)
+{
+	return platform_driver_register(&lpc313x_wdt_driver);
+}
+
+static void __exit lpc313x_wdt_exit(void)
+{
+	platform_driver_unregister(&lpc313x_wdt_driver);
+}
+
+module_init(lpc313x_wdt_init);
+module_exit(lpc313x_wdt_exit);
+
+MODULE_AUTHOR("NXP Semiconductors");
+MODULE_DESCRIPTION("Driver for the LPC313x watchdog");
+MODULE_LICENSE("GPL");
+module_param(heartbeat, int, 0);
+MODULE_PARM_DESC(heartbeat,
+		 "Watchdog heartbeat period in seconds from 1 to "
+		 __MODULE_STRING(MAX_HEARTBEAT) ", default "
+		 __MODULE_STRING(DEFAULT_HEARTBEAT));
+
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout,
+		 "Set to 1 to keep watchdog running after device release");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_ALIAS("platform:lpc313x-wdt");
diff -purN linux-2.6.28.2/include/linux/i2c-pnx.h work_2.6.28.2/include/linux/i2c-pnx.h
--- linux-2.6.28.2/include/linux/i2c-pnx.h	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/include/linux/i2c-pnx.h	2010-03-15 16:57:43.000000000 -0700
@@ -21,7 +21,7 @@ struct i2c_pnx_mif {
 	int			mode;		/* Interface mode */
 	struct completion	complete;	/* I/O completion */
 	struct timer_list	timer;		/* Timeout */
-	char *			buf;		/* Data buffer */
+	u8 *			buf;		/* Data buffer */
 	int			len;		/* Length of data buffer */
 };
 
diff -purN linux-2.6.28.2/include/linux/serial_8250.h work_2.6.28.2/include/linux/serial_8250.h
--- linux-2.6.28.2/include/linux/serial_8250.h	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/include/linux/serial_8250.h	2010-03-15 17:05:34.000000000 -0700
@@ -28,6 +28,8 @@ struct plat_serial8250_port {
 	unsigned char	iotype;		/* UPIO_* */
 	unsigned char	hub6;
 	upf_t		flags;		/* UPF_* flags */
+ 	void		(*pm)(struct uart_port *, unsigned int state,
+ 			      unsigned int oldstate);
 };
 
 /*
diff -purN linux-2.6.28.2/include/linux/serial_core.h work_2.6.28.2/include/linux/serial_core.h
--- linux-2.6.28.2/include/linux/serial_core.h	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/include/linux/serial_core.h	2010-03-15 16:58:39.000000000 -0700
@@ -40,7 +40,8 @@
 #define PORT_NS16550A	14
 #define PORT_XSCALE	15
 #define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
-#define PORT_MAX_8250	16	/* max port ID */
+#define PORT_NXP16750   17
+#define PORT_MAX_8250	17	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
diff -purN linux-2.6.28.2/sound/soc/codecs/uda1380.c work_2.6.28.2/sound/soc/codecs/uda1380.c
--- linux-2.6.28.2/sound/soc/codecs/uda1380.c	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/sound/soc/codecs/uda1380.c	2010-03-16 10:01:46.000000000 -0700
@@ -433,7 +433,7 @@ static int uda1380_pcm_prepare(struct sn
 	}
 
 	/* FIXME enable DAC_CLK */
-	uda1380_write(codec, UDA1380_CLK, clk | R00_DAC_CLK);
+	uda1380_write(codec, UDA1380_CLK, clk);
 
 	return 0;
 }
diff -purN linux-2.6.28.2/sound/soc/Kconfig work_2.6.28.2/sound/soc/Kconfig
--- linux-2.6.28.2/sound/soc/Kconfig	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/sound/soc/Kconfig	2010-03-15 16:57:43.000000000 -0700
@@ -33,6 +33,7 @@ source "sound/soc/fsl/Kconfig"
 source "sound/soc/davinci/Kconfig"
 source "sound/soc/omap/Kconfig"
 source "sound/soc/blackfin/Kconfig"
+source "sound/soc/lpc313x/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff -purN linux-2.6.28.2/sound/soc/lpc313x/Kconfig work_2.6.28.2/sound/soc/lpc313x/Kconfig
--- linux-2.6.28.2/sound/soc/lpc313x/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/Kconfig	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,140 @@
+config SND_LPC313X_SOC
+        tristate "SoC Audio for the NXP LPC313X System-on-a-Chip"
+        depends on ARCH_LPC313X && SND_SOC
+        help
+          Say Y or M if you want to add audio support for the LPC313X.
+          You will also need to to select the audio interfaces to
+	  support below.
+
+config SND_LPC313X_SOC_I2S
+        bool
+
+config SND_LPC313X_SOC_I2S_UDA1380
+        bool "SoC Audio for the UDA1380 CODEC using I2S/I2C"
+        depends on SND_LPC313X_SOC
+        select I2C_PNX
+        select SND_LPC313X_SOC_I2S
+        select SND_SOC_UDA1380
+        help
+          Say Y here if you want to add support for SoC audio on the
+	  LPC313x with the UDA1380 CODEC. This requires an I2S channel
+	  and I2C channel connected to the I2C interface of the
+	  UDA1380 codec.
+
+config SND_USE_EA3131
+        bool "Enable audio configuration for the EA3131 board"
+        depends on SND_LPC313X_SOC
+	select SND_LPC313X_SOC_I2S_UDA1380
+	select SND_I2C1_CHANNEL_UDA1380
+	select SND_I2S_RX1_MASTER
+	select SND_I2S_TX1_MASTER
+	select SND_CODEC_FS256
+        help
+          Say Y to configuration audio for the EA3131 board. The EA3131
+	  board used the I2S1 channel with the UDA1380 audio CODEC and
+	  I2C on channel 1.
+
+config SND_I2C1_CHANNEL_UDA1380
+	bool "I2C1 channel connected to the UDA1380"
+	depends on SND_LPC313X_SOC_I2S_UDA1380
+	help
+	  Say Y here to use the I2C1 channel to communicate with the
+	  UDA1380 CODEC. Not selecting this option will use I2C0.
+
+choice
+	prompt "I2S RX channel configuration"
+	depends on SND_LPC313X_SOC_I2S
+	help
+	  This menu selects the I2S RX (record) channel configurations
+
+	config SND_I2S_RX0_MASTER
+	bool "I2S RX0 master mode"
+	help
+	  Select this option to only used the I2S RX0 channel for
+	  audio record in master mode.
+
+	config SND_I2S_RX1_MASTER
+	bool "I2S RX1 master mode"
+	help
+	  Select this option to only used the I2S RX1 channel for
+	  audio record in master mode.
+
+	config SND_I2S_RX0_SLAVE
+	bool "I2S RX0 slave mode"
+	help
+	  Select this option to only used the I2S RX0 channel for
+	  audio record in slave mode.
+
+	config SND_I2S_RX1_SLAVE
+	bool "I2S RX1 slave mode"
+	help
+	  Select this option to only used the I2S RX1 channel for
+	  audio record in slave mode.
+
+endchoice
+
+choice
+	prompt "I2S TX channel configuration"
+	depends on SND_LPC313X_SOC_I2S
+	help
+	  This menu selects the I2S TX (playback) channel configurations
+
+	config SND_I2S_TX0_MASTER
+	bool "I2S TX0 master mode"
+	help
+	  Select this option to only used the I2S TX0 channel for
+	  audio playback in master mode.
+
+	config SND_I2S_TX1_MASTER
+	bool "I2S TX1 master mode"
+	help
+	  Select this option to only used the I2S TX1 channel for
+	  audio record in playback mode.
+
+endchoice
+
+choice
+	prompt "WS clock divider"
+	depends on SND_LPC313X_SOC_I2S
+	help
+	  This divider is used to generate the WS rate from the CODEC
+	  clock. The CODEC clock may or may not be generated by the LPC313x.
+	  If it is, it is generated on the CLK_256FS pin. This divider is
+	  usually a factor of 256, 384, 512, 768, or 1024 times the sample
+	  frequency. Selected the correct multiplier here to have the audio
+	  driver generate the correct clock rates for the audio CODEC.
+
+	config SND_CODEC_FS256
+	bool "CODEC clock is 256FS"
+
+	config SND_CODEC_FS384
+	bool "CODEC clock is 384FS"
+
+	config SND_CODEC_FS512
+	bool "CODEC clock is 512FS"
+
+	config SND_CODEC_FS768
+	bool "CODEC clock is 768FS"
+
+	config SND_CODEC_FS1024
+	bool "CODEC clock is 1024FS"
+
+endchoice
+
+config SND_CODEC_NO_FS256_NEEDED
+        bool "Disable the CLK_FS256 signals"
+        depends on SND_LPC313X_SOC
+        help
+          For audio CODECs that do not need the FS256 clock, enable this
+	  option. These CODECs usually generate internal clocking based
+	  on the BCK and ES signals from the LPC313X I2S signals.
+
+config SND_USE_DMA_LINKLIST
+        bool "Use a DMA linked list instead of a circular buffer"
+	default y
+        depends on SND_LPC313X_SOC
+        help
+          The audio driver supports 2 DMA mode: circular buffer mode and
+	  DMA linked list mode. This option lets you choose which mode to
+	  use. DMA linked list mode is recommended.
+
diff -purN linux-2.6.28.2/sound/soc/lpc313x/lpc313x-i2s.c work_2.6.28.2/sound/soc/lpc313x/lpc313x-i2s.c
--- linux-2.6.28.2/sound/soc/lpc313x/lpc313x-i2s.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/lpc313x-i2s.c	2010-03-25 11:05:58.000000000 -0700
@@ -0,0 +1,411 @@
+/*
+ * sound/soc/lpc313x/lpc313x-i2s.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/cgu.h>
+#include <mach/board.h>
+#include <mach/registers.h>
+
+#include "lpc313x-i2s-clocking.h"
+#include "lpc313x-pcm.h"
+#include "lpc313x-i2s.h"
+
+#define I2S_NAME "lpc313x-i2s"
+
+/* All major audio rates are support and 16-bit I2S data is supported */
+#define LPC313X_I2S_RATES \
+    (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+     SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+     SNDRV_PCM_RATE_48000)
+#define LPC313X_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16)
+
+#define CH_PLAY 0
+#define CH_REC  1
+
+/* Structure that keeps I2S direction data */
+struct lpc313x_i2s_ch_info {
+	char *name;                 /* Name of this channel */
+	unsigned short ch_on;       /* Flag used to indicate if clocks are on */
+	unsigned short daifmt;
+	u32 ws_freq;
+	int i2s_ch;
+	enum i2s_supp_clks chclk;
+};
+
+/* Common I2S structure data */
+struct lpc313x_i2s_info {
+	spinlock_t lock;
+	unsigned short initialized;
+	struct lpc313x_i2s_ch_info ch_info[2];
+	u32 freq;
+};
+
+/* Common I2S structure data */
+static struct lpc313x_i2s_info i2s_info =
+{
+	.lock = __SPIN_LOCK_UNLOCKED(i2s_info.lock),
+	.initialized = 0,
+	.ch_info = 
+	{
+		[0] =
+		{
+#if defined (CONFIG_SND_I2S_TX0_MASTER)
+			.name  = "i2s0_play",
+			.chclk = CLK_TX_0,
+			.i2s_ch = I2S_CH_TX0,
+#else
+			.name  = "i2s1_play",
+			.chclk = CLK_TX_1,
+			.i2s_ch = I2S_CH_TX1,
+#endif
+			.ch_on = 0,
+		},
+		[1] =
+		{
+#if defined (CONFIG_SND_I2S_RX0_MASTER)
+			.name  = "i2s0_mrec",
+			.chclk = CLK_RX_0,
+			.i2s_ch = I2S_CH_RX0,
+#endif
+#if defined (CONFIG_SND_I2S_RX1_MASTER)
+			.name  = "i2s1_mrec",
+			.chclk = CLK_RX_1,
+			.i2s_ch = I2S_CH_RX1,
+#endif
+#if defined (SND_I2S_RX0_SLAVE)
+			.name  = "i2s0_srec",
+			/* Not supported yet, generate an error */
+			.i2s_ch = I2S_CH_RX0,
+#error
+#endif
+#if defined (SND_I2S_RX1_SLAVE)
+			.name  = "i2s1_srec",
+			/* Not supported yet, generate an error */
+			.i2s_ch = I2S_CH_RX1,
+#error
+#endif
+			.ch_on = 0,
+		},
+	},
+};
+
+static inline int lpc313x_get_ch_dir(struct snd_pcm_substream *substream)
+{
+	int dir = CH_REC;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dir = CH_PLAY;
+	}
+
+	return dir;
+}
+
+static void lpc313x_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	int dir = lpc313x_get_ch_dir(substream);
+
+	if (i2s_info.ch_info[dir].ch_on == 0) {
+		/* This channel is not enabled! */
+		pr_warning("%s: I2S channel is not on!\n", i2s_info.ch_info[dir].name);
+		return;
+	}
+
+	/* Channel specific shutdown */
+	lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
+	i2s_info.ch_info[dir].ch_on = 0;
+
+	/* Can we shutdown I2S interface to save some power? */
+	if (i2s_info.ch_info[1 - dir].ch_on != 0) {
+		/* Other channel is busy, exit without shutting down main clock */
+		return;
+	}
+
+	/* Safe to shut down */
+	if (i2s_info.initialized == 0) {
+		/* Nothing is enabled! */
+		pr_warning("I2S shutdown (%s) when nothing is enabled!\n",
+			i2s_info.ch_info[dir].name);
+		return;
+	}
+
+	/* Disable I2S register access clock */
+	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 0);
+
+	i2s_info.initialized = 0;
+}
+
+static int lpc313x_i2s_startup(struct snd_pcm_substream *substream)
+{
+	int dir = lpc313x_get_ch_dir(substream);
+
+	/* Select master/slave mode for RX channel */
+	if (dir == CH_REC) {
+#if defined (CONFIG_SND_I2S_RX0_SLAVE) | defined (CONFIG_SND_I2S_RX1_SLAVE)
+		I2S_CFG_MUX_SETTINGS = 0;
+#endif
+#if defined (CONFIG_SND_I2S_RX0_MASTER)
+		I2S_CFG_MUX_SETTINGS = I2S_RXO_SELECT_MASTER;
+#endif
+#if defined (CONFIG_SND_I2S_RX1_MASTER)
+		I2S_CFG_MUX_SETTINGS = I2S_RX1_SELECT_MASTER;
+#endif
+	}
+
+	if (i2s_info.ch_info[dir].ch_on != 0) {
+		/* This channel already enabled! */
+		pr_warning("%s: I2S channel is busy!\n", i2s_info.ch_info[dir].name);
+		return -EBUSY;
+	}
+
+	/* Initialize I2S interface */
+	if (i2s_info.initialized == 0) {
+		/* Enable I2S register access clock */
+		cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
+		cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
+
+		i2s_info.initialized = 1;
+	}
+
+	/* Channel specific init, ok to leave the clocks off for now */
+	i2s_info.ch_info[dir].ch_on = 1;
+	lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
+
+	/* Mask all interrupts for the I2S channel */
+	I2S_CH_INT_MASK(i2s_info.ch_info[dir].i2s_ch) = I2S_FIFO_ALL_MASK;
+
+	return 0;
+}
+
+static int lpc313x_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				      int clk_id, unsigned int freq, int dir)
+{
+	/* Will use in HW params later */
+//	i2s_info.ch_info[cpu_dai->id].ws_freq = freq;
+	i2s_info.ch_info[CH_REC].ws_freq = freq;
+	i2s_info.ch_info[CH_PLAY].ws_freq = freq;
+	return 0;
+}
+
+static int lpc313x_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+				   unsigned int fmt)
+{
+	/* Will use in HW params later */
+//	i2s_info.ch_info[cpu_dai->id].daifmt = fmt;
+	i2s_info.ch_info[CH_REC].daifmt = fmt;
+	i2s_info.ch_info[CH_PLAY].daifmt = fmt;
+
+	return 0;
+}
+
+static int lpc313x_i2s_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+				      int div_id, int div)
+{
+	/* This function isn't used */
+	(void) cpu_dai;
+	(void) div_id;
+	(void) div;
+
+	return 0;
+}
+
+static int lpc313x_i2s_hw_params(struct snd_pcm_substream *substream,
+			         struct snd_pcm_hw_params *params)
+{
+	int dir = lpc313x_get_ch_dir(substream);
+	u32 tmp;
+
+	/* Setup the I2S data format */
+	tmp = 0;
+	switch (i2s_info.ch_info[dir].daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			spin_lock_irq(&i2s_info.lock);
+			tmp = I2S_FORMAT_SETTINGS &
+				~I2S_SET_FORMAT(i2s_info.ch_info[dir].i2s_ch,
+				I2S_FORMAT_MASK);
+			I2S_FORMAT_SETTINGS = tmp | I2S_SET_FORMAT(i2s_info.ch_info[dir].i2s_ch,
+				I2S_FORMAT_I2S);
+			spin_unlock_irq(&i2s_info.lock);
+			break;
+
+		default:
+			pr_warning("%s: Unsupported audio data format\n",
+				i2s_info.ch_info[dir].name);
+			return -EINVAL;
+	}
+
+#if defined (CONFIG_SND_DEBUG_VERBOSE)
+	pr_info("Desired clock rate : %d\n", i2s_info.ch_info[dir].ws_freq);
+	pr_info("Channels           : %d\n", params_channels(params));
+	pr_info("Data format        : %d\n", i2s_info.ch_info[dir].daifmt);
+#endif
+
+	/* The playback and record rates are shared, so just set the CODEC clock
+	   to the selected rate (will actually generate 256 * rate) */
+	i2s_info.freq = i2s_info.ch_info[dir].ws_freq;
+	if (lpc313x_main_clk_rate(i2s_info.freq) == 0)
+	{
+		pr_warning("Unsupported audio data rate (%d)\n",
+			i2s_info.freq);
+		return -EINVAL;
+	}
+
+	/* Now setup the selected channel clocks (WS and BCK) */
+	if (lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, i2s_info.freq,
+		(i2s_info.freq * 32)) == 0)
+	{
+		pr_warning("Unsupported channel data rates (ws=%d, bck=%d)\n",
+			i2s_info.freq, (i2s_info.freq * 32));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lpc313x_i2s_prepare(struct snd_pcm_substream *substream)
+{
+	/* Nothing to do here */
+	return 0;
+}
+
+
+static int lpc313x_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		break;
+
+	default:
+		pr_warning("lpc313x_i2s_triggers: Unsupported cmd: %d\n",
+				cmd);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int lpc313x_i2s_suspend(struct platform_device *pdev,
+			       struct snd_soc_dai *cpu_dai)
+{
+	/* Shutdown active clocks */
+	if (i2s_info.ch_info[CH_PLAY].ch_on != 0) {
+		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk, 0, 0);
+	}
+	if (i2s_info.ch_info[CH_REC].ch_on != 0) {
+		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk, 0, 0);
+	}
+
+	/* Disable I2S register access clock */
+	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 0);
+	/* shutdown main clocks */
+	lpc313x_main_clk_rate(0);
+
+	return 0;
+}
+
+static int lpc313x_i2s_resume(struct platform_device *pdev,
+			      struct snd_soc_dai *cpu_dai)
+{
+	/* resume main clocks */
+	lpc313x_main_clk_rate(i2s_info.freq);
+	/* Enable I2S register access clock */
+	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
+
+	/* resume active clocks */
+	if (i2s_info.ch_info[CH_PLAY].ch_on != 0) {
+		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk,
+		i2s_info.ch_info[CH_PLAY].ws_freq, (i2s_info.freq * 32));
+	}
+	if (i2s_info.ch_info[CH_REC].ch_on != 0) {
+		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk,
+		i2s_info.ch_info[CH_REC].ws_freq, (i2s_info.freq * 32));
+	}
+
+	return 0;
+}
+
+#else
+#define lpc313x_i2s_suspend	NULL
+#define lpc313x_i2s_resume	NULL
+#endif
+
+struct snd_soc_dai lpc313x_i2s_dai = {
+	 .name = I2S_NAME,
+	 .id = 0,
+	 .type = SND_SOC_DAI_PCM,
+	 .suspend = lpc313x_i2s_suspend,
+	 .resume = lpc313x_i2s_resume,
+	 .playback = {
+		      .channels_min = 2,
+		      .channels_max = 2,
+		      .rates = LPC313X_I2S_RATES,
+		      .formats = LPC313X_I2S_FORMATS,
+		      },
+	 .capture = {
+		     .channels_min = 2,
+		     .channels_max = 2,
+		     .rates = LPC313X_I2S_RATES,
+		     .formats = LPC313X_I2S_FORMATS,
+		     },
+	 .ops = {
+		 .startup = lpc313x_i2s_startup,
+		 .shutdown = lpc313x_i2s_shutdown,
+		 .prepare = lpc313x_i2s_prepare,
+		.trigger = lpc313x_i2s_trigger,
+		 .hw_params = lpc313x_i2s_hw_params,
+		 },
+	 .dai_ops = {
+		     .set_sysclk = lpc313x_i2s_set_dai_sysclk,
+		     .set_fmt = lpc313x_i2s_set_dai_fmt,
+		     .set_clkdiv = lpc313x_i2s_set_dai_clkdiv,
+		     },
+	 .private_data = &i2s_info,
+};
+EXPORT_SYMBOL_GPL(lpc313x_i2s_dai);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC LPC313X I2S interface");
+MODULE_LICENSE("GPL");
+
diff -purN linux-2.6.28.2/sound/soc/lpc313x/lpc313x-i2s-clocking.c work_2.6.28.2/sound/soc/lpc313x/lpc313x-i2s-clocking.c
--- linux-2.6.28.2/sound/soc/lpc313x/lpc313x-i2s-clocking.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/lpc313x-i2s-clocking.c	2010-03-24 18:45:04.000000000 -0700
@@ -0,0 +1,360 @@
+/*
+ * sound/soc/lpc313x/lpc313x-i2s-clocking.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ * Note: Fractional clock divider domains are defined in the bootloader
+ * code. As of the time this driver was developed, the fractional
+ * divider groupings are mapped as follows:
+ *     Group 17 -> TX0 WS, TX1, WS, RX0 WS, RX1 WS
+ *     Group 18 -> TX0 BCK, TX1 BCK
+ *     Group 19 -> CLK_256FS, TX_CLK0
+ *     Group 20 -> RX0 BCK, RX1 BCK
+ *
+ * The driver supports the following sample rates and FS clock
+ * multipliers. These rates are dependent on an external 12MHz
+ * oscillator input. All these rates are generated from a small set of
+ * PLL frequencies and a fractional divider. Some of the rates can be
+ * generated by more than 1PLL frequency.
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  256FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  384FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  512FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  768FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  1024FS    Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ */
+
+#include <linux/io.h>
+
+#include <mach/cgu.h>
+#include <mach/board.h>
+#include <mach/registers.h>
+#include "lpc313x-i2s-clocking.h"
+
+struct i2s_clk_setup {
+	u32 target_codec_rate;
+	u32 real_fs_codec_rate;
+};
+static struct i2s_clk_setup i2s_clk_state;
+
+/*
+ * clock setup enable/disable selection arrays - these clocks are enabled as a group
+ * for a specific I2S channel
+ */
+static CGU_CLOCK_ID_T rx0clks[] = {
+	CGU_SB_I2SRX_IF_0_PCLK_ID,
+	CGU_SB_I2SRX_FIFO_0_PCLK_ID,
+	CGU_SB_I2SRX_BCK0_N_ID,
+	CGU_SB_I2SRX_WS0_ID,
+	CGU_SB_I2SRX_BCK0_ID,
+	CGU_SB_INVALID_CLK_ID
+};
+static CGU_CLOCK_ID_T tx0clks[] = {
+	CGU_SB_I2STX_IF_0_PCLK_ID,
+	CGU_SB_I2STX_FIFO_0_PCLK_ID,
+	CGU_SB_I2STX_BCK0_N_ID,
+	CGU_SB_I2STX_WS0_ID,
+	CGU_SB_INVALID_CLK_ID
+};
+static CGU_CLOCK_ID_T rx1clks[] = {
+	CGU_SB_I2SRX_IF_1_PCLK_ID,
+	CGU_SB_I2SRX_FIFO_1_PCLK_ID,
+	CGU_SB_I2SRX_BCK1_N_ID,
+	CGU_SB_I2SRX_WS1_ID,
+	CGU_SB_I2SRX_BCK1_ID,
+	CGU_SB_INVALID_CLK_ID
+};
+static CGU_CLOCK_ID_T tx1clks[] = {
+	CGU_SB_I2STX_IF_1_PCLK_ID,
+	CGU_SB_I2STX_FIFO_1_PCLK_ID,
+	CGU_SB_I2STX_BCK1_N_ID,
+	CGU_SB_I2STX_WS1_ID,
+	CGU_SB_INVALID_CLK_ID
+};
+
+typedef CGU_CLOCK_ID_T * P_CGU_CLOCK_ID_T;
+static P_CGU_CLOCK_ID_T clkarray[CLK_TX_1 + 1] = {
+	rx0clks,
+	tx0clks,
+	rx1clks,
+	tx1clks
+};
+
+/* 48K*1024 sysclk rate settings (12M oscillator input),
+   49152000Hz FS clock, error .003999Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS     48          32  24         16  12        8
+ *  256FS     24          16  12         8   6         4
+ *  384FS     16              8              4         
+ *  512FS     12          8              4   3         2
+ *  768FS     8               4              2
+ *  1024FS    6           4   3          2             1
+*/
+static CGU_HPLL_SETUP_T pllsetup_48K_1024 = {
+	CGU_FIN_SELECT_FFAST, 514, 21708, 5, 0, 44, 21, 0, (48000 * 1024)
+};
+
+/* 48K*768 sysclk rate settings (12M oscillator input),
+   36864000Hz FS clock, error .003999Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS     36          24  18         12            6
+ *  256FS     18          12  9          6             3
+ *  384FS     12          8   6          4   3         2
+ *  512FS     9           6                            
+ *  768FS     6           4              2             1
+ *  1024FS                                             
+*/
+static CGU_HPLL_SETUP_T pllsetup_48K_768 = {
+	CGU_FIN_SELECT_FFAST, 514, 21299, 21, 0, 44, 22, 0, (48000 * 768)
+};
+
+/* 44.1K*1024 sysclk rate settings (12M oscillator input),
+   45158400Hz FS clock, error .0131999Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS         32              16              8
+ *  256FS         16              8               4
+ *  384FS                                         
+ *  512FS         8               4               2
+ *  768FS                                         
+ *  1024FS        4               2               1
+*/
+static CGU_HPLL_SETUP_T pllsetup_44_1K_1024 = {
+	CGU_FIN_SELECT_FFAST, 770, 8191, 2, 0, 16, 8, 0, (44100 * 1024)
+};
+
+/* 44.1K*768 sysclk rate settings (12M oscillator input),
+   33868800Hz FS clock, error .0099Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS         24              12              6
+ *  256FS         12              6               3
+ *  384FS         8               4               2
+ *  512FS         6               3                
+ *  768FS         4               2               1
+ *  1024FS        3                               
+*/
+static CGU_HPLL_SETUP_T pllsetup_44_1K_768 = {
+	CGU_FIN_SELECT_FFAST, 514, 19660, 11, 0, 48, 23, 0, (44100 * 768)
+};
+
+/* 32K*1024 sysclk rate settings (12M oscillator input),
+   32768000Hz FS clock, error .01638Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS     32              16             8    
+ *  256FS     16              8              4    
+ *  384FS                                         
+ *  512FS     8               4              2    
+ *  768FS                                         
+ *  1024FS                                   1    
+*/
+static CGU_HPLL_SETUP_T pllsetup_32K_1024 = {
+	CGU_FIN_SELECT_FFAST, 770, 32765, 21, 0, 20, 10, 0, (32000 * 1024)
+};
+
+static CGU_HPLL_SETUP_T *ppll_list[] = {
+	&pllsetup_32K_1024,
+	&pllsetup_44_1K_768,
+	&pllsetup_44_1K_1024,
+	&pllsetup_48K_768,
+	&pllsetup_48K_1024,
+	NULL
+};
+
+static const u32 fsdiv =
+#if defined (CONFIG_SND_CODEC_FS256)
+	256;
+#elif defined (CONFIG_SND_CODEC_FS384)
+	384;
+#elif defined (CONFIG_SND_CODEC_FS512)
+	512;
+#elif defined (CONFIG_SND_CODEC_FS768)
+	768;
+#elif defined (CONFIG_SND_CODEC_FS1024)
+	1024;
+#endif
+
+static u32 lpc313x_set_best_rate(u32 freq)
+{
+	CGU_FDIV_SETUP_T clk_div;
+	u32 diff;
+	int i = 0;
+
+	clk_div.stretch = 1;
+
+	while (ppll_list[i] != NULL)
+	{
+		/* Find match divider based on current FS divider and rate */
+		diff = ppll_list[i]->freq / fsdiv;
+		clk_div.m = diff / freq;
+		diff = diff - (freq * clk_div.m);
+
+		if (diff == 0)
+		{
+			if (clk_div.m <= 1)
+			{
+				clk_div.n = 0;
+				clk_div.m = 0;
+			}
+			else
+			{
+				clk_div.n = 1;
+			}
+
+			/* Set PLL rate and divider for CODEC clock */
+			i2s_clk_state.real_fs_codec_rate = ppll_list[i]->freq;
+			cgu_hpll_config(CGU_HPLL0_ID, ppll_list[i]);
+			cgu_fdiv_config(19, clk_div, 1);
+			return freq;
+		}
+
+		i++;
+	}
+
+	return 0;
+}
+
+/*
+ * Sets up the audio PLL to generate a frequency as close as possible to
+ * the target clkrate frequency
+ */
+static u32 lpc313x_set_codec_freq(u32 freq)
+{
+	if (freq == 0)
+	{
+		/* Disable the required audio CODEC clocks */
+		cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 0);
+		cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 0);
+	}
+	else if (freq != i2s_clk_state.target_codec_rate)
+	{
+		/* Disable the required audio CODEC clocks during frequency change */
+		cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 0);
+		cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 0);
+
+		freq = lpc313x_set_best_rate(freq);
+		if (freq > 0)
+		{
+#if !defined (CONFIG_SND_CODEC_NO_FS256_NEEDED)
+			/* Enable clock */
+			cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 1);
+#endif
+			cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 1);
+		}
+	}
+
+	i2s_clk_state.target_codec_rate = freq;
+
+	return freq;
+}
+
+/*
+ * Start or stop a channel's clocks
+ */
+static void lpc313x_ch_clk_disen(enum i2s_supp_clks chclk, int en)
+{
+	int i = 0;
+	P_CGU_CLOCK_ID_T pclks = (P_CGU_CLOCK_ID_T) clkarray[chclk];
+
+	while (pclks[i] != CGU_SB_INVALID_CLK_ID)
+	{
+		cgu_clk_en_dis(pclks[i], en);
+		i++;
+	}
+}
+
+/*
+ * Sets up the channel bit clock to generate a rate as close as possible
+ * to the target clkrate frequency
+ */
+static u32 lpc313x_set_ch_freq(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
+{
+	CGU_FDIV_SETUP_T ch_div;
+
+	if (ws_freq == 0)
+	{
+		/* Turn channel clock off */
+		lpc313x_ch_clk_disen(chclk, 0);
+		bit_freq = 0;
+	}
+	else
+	{
+		/* Stop channel clocks for the change */
+		lpc313x_ch_clk_disen(chclk, 0);
+
+		ch_div.stretch = 1;
+		ch_div.n = 1;
+
+		/* Find divider to generate target WS frequency from PLL */
+		ch_div.m = i2s_clk_state.real_fs_codec_rate / ws_freq;
+		cgu_fdiv_config(17, ch_div, 1);
+
+		/* Find divider to generate target bck frequency from PLL */
+		ch_div.m = i2s_clk_state.real_fs_codec_rate / bit_freq;
+
+		if ((chclk == CLK_RX_0) || (chclk == CLK_RX_1)) {
+			cgu_fdiv_config(20, ch_div, 1);
+		}
+		if ((chclk == CLK_TX_0) || (chclk == CLK_TX_1)) {
+			cgu_fdiv_config(18, ch_div, 1);
+		}
+
+		/* Enable channel clock */
+		lpc313x_ch_clk_disen(chclk, 1);
+	}
+
+	return ws_freq;
+}
+
+/*
+ * Set the audio CODEC clock rate or 0 to disable the clock, returns
+ * the actual programmed clock rate. The programmed rate is generated on
+ * the FS256 pin has a rate of (256 * clkrate).
+ */
+u32 lpc313x_main_clk_rate(u32 freq)
+{
+	u32 ret = 0;
+	/* Compute and set proper divider */
+	ret = lpc313x_set_codec_freq(freq);
+#if defined (CONFIG_SND_DEBUG_VERBOSE)
+	pr_info("LPC313x ASOC main clock : %d (%d)\n", 
+		i2s_clk_state.target_codec_rate,
+		i2s_clk_state.real_fs_codec_rate);
+#endif
+	return ret;
+}
+
+/*
+ * Set a specific channel's bit clock and word select rates. his applies
+ * to the channel's WS and BCLK signals. Returns the actual programmed
+ * WS clock rate.
+ */
+u32 lpc313x_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
+{
+	/* Compute and set proper divider */
+	return lpc313x_set_ch_freq(chclk, ws_freq, bit_freq);
+}
+
diff -purN linux-2.6.28.2/sound/soc/lpc313x/lpc313x-i2s-clocking.h work_2.6.28.2/sound/soc/lpc313x/lpc313x-i2s-clocking.h
--- linux-2.6.28.2/sound/soc/lpc313x/lpc313x-i2s-clocking.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/lpc313x-i2s-clocking.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,66 @@
+/*
+ * sound/soc/lpc313x/lpc313x-i2s-clocking.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ * This file provides the necessary clocking and control functions for the
+ * sound drivers on the LPC313X. These functions include clock enable and
+ * disable, and clock frequency setup on the WS, BCLK, and SYSCLK pins.
+ *
+ * Pin mapping is as follows:
+ *     Chip signal name         CODEC signal name
+ *     CLK_256FS                Audio CODEC clock
+ *     I2SRX_WS0                I2S RX channel 0 Word select clock
+ *     I2SRX_WS1                I2S RX channel 1 Word select clock
+ *     I2STX_WS0                I2S TX channel 0 Word select clock
+ *     I2STX_WS1                I2S TX channel 1 Word select clock
+ *     I2SRX_BCK0               I2S RX channel 0 serial data bit clock
+ *     I2SRX_BCK1               I2S RX channel 1 serial data bit clock
+ *     I2STX_BCK0               I2S TX channel 0 serial data bit clock
+ *     I2STX_BCK1               I2S TX channel 1 serial data bit clock
+ */
+
+#ifndef __LPC313X_I2S_CLOCKING_H
+#define __LPC313X_I2S_CLOCKING_H
+
+#include <linux/types.h>
+
+/*
+ * I2S supported clock groupings
+ */
+enum i2s_supp_clks {CLK_RX_0, CLK_TX_0, CLK_RX_1, CLK_TX_1};
+
+/*
+ * Set the audio CODEC clock rate or 0 to disable the clock, returns
+ * the actual programmed clock rate. The programmed rate is generated on
+ * the FS256 pin has a rate of (256 * clkrate).
+ */
+u32 lpc313x_main_clk_rate(u32 clkrate);
+
+/*
+ * Set a specific channel's bit clock and word select rates. his applies
+ * to the channel's WS and BCLK signals. Returns the actual programmed
+ * WS clock rate.
+ */
+u32 lpc313x_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq);
+
+#endif /* __LPC313X_I2S_CLOCKING */
diff -purN linux-2.6.28.2/sound/soc/lpc313x/lpc313x-i2s.h work_2.6.28.2/sound/soc/lpc313x/lpc313x-i2s.h
--- linux-2.6.28.2/sound/soc/lpc313x/lpc313x-i2s.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/lpc313x-i2s.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,31 @@
+/*
+ * sound/soc/lpc313x/lpc313x-i2s.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __SOUND_SOC_LPC313X_I2S_H
+#define __SOUND_SOC_LPC313X_I2S_H
+
+#include <linux/types.h>
+
+extern struct snd_soc_dai lpc313x_i2s_dai;
+
+#endif
+
diff -purN linux-2.6.28.2/sound/soc/lpc313x/lpc313x-pcm.c work_2.6.28.2/sound/soc/lpc313x/lpc313x-pcm.c
--- linux-2.6.28.2/sound/soc/lpc313x/lpc313x-pcm.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/lpc313x-pcm.c	2010-03-25 11:07:19.000000000 -0700
@@ -0,0 +1,576 @@
+/*
+ * sound/soc/lpc313x/lpc313x-pcm.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <mach/dma.h>
+#include "lpc313x-pcm.h"
+
+#define SND_NAME "lpc313x-audio"
+static u64 lpc313x_pcm_dmamask = DMA_BIT_MASK(32);
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+/* The DMA controller in the LPC31XX has limited interrupt support
+   for DMA. A timer is used instead to update the current buffer
+   position */
+#define MIN_PERIODS 8
+#define MAX_PERIODS 32
+#define DMA_LIST_SIZE (MAX_PERIODS * sizeof(dma_sg_ll_t))
+#define MIN_BYTES_PERIOD 2048
+#define MAX_BYTES_PERIOD 4096
+#define MINTICKINC ((MIN_BYTES_PERIOD * HZ * (MIN_PERIODS / 4)) / (48000 * 2 * 2))
+
+#else
+#define MIN_PERIODS 2
+#define MAX_PERIODS 2
+#define MIN_BYTES_PERIOD (32 * 1024)
+#define MAX_BYTES_PERIOD (32 * 1024)
+#endif
+
+#if defined (CONFIG_SND_I2S_TX0_MASTER)
+#define TX_FIFO_ADDR (I2S_PHYS + 0x0E0)
+#define TX_DMA_CHCFG DMA_SLV_I2STX0_L
+#else
+#define TX_FIFO_ADDR (I2S_PHYS + 0x160)
+#define TX_DMA_CHCFG DMA_SLV_I2STX1_L
+#endif
+#if defined (CONFIG_SND_I2S_RX0_MASTER) | defined (CONFIG_SND_I2S_RX0_SLAVE)
+#define RX_FIFO_ADDR (I2S_PHYS + 0x1E0)
+#define RX_DMA_CHCFG DMA_SLV_I2SRX0_L
+#else
+#define RX_FIFO_ADDR (I2S_PHYS + 0x260)
+#define RX_DMA_CHCFG DMA_SLV_I2SRX1_L
+#endif
+
+static const struct snd_pcm_hardware lpc313x_pcm_hardware = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_RESUME |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats = (SND_SOC_DAIFMT_I2S),
+	.period_bytes_min = MIN_BYTES_PERIOD,
+	.period_bytes_max = MAX_BYTES_PERIOD,
+	.periods_min = MIN_PERIODS,
+	.periods_max = MAX_PERIODS,
+	.buffer_bytes_max = (MAX_PERIODS * MAX_BYTES_PERIOD)
+};
+
+struct lpc313x_dma_data {
+	dma_addr_t dma_buffer;	/* physical address of DMA buffer */
+	dma_addr_t dma_buffer_end; /* first address beyond DMA buffer */
+	size_t period_size;
+	int num_periods;
+
+	/* DMA configuration and support */
+	int dmach;
+	volatile dma_addr_t dma_cur;
+	u32 dma_cfg_base;
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+	dma_sg_ll_t *p_sg_cpu;
+	dma_sg_ll_t *p_sg_dma;
+	struct timer_list timer[2];
+	int inccount;
+#endif
+};
+
+/*
+ * DMA ISR - occurs when a new DMA buffer is needed
+ */
+static void lpc313x_pcm_dma_irq(int ch, dma_irq_type_t dtype, void *handle) {
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *) handle;
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc313x_dma_data *prtd = rtd->private_data;
+
+	(void) dtype;
+	(void) ch;
+
+	/* Last buffer is finished */
+	prtd->dma_cur += prtd->period_size;
+	if (prtd->dma_cur >= prtd->dma_buffer_end)
+		prtd->dma_cur = prtd->dma_buffer;
+
+	/* Tell audio system more buffer space is available */
+	snd_pcm_period_elapsed(substream);
+}
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+static void lpc313x_check_dmall(unsigned long data) {
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *) data;
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc313x_dma_data *prtd = rtd->private_data;
+
+	/* Determine buffer position from current DMA position. We don't need
+	   the exact address, just the last finished period */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mod_timer(&prtd->timer[0], jiffies + MINTICKINC);
+		prtd->dma_cur = (dma_addr_t) DMACH_SRC_ADDR(prtd->dmach - 1);
+	}
+	else {
+		mod_timer(&prtd->timer[1], jiffies + MINTICKINC);
+		prtd->dma_cur = (dma_addr_t) DMACH_DST_ADDR(prtd->dmach - 1);
+	}
+
+	/* Tell audio system more buffer space is available */
+	snd_pcm_period_elapsed(substream);
+}
+#endif
+
+static int lpc313x_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *dmabuf = &substream->dma_buffer;
+	size_t size = lpc313x_pcm_hardware.buffer_bytes_max;
+
+	dmabuf->dev.type = SNDRV_DMA_TYPE_DEV;
+	dmabuf->dev.dev = pcm->card->dev;
+	dmabuf->private_data = NULL;
+	dmabuf->area = dma_alloc_coherent(pcm->card->dev, size,
+					  &dmabuf->addr, GFP_KERNEL);
+
+	pr_debug("lpc313x-pcm:"
+		"preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
+		(void *) dmabuf->area,
+		(void *) dmabuf->addr,
+		size);
+
+	if (!dmabuf->area)
+		return -ENOMEM;
+
+	dmabuf->bytes = size;
+
+	return 0;
+}
+
+/*
+ * PCM operations
+ */
+static int lpc313x_pcm_hw_params(struct snd_pcm_substream *substream,
+			         struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc313x_dma_data *prtd = runtime->private_data;
+
+	/* this may get called several times by oss emulation
+	 * with different params
+	 */
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+
+	prtd->dma_buffer = runtime->dma_addr;
+	prtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;
+	prtd->period_size = params_period_bytes(params);
+	prtd->num_periods = params_periods(params);
+
+	return 0;
+}
+
+static int lpc313x_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+
+	/* Return the DMA channel */
+	if (prtd->dmach != -1) {
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+		dma_release_sg_channel(prtd->dmach);
+
+		/* Return the linked list area */
+		dma_free_coherent(substream->pcm->card->dev, 
+			DMA_LIST_SIZE, prtd->p_sg_cpu, (dma_addr_t)prtd->p_sg_dma);
+#else
+		dma_release_channel((unsigned int) prtd->dmach);
+#endif
+
+		prtd->dmach = -1;
+	}
+
+	return 0;
+}
+
+static int lpc313x_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+
+	/* Setup DMA channel */
+	if (prtd->dmach == -1) {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+			prtd->dmach = dma_request_sg_channel("I2STX",
+				lpc313x_pcm_dma_irq, substream, 0);
+			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
+				DMA_CFG_RD_SLV_NR(0) | DMA_CFG_CMP_CH_EN |
+				DMA_CFG_WR_SLV_NR(TX_DMA_CHCFG) |
+				DMA_CFG_CMP_CH_NR(prtd->dmach);
+
+#else
+			prtd->dmach = dma_request_channel("I2STX",
+				lpc313x_pcm_dma_irq, substream);
+			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
+				DMA_CFG_RD_SLV_NR(0) | DMA_CFG_CIRC_BUF |
+				DMA_CFG_WR_SLV_NR(TX_DMA_CHCFG);
+#endif
+		}
+		else {
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+			prtd->dmach = dma_request_sg_channel("I2SRX",
+				lpc313x_pcm_dma_irq, substream, 0);
+			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
+				DMA_CFG_WR_SLV_NR(0) | DMA_CFG_CMP_CH_EN |
+				DMA_CFG_RD_SLV_NR(RX_DMA_CHCFG) |
+				DMA_CFG_CMP_CH_NR(prtd->dmach);
+
+#else
+			prtd->dmach = dma_request_channel("I2SRX",
+				lpc313x_pcm_dma_irq, substream);
+			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
+				DMA_CFG_WR_SLV_NR(0) | DMA_CFG_CIRC_BUF |
+				DMA_CFG_RD_SLV_NR(RX_DMA_CHCFG);
+#endif
+		}
+
+		if (prtd->dmach < 0) {
+			pr_err("Error allocating DMA channel\n");
+			return prtd->dmach;
+		}
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+		/* Allocate space for a DMA linked list */
+		prtd->p_sg_cpu = (dma_sg_ll_t *) dma_alloc_coherent(
+			substream->pcm->card->dev, DMA_LIST_SIZE,
+			(dma_addr_t *) &prtd->p_sg_dma, GFP_KERNEL);
+
+		if (prtd->p_sg_cpu == NULL) {
+			pr_err("Error allocating DMA sg list\n");
+			dma_release_sg_channel(prtd->dmach);
+			prtd->dmach = -1;
+			return -ENOMEM;
+		}
+#endif
+	}
+
+	return 0;
+}
+
+int dma_stop_channel_sg (unsigned int chn);
+
+static int lpc313x_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc313x_dma_data *prtd = rtd->private_data;
+	int ret = 0;
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+	int i, tch;
+	u32 addr;
+	dma_sg_ll_t *p_sg_cpuw, *p_sg_dmaw;
+	unsigned long timeout;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		tch = 0;
+	}
+	else {
+		tch = 1;
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->dma_cur = prtd->dma_buffer;
+		p_sg_cpuw = prtd->p_sg_cpu;
+		p_sg_dmaw = prtd->p_sg_dma;
+
+		/* Build a linked list that wraps around */
+		addr = (u32) prtd->dma_buffer;
+		for (i = 0; i < prtd->num_periods; i++) {
+			p_sg_cpuw->setup.trans_length = (prtd->period_size / 4) - 1;
+			p_sg_cpuw->setup.cfg = prtd->dma_cfg_base;
+			p_sg_cpuw->next_entry = (u32) (p_sg_dmaw + 1);
+
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				p_sg_cpuw->setup.src_address = addr;
+				p_sg_cpuw->setup.dest_address = TX_FIFO_ADDR;
+			}
+			else {
+				p_sg_cpuw->setup.dest_address = addr;
+				p_sg_cpuw->setup.src_address = RX_FIFO_ADDR;
+			}
+
+			/* Wrap end of list back to start? */
+			if (i == (prtd->num_periods - 1))
+				p_sg_cpuw->next_entry = (u32) prtd->p_sg_dma;
+
+			p_sg_cpuw++;
+			p_sg_dmaw++;
+			addr += prtd->period_size;
+		}
+
+		/* Add and start audio data position timer */
+		init_timer(&prtd->timer[tch]);
+		prtd->timer[tch].data = (unsigned long) substream;
+		prtd->timer[tch].function = lpc313x_check_dmall;
+		prtd->timer[tch].expires = jiffies + MINTICKINC;
+		add_timer(&prtd->timer[tch]);
+
+		/* Program DMA channel and start it */
+		dma_prog_sg_channel(prtd->dmach, (u32) prtd->p_sg_dma);
+		dma_set_irq_mask(prtd->dmach, 1, 1);
+#else
+	dma_setup_t dmasetup;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->dma_cur = prtd->dma_buffer;
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			dmasetup.src_address = (u32) prtd->dma_buffer;
+			dmasetup.dest_address = TX_FIFO_ADDR;
+		}
+		else {
+			dmasetup.dest_address = (u32) prtd->dma_buffer;
+			dmasetup.src_address = RX_FIFO_ADDR;
+		}
+
+		dmasetup.cfg = prtd->dma_cfg_base;
+		dmasetup.trans_length = (2 * prtd->period_size / 4) - 1;
+
+		/* Program DMA channel and start it */
+		dma_prog_channel(prtd->dmach, &dmasetup);
+		dma_set_irq_mask(prtd->dmach, 0, 0);
+#endif
+		dma_start_channel(prtd->dmach);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+		del_timer_sync(&prtd->timer[tch]);
+#endif
+		/* Stop the companion channel and let the current DMA
+		   transfer finish */
+		dma_stop_channel_sg(prtd->dmach);
+		timeout = jiffies + (HZ / 20);
+		while ((dma_channel_enabled(prtd->dmach)) &&
+			(jiffies < timeout)) {
+			cpu_relax();
+		}
+
+//		dma_stop_channel(prtd->dmach);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		break;
+
+	default:
+		pr_warning("lpc313x_pcm_trigger: Unsupported cmd: %d\n",
+				cmd);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t lpc313x_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc313x_dma_data *prtd = runtime->private_data;
+	snd_pcm_uframes_t x;
+
+	/* Return an offset into the DMA buffer for the next data */
+	x = bytes_to_frames(runtime, (prtd->dma_cur - runtime->dma_addr));
+	if (x >= runtime->buffer_size)
+		x = 0;
+
+	return x;
+}
+
+static int lpc313x_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc313x_dma_data *prtd;
+	int ret = 0;
+
+	snd_soc_set_runtime_hwparams(substream, &lpc313x_pcm_hardware);
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+		SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	runtime->private_data = prtd;
+	prtd->dmach = -1;
+
+out:
+	return ret;
+}
+
+static int lpc313x_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+
+	kfree(prtd);
+	return 0;
+}
+
+static int lpc313x_pcm_mmap(struct snd_pcm_substream *substream,
+			    struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops lpc313x_pcm_ops = {
+	.open = lpc313x_pcm_open,
+	.close = lpc313x_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = lpc313x_pcm_hw_params,
+	.hw_free = lpc313x_pcm_hw_free,
+	.prepare = lpc313x_pcm_prepare,
+	.trigger = lpc313x_pcm_trigger,
+	.pointer = lpc313x_pcm_pointer,
+	.mmap = lpc313x_pcm_mmap,
+};
+
+/*
+ * ASoC platform driver
+ */
+static int lpc313x_pcm_new(struct snd_card *card,
+			   struct snd_soc_dai *dai,
+			   struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &lpc313x_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = lpc313x_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		pr_debug("%s: Allocating PCM capture DMA buffer\n", SND_NAME);
+		ret = lpc313x_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void lpc313x_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (substream == NULL)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				  buf->area, buf->addr);
+
+		buf->area = NULL;
+	}
+}
+
+#if defined(CONFIG_PM)
+static int lpc313x_pcm_suspend(struct platform_device *pdev,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct lpc313x_dma_data *prtd;
+
+	if (runtime == NULL)
+		return 0;
+
+	prtd = runtime->private_data;
+
+	/* Nothing to do here */
+
+	return 0;
+}
+
+static int lpc313x_pcm_resume(struct platform_device *pdev,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct lpc313x_dma_data *prtd;
+
+	if (runtime == NULL)
+		return 0;
+
+	prtd = runtime->private_data;
+
+	/* Nothing to do here */
+
+	return 0;
+}
+
+#else
+#define lpc313x_pcm_suspend	NULL
+#define lpc313x_pcm_resume	NULL
+#endif
+
+struct snd_soc_platform lpc313x_soc_platform = {
+	.name = SND_NAME,
+	.pcm_ops = &lpc313x_pcm_ops,
+	.pcm_new = lpc313x_pcm_new,
+	.pcm_free = lpc313x_pcm_free_dma_buffers,
+	.suspend = lpc313x_pcm_suspend,
+	.resume = lpc313x_pcm_resume,
+};
+EXPORT_SYMBOL_GPL(lpc313x_soc_platform);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("NXP LPC313X PCM module");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.28.2/sound/soc/lpc313x/lpc313x-pcm.h work_2.6.28.2/sound/soc/lpc313x/lpc313x-pcm.h
--- linux-2.6.28.2/sound/soc/lpc313x/lpc313x-pcm.h	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/lpc313x-pcm.h	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,29 @@
+/*
+ * sound/soc/lpc313x/lpc313x-pcm.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __SOUND_SOC_LPC313X_PCM_H
+#define __SOUND_SOC_LPC313X_PCM_H
+
+extern struct snd_soc_platform lpc313x_soc_platform;
+
+#endif
+
diff -purN linux-2.6.28.2/sound/soc/lpc313x/lpc313x-uda1380.c work_2.6.28.2/sound/soc/lpc313x/lpc313x-uda1380.c
--- linux-2.6.28.2/sound/soc/lpc313x/lpc313x-uda1380.c	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/lpc313x-uda1380.c	2010-03-16 10:38:00.000000000 -0700
@@ -0,0 +1,222 @@
+/*
+ * sound/soc/lpc313x/lpc313x-uda1380.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "../codecs/uda1380.h"
+#include "lpc313x-pcm.h"
+#include "lpc313x-i2s.h"
+#include "lpc313x-i2s-clocking.h"
+
+#define SND_MODNAME "lpc313x_uda1380"
+
+static int ea3131_uda1380_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	const unsigned int fmt = (SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_CBS_CFS);
+	int ret;
+
+
+	/* Set the CPU I2S rate clock (first) */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params),
+					    SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set I2S clock (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	/* Set CPU and CODEC DAI format */
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CPU DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CODEC DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops ea3131_uda1380_ops = {
+	.hw_params = ea3131_uda1380_hw_params,
+};
+
+static const struct snd_soc_dapm_widget ea3131_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_LINE("Line Out", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* Headphone connected to VOUTRHP, VOUTLHP */
+	{"Headphone Jack", NULL, "VOUTRHP"},
+	{"Headphone Jack", NULL, "VOUTLHP"},
+
+	/* Line Out connected to VOUTR, VOUTL */
+	{"Line Out", NULL, "VOUTR"},
+	{"Line Out", NULL, "VOUTL"},
+
+	/* Mic connected to VINM */
+	{"VINM", NULL, "Mic Jack"},
+
+	/* Line In connected to VINR, VINL */
+	{"VINL", NULL, "Line In"},
+	{"VINR", NULL, "Line In"},
+};
+
+static int ea3131_uda1380_init(struct snd_soc_codec *codec)
+{
+	/* Add widgets */
+	snd_soc_dapm_new_controls(codec, ea3131_dapm_widgets,
+				  ARRAY_SIZE(ea3131_dapm_widgets));
+
+	/* Set up audio path audio_map */
+	snd_soc_dapm_add_routes(codec, intercon, ARRAY_SIZE(intercon));
+
+	/* Always connected pins */
+	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+	snd_soc_dapm_enable_pin(codec, "Line Out");
+	snd_soc_dapm_enable_pin(codec, "Mic Jack");
+	snd_soc_dapm_enable_pin(codec, "Line In");
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static struct snd_soc_dai_link ea3131_uda1380_dai[] = {
+	{
+		.name = "UDA1380",
+		.stream_name = "UDA1380",
+		.cpu_dai = &lpc313x_i2s_dai,
+		.codec_dai = &uda1380_dai[UDA1380_DAI_DUPLEX],
+		.init = ea3131_uda1380_init,
+		.ops = &ea3131_uda1380_ops,
+	},
+};
+
+static struct snd_soc_machine snd_soc_machine_ea3131 = {
+	.name = "LPC313X_I2S_UDA1380",
+	.dai_link = &ea3131_uda1380_dai[0],
+	.num_links = ARRAY_SIZE(ea3131_uda1380_dai),
+};
+
+static struct uda1380_setup_data ea3131_uda1380_setup = {
+	.i2c_address = 0x1a,
+	.dac_clk = UDA1380_DAC_CLK_SYSCLK,
+#if defined (CONFIG_SND_I2C1_CHANNEL_UDA1380)
+	.i2c_bus = 1
+#else
+	.i2c_bus = 0
+#endif
+};
+
+static struct snd_soc_device ea3131_uda1380_snd_devdata = {
+	.machine = &snd_soc_machine_ea3131,
+	.platform = &lpc313x_soc_platform,
+	.codec_dev = &soc_codec_dev_uda1380,
+	.codec_data = &ea3131_uda1380_setup,
+};
+
+static struct platform_device *ea3131_snd_device;
+static int __init ea3131_asoc_init(void)
+{
+	int ret = 0;
+
+	/*
+	 * Create and register platform device
+	 */
+	ea3131_snd_device = platform_device_alloc("soc-audio", -1);
+	if (ea3131_snd_device == NULL) {
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(ea3131_snd_device, &ea3131_uda1380_snd_devdata);
+	ea3131_uda1380_snd_devdata.dev = &ea3131_snd_device->dev;
+
+	/*
+	 * Enable CODEC clock first or I2C will fail to the CODEC
+	 */
+	lpc313x_main_clk_rate(48000);
+
+	ret = platform_device_add(ea3131_snd_device);
+	if (ret) {
+		pr_warning("%s: platform_device_add failed (%d)\n",
+			   SND_MODNAME, ret);
+		goto err_device_add;
+	}
+
+	return 0;
+
+err_device_add:
+	if (ea3131_snd_device != NULL) {
+		platform_device_put(ea3131_snd_device);
+		lpc313x_main_clk_rate(0);
+		ea3131_snd_device = NULL;
+	}
+
+	return ret;
+}
+
+static void __exit ea3131_asoc_exit(void)
+{
+	platform_device_unregister(ea3131_snd_device);
+	lpc313x_main_clk_rate(0);
+	ea3131_snd_device = NULL;
+}
+
+module_init(ea3131_asoc_init);
+module_exit(ea3131_asoc_exit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC machine driver for LPC313X/UDA1380");
+MODULE_LICENSE("GPL");
+
diff -purN linux-2.6.28.2/sound/soc/lpc313x/Makefile work_2.6.28.2/sound/soc/lpc313x/Makefile
--- linux-2.6.28.2/sound/soc/lpc313x/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ work_2.6.28.2/sound/soc/lpc313x/Makefile	2010-03-15 16:57:43.000000000 -0700
@@ -0,0 +1,11 @@
+# LPC313X Platform Support
+snd-soc-lpc313x-objs := lpc313x-pcm.o
+snd-soc-lpc313x-i2s-objs := lpc313x-i2s.o
+
+obj-$(CONFIG_SND_LPC313X_SOC) += snd-soc-lpc313x.o
+obj-$(CONFIG_SND_LPC313X_SOC_I2S) += snd-soc-lpc313x-i2s.o lpc313x-i2s-clocking.o
+
+# LPC3XXX Machine Support
+snd-soc-lpc313x-uda1380-objs := lpc313x-uda1380.o
+
+obj-$(CONFIG_SND_LPC313X_SOC_I2S_UDA1380) += snd-soc-lpc313x-uda1380.o
diff -purN linux-2.6.28.2/sound/soc/Makefile work_2.6.28.2/sound/soc/Makefile
--- linux-2.6.28.2/sound/soc/Makefile	2009-01-24 16:42:07.000000000 -0800
+++ work_2.6.28.2/sound/soc/Makefile	2010-03-15 16:57:43.000000000 -0700
@@ -2,4 +2,4 @@ snd-soc-core-objs := soc-core.o soc-dapm
 
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
 obj-$(CONFIG_SND_SOC)	+= codecs/ at32/ at91/ pxa/ s3c24xx/ sh/ fsl/ davinci/
-obj-$(CONFIG_SND_SOC)	+= omap/ au1x/ blackfin/
+obj-$(CONFIG_SND_SOC)	+= omap/ au1x/ blackfin/ lpc313x/
