diff -uNr linux-2.6.33-lpc313x-vanilla/arch/arm/mach-lpc313x/ea313x.c linux-2.6.33-lpc313x/arch/arm/mach-lpc313x/ea313x.c
--- linux-2.6.33-lpc313x-vanilla/arch/arm/mach-lpc313x/ea313x.c	2014-05-13 18:16:09.361514071 +0200
+++ linux-2.6.33-lpc313x/arch/arm/mach-lpc313x/ea313x.c	2014-05-08 13:58:11.948636902 +0200
@@ -49,6 +49,7 @@
 #include <linux/i2c/pca953x.h>
 #include <linux/serial_sc16is7x2.h>
 
+
 static struct lpc313x_mci_irq_data irq_data = {
 	.irq = IRQ_SDMMC_CD,
 };
@@ -163,6 +164,158 @@
 	.resource	= lpc313x_mci_resources,
 };
 
+#if defined (CONFIG_FB_SSD1963)
+static struct resource ssd1963_resource[] = {
+  [0] = {
+     .start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
+     .end   = EXT_SRAM0_PHYS + 0x00000 + 0xffff,
+     .flags = IORESOURCE_MEM,
+  },
+  [1] = {
+     .start = EXT_SRAM0_PHYS + 0x10000 + 0x0000,
+     .end   = EXT_SRAM0_PHYS + 0x10000 + 0xffff,
+     .flags = IORESOURCE_MEM,
+  },
+};
+
+static struct platform_device ssd1963_device = {
+  .name          = "ssd1963",
+  .id            = 0,
+  .num_resources = ARRAY_SIZE(ssd1963_resource),
+  .resource      = ssd1963_resource,
+};
+
+static void __init ea_add_device_ssd1963(void)
+{
+  MPMC_STCONFIG0 = 0x81;
+  MPMC_STWTWEN0  = 0;
+  MPMC_STWTOEN0  = 0;
+  MPMC_STWTRD0   = 31;
+  MPMC_STWTPG0   = 0;
+  MPMC_STWTWR0   = 15;
+  MPMC_STWTTURN0 = 0;
+
+  printk(KERN_ALERT "SSD1963->EA313x: platform_device_register(&ssd1963_device) called\n");
+  platform_device_register(&ssd1963_device);
+  printk(KERN_ALERT "SSD1963->EA313x: platform_device_register(&ssd1963_device) returned\n");
+}
+#else
+static void __init ea_add_device_ssd1963(void) {}
+#endif /* CONFIG_FB_SSD1963 */
+
+#if defined (CONFIG_FB_MD050SD)
+static struct resource md050sd_resource[] = {
+  [0] = {
+     .start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
+     .end   = EXT_SRAM0_PHYS + 0x00000 + 0xffff,
+     .flags = IORESOURCE_MEM,
+  },
+  [1] = {
+     .start = EXT_SRAM0_PHYS + 0x10000 + 0x0000,
+     .end   = EXT_SRAM0_PHYS + 0x10000 + 0xffff,
+     .flags = IORESOURCE_MEM,
+  },
+};
+
+static struct platform_device md050sd_device = {
+  .name          = "md050sd",
+  .id            = 0,
+  .num_resources = ARRAY_SIZE(md050sd_resource),
+  .resource      = md050sd_resource,
+};
+
+static void __init ea_add_device_md050sd(void)
+{
+  MPMC_STCONFIG0 = 0x81;
+  MPMC_STWTWEN0  = 0;
+  MPMC_STWTOEN0  = 0;
+  MPMC_STWTRD0   = 0;
+  MPMC_STWTPG0   = 0;
+  MPMC_STWTWR0   = 2;
+  MPMC_STWTTURN0 = 0;
+
+  printk(KERN_ALERT "MD050SD->EA313x: platform_device_register(&md050sd_device) called\n");
+  platform_device_register(&md050sd_device);
+  printk(KERN_ALERT "MD050SD->EA313x: platform_device_register(&md050sd_device) returned\n");
+}
+#else
+static void __init ea_add_device_md050sd(void) {}
+#endif /* CONFIG_FB_MD050SD */
+
+#if defined (CONFIG_FB_SSD1289)
+static struct resource ssd1289_resource[] = {
+  [0] = {
+     .start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
+     .end   = EXT_SRAM0_PHYS + 0x00000 + 0xffff,
+     .flags = IORESOURCE_MEM,
+  },
+  [1] = {
+     .start = EXT_SRAM0_PHYS + 0x10000 + 0x0000,
+     .end   = EXT_SRAM0_PHYS + 0x10000 + 0xffff,
+     .flags = IORESOURCE_MEM,
+  },
+};
+
+static struct platform_device ssd1289_device = {
+  .name          = "ssd1289",
+  .id            = 0,
+  .num_resources = ARRAY_SIZE(ssd1289_resource),
+  .resource      = ssd1289_resource,
+};
+
+static void __init ea_add_device_ssd1289(void)
+{
+  MPMC_STCONFIG0 = 0x81;
+  MPMC_STWTWEN0  = 0;
+  MPMC_STWTOEN0  = 0;
+  MPMC_STWTRD0   = 0;
+  MPMC_STWTPG0   = 0;
+  MPMC_STWTWR0   = 2;
+  MPMC_STWTTURN0 = 0;
+
+  printk(KERN_ALERT "SSD1289->EA313x: platform_device_register(&ssd1289_device) called\n");
+  platform_device_register(&ssd1289_device);
+  printk(KERN_ALERT "SSD1289->EA313x: platform_device_register(&ssd1289_device) returned\n");
+}
+#else
+static void __init ea_add_device_ssd1289(void) {}
+#endif /* CONFIG_FB_SSD1289 */
+
+//static struct resource testmod_resource[] = {
+//   [0] = {
+//         .start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
+//         .end   = EXT_SRAM0_PHYS + 0x00000 + 0xffff,
+//         .flags = IORESOURCE_MEM,
+//      },
+//      [1] = {
+//         .start = EXT_SRAM0_PHYS + 0x10000 + 0x0000,
+//         .end   = EXT_SRAM0_PHYS + 0x10000 + 0xffff,
+//         .flags = IORESOURCE_MEM,
+//   },
+//};
+//
+//static struct platform_device testmod_device = {
+//   .name          = "testmod",
+//   .id            = 0,
+//   .num_resources = ARRAY_SIZE(testmod_resource),
+//   .resource      = testmod_resource,
+//};
+
+//static void __init ea_add_device_testmod(void)
+//{
+//   MPMC_STCONFIG0 = 0x81;
+//   MPMC_STWTWEN0  = 10;
+//   MPMC_STWTOEN0  = 0;
+//   MPMC_STWTRD0   = 31;
+//   MPMC_STWTPG0   = 0;
+//   MPMC_STWTWR0   = 31;
+//   MPMC_STWTTURN0 = 0;
+//
+//   platform_device_register(&testmod_device);
+//}
+
+
+//#define DM_IO_DELAY()   do {} while(0)
 /*
  * DM9000 ethernet device
  */
@@ -195,7 +348,7 @@
 11nsec but DM9000 needs 80nsec between nOEs. So lets add some dummy instructions such as
 reading a GPIO register to compensate for extra 70nsec.
 */
-# define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
+#define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
 
 static void dm9000_dumpblk(void __iomem *reg, int count)
 {
@@ -403,9 +556,6 @@
 	.resource	= lpc313x_spi_resources,
 };
 
-
-
-
 #if defined(CONFIG_MTD_DATAFLASH)
 /* MTD Data FLASH driver registration */
 static int __init lpc313x_spimtd_register(void)
@@ -441,6 +591,18 @@
 		.length		= SZ_4K,
 		.type		= MT_DEVICE
 	},
+//   {
+//      .virtual = io_p2v(EXT_SRAM0_PHYS + 0x10000),
+//      .pfn     = __phys_to_pfn(EXT_SRAM0_PHYS + 0x10000),
+//      .length     = SZ_4K,
+//      .type    = MT_DEVICE
+//   },
+//   {
+//      .virtual = io_p2v(IO_MPMC_CFG_PHYS),
+//      .pfn     = __phys_to_pfn(IO_MPMC_CFG_PHYS),
+//      .length     = SZ_4K,
+//      .type    = MT_DEVICE
+//   },
 	{
 		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
 		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
@@ -518,13 +680,15 @@
 {
 	lpc313x_init();
 	
-	
-
 	platform_add_devices(devices, ARRAY_SIZE(devices));
 
 	/* add DM9000 device */
 	ea_add_device_dm9000();
-	
+	ea_add_device_ssd1963();
+	ea_add_device_ssd1289();
+	ea_add_device_md050sd();
+
+//   ea_add_device_testmod();
 
 	/* register i2cdevices */
 	lpc313x_register_i2c_devices();
@@ -535,7 +699,6 @@
 	GPIO_OUT_HIGH(IOCONF_GPIO,(1 << GPIO_GPIO15)); /* GPIO15 */
 	GPIO_OUT_HIGH(IOCONF_GPIO,(1 << GPIO_GPIO19)); /* GPIO19 */
 
-
 	
 #if defined(CONFIG_MACH_EA3152)
 	i2c_register_board_info(1, ea3152_i2c1_devices,
diff -uNr linux-2.6.33-lpc313x-vanilla/build_kernel.sh linux-2.6.33-lpc313x/build_kernel.sh
--- linux-2.6.33-lpc313x-vanilla/build_kernel.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-lpc313x/build_kernel.sh	2014-05-13 18:18:08.248515922 +0200
@@ -0,0 +1,18 @@
+#!/bin/bash
+# Armin Schlegel (2014)
+# compiles the kernel and copies the ready files to ready
+
+mkdir ready
+cd ready
+rm -r lib/*
+rm ready.tar.gz
+cd ..
+
+make -j4
+make modules -j4
+cp arch/arm/boot/zImage ready/boot
+make modules_install INSTALL_MOD_PATH=ready
+
+cd ready
+tar cvfz ready.tar.gz boot lib
+cd ..
+
diff -uNr linux-2.6.33-lpc313x-vanilla/drivers/video/Kconfig linux-2.6.33-lpc313x/drivers/video/Kconfig
--- linux-2.6.33-lpc313x-vanilla/drivers/video/Kconfig	2014-05-13 18:17:08.084514985 +0200
+++ linux-2.6.33-lpc313x/drivers/video/Kconfig	2014-05-08 13:18:19.890707579 +0200
@@ -2146,38 +2146,73 @@
 	  the bootloader.
 
 config FB_MSM
-	tristate "MSM Framebuffer support"
-	depends on FB && ARCH_MSM
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	default y
+   tristate "MSM Framebuffer support"
+   depends on FB && ARCH_MSM
+   select FB_CFB_FILLRECT
+   select FB_CFB_COPYAREA
+   select FB_CFB_IMAGEBLIT
+   default y
 
 config FB_MX3
-	tristate "MX3 Framebuffer support"
-	depends on FB && MX3_IPU
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	default y
-	help
-	  This is a framebuffer device for the i.MX31 LCD Controller. So
-	  far only synchronous displays are supported. If you plan to use
-	  an LCD display with your i.MX31 system, say Y here.
+   tristate "MX3 Framebuffer support"
+   depends on FB && MX3_IPU
+   select FB_CFB_FILLRECT
+   select FB_CFB_COPYAREA
+   select FB_CFB_IMAGEBLIT
+   default y
+   help
+     This is a framebuffer device for the i.MX31 LCD Controller. So
+     far only synchronous displays are supported. If you plan to use
+     an LCD display with your i.MX31 system, say Y here.
 
 config FB_BROADSHEET
-	tristate "E-Ink Broadsheet/Epson S1D13521 controller support"
-	depends on FB
-	select FB_SYS_FILLRECT
-	select FB_SYS_COPYAREA
-	select FB_SYS_IMAGEBLIT
-	select FB_SYS_FOPS
-	select FB_DEFERRED_IO
-	help
-	  This driver implements support for the E-Ink Broadsheet
-	  controller. The release name for this device was Epson S1D13521
-	  and could also have been called by other names when coupled with
-	  a bridge adapter.
+   tristate "E-Ink Broadsheet/Epson S1D13521 controller support"
+   depends on FB
+   select FB_SYS_FILLRECT
+   select FB_SYS_COPYAREA
+   select FB_SYS_IMAGEBLIT
+   select FB_SYS_FOPS
+   select FB_DEFERRED_IO
+   help
+     This driver implements support for the E-Ink Broadsheet
+     controller. The release name for this device was Epson S1D13521
+     and could also have been called by other names when coupled with
+     a bridge adapter.
+     
+config FB_SSD1963
+  tristate "Solomon Systech SSD1963 controller support"
+  depends on FB
+  select FB_SYS_FILLRECT
+  select FB_SYS_COPYAREA
+  select FB_SYS_IMAGEBLIT
+  select FB_SYS_FOPS
+  select FB_DEFERRED_IO
+  help
+    This is a framebuffer device for the Solomon Systek SSD1963
+    controller.
+    
+config FB_SSD1289
+  tristate "SSD1289 display support"
+  depends on FB
+  select FB_SYS_FILLRECT
+  select FB_SYS_COPYAREA
+  select FB_SYS_IMAGEBLIT
+  select FB_SYS_FOPS
+  select FB_DEFERRED_IO
+  help
+    This is a framebuffer device for the Solomon Systek SSD1289 
+    controller.
+        
+config FB_MD050SD
+  tristate "MD050SD display support"
+  depends on FB
+  select FB_SYS_FILLRECT
+  select FB_SYS_COPYAREA
+  select FB_SYS_IMAGEBLIT
+  select FB_SYS_FOPS
+  select FB_DEFERRED_IO
+  help
+    This is a framebuffer device for the MD050SD.
 
 source "drivers/video/omap/Kconfig"
 source "drivers/video/omap2/Kconfig"
diff -uNr linux-2.6.33-lpc313x-vanilla/drivers/video/Makefile linux-2.6.33-lpc313x/drivers/video/Makefile
--- linux-2.6.33-lpc313x-vanilla/drivers/video/Makefile	2014-05-13 18:17:08.085514985 +0200
+++ linux-2.6.33-lpc313x/drivers/video/Makefile	2014-05-08 13:18:41.647706936 +0200
@@ -128,6 +128,9 @@
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
 obj-$(CONFIG_FB_CARMINE)          += carminefb.o
 obj-$(CONFIG_FB_MB862XX)	  += mb862xx/
+obj-$(CONFIG_FB_SSD1963)	  += ssd1963.o
+obj-$(CONFIG_FB_SSD1289)	  += ssd1289.o
+obj-$(CONFIG_FB_MD050SD)	  += md050sd.o
 obj-$(CONFIG_FB_MSM)              += msm/
 
 # Platform or fallback drivers go here
diff -uNr linux-2.6.33-lpc313x-vanilla/drivers/video/md050sd.c linux-2.6.33-lpc313x/drivers/video/md050sd.c
--- linux-2.6.33-lpc313x-vanilla/drivers/video/md050sd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-lpc313x/drivers/video/md050sd.c	2014-05-13 18:18:42.174516450 +0200
@@ -0,0 +1,724 @@
+/*
+ * MD050SD Framebuffer
+ *
+ *
+ * Copyright (c) 2014 Armin Schlegel <armin.schlegel@gmx.de>
+ * Original: Copyright (c) 2009 Jean-Christian de Rivaz
+ * Original: Copyright (c) 2012 Jeroen Domburg <jeroen@spritesmods.com>
+ *
+ * This is an adaption from the ili9325.c from Jeroen Domburg to work with
+ * the MD050SD controller.
+ * Bits and pieces borrowed from the fsl-ili9325.c:
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Author: Alison Wang <b18965@freescale.com>
+ *         Jason Jin <Jason.jin@freescale.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * For direct I/O-mode:
+ *
+ * This driver expect the MD050SD to be connected to a 16 bits local bus
+ * and to be set in the 16 bits parallel interface mode. To use it you must
+ * define in your board file a struct platform_device with a name set to
+ * "md050sd" and a struct resource array with two IORESOURCE_MEM: the first
+ * for the control register; the second for the data register.
+ *
+ */
+
+
+#include <linux/kernel.h>
+//#define DEBUG 1
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/fb.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+
+
+#define LED_BACKLIGHT_PIN  20
+#define LED_RESET_PIN  19
+
+#define USE_MEMCPY   0
+
+/* TFT Controler Register defines */
+#define MD050SD_SET_BACKLIGHT_PWM        (0x0001)
+#define MD050SD_SET_LINE_ADDRESS_START   (0x0002)
+#define MD050SD_SET_COLUMN_ADDRESS_START (0x0003)
+#define MD050SD_DISPLAY_PAGE             (0x0004)
+#define MD050SD_PAGE_RW                  (0x0005)
+#define MD050SD_SET_LINE_ADDRESS_END     (0x0006)
+#define MD050SD_SET_COLUMN_ADDRESS_END   (0x0007)
+#define MD050SD_SET_SLEEP                (0x000B)
+#define MD050SD_WRITE_MEMORY_START       (0x000F)
+
+#define MD050SD_WIDTH                      800
+#define MD050SD_HEIGHT                     480
+
+struct md050sd_page {
+   unsigned short x;
+   unsigned short y;
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned short len;
+   int must_update;
+};
+
+struct md050sd {
+   struct device *dev;
+   struct fb_info *info;
+   unsigned int pages_count;
+   struct md050sd_page *pages;
+   unsigned long pseudo_palette[17];
+   int backlight;
+   volatile unsigned short *ctrl_io;
+   volatile unsigned short *data_io;
+};
+
+#define MD050SD_LINES_PER_PAGE  20
+#define MD050SD_BYTES_PER_PIXEL         2
+#define MD050SD_PAGE_SIZE  (MD050SD_LINES_PER_PAGE * MD050SD_WIDTH * MD050SD_BYTES_PER_PIXEL)
+
+inline void md050sd_send_cmd(struct md050sd *item, unsigned short cmd)
+{
+   writew(cmd & 0xFF, item->ctrl_io );
+}
+
+
+inline void md050sd_send_data(struct md050sd *item, unsigned short data)
+{
+   writew(data, item->data_io);
+}
+
+void md050sd_setWindow(struct md050sd *item, unsigned short xs, unsigned short ys,
+      unsigned short xe, unsigned short ye)
+{
+   md050sd_send_cmd(item, MD050SD_SET_LINE_ADDRESS_START);
+   md050sd_send_data(item, ys);
+   md050sd_send_cmd(item, MD050SD_SET_COLUMN_ADDRESS_START);
+   md050sd_send_data(item, xs);
+
+   md050sd_send_cmd(item, MD050SD_SET_LINE_ADDRESS_END);
+   md050sd_send_data(item, ye);
+   md050sd_send_cmd(item, MD050SD_SET_COLUMN_ADDRESS_END);
+   md050sd_send_data(item, xe);
+
+   md050sd_send_cmd(item, MD050SD_WRITE_MEMORY_START);
+}
+
+void md050sd_copy(struct md050sd *item, unsigned int index)
+{
+#define PIXELGROUPLEN 40
+   unsigned short x;
+   unsigned short y;
+   unsigned short y_local;
+
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned int len;
+   //   unsigned int count;
+   unsigned short j;
+   unsigned short tmpy;
+   unsigned short xend;
+   //int pageModified = 0;
+   x = item->pages[index].x;
+   y = item->pages[index].y;
+   buffer = item->pages[index].buffer;
+   oldbuffer = item->pages[index].oldbuffer;
+   len = item->pages[index].len;
+   dev_dbg(item->dev,
+         "%s: page[%u]: x=%3hu y=%3hu buffer=0x%p len=%3hu\n",
+         __func__, index, x, y, buffer, len);
+#if USE_MEMCPY == 0
+   tmpy = 0;
+   xend = 0;
+   for (y_local = y; y_local < y + MD050SD_LINES_PER_PAGE; y_local++) {
+      for (x = 0; x < MD050SD_WIDTH; x++) {
+         if (buffer[x + tmpy * MD050SD_WIDTH] != oldbuffer[x + tmpy * MD050SD_WIDTH]) {
+            if ((x + PIXELGROUPLEN) > MD050SD_WIDTH) {
+               xend = MD050SD_WIDTH - 1;
+            } else
+               xend = x + PIXELGROUPLEN;
+            md050sd_setWindow(item, x, y_local, xend, y_local);
+            for (j = x; j <= xend; j++) {
+               md050sd_send_data(item, buffer[j + tmpy * MD050SD_WIDTH]);
+               oldbuffer[j + tmpy * MD050SD_WIDTH] = buffer[j + tmpy * MD050SD_WIDTH];
+            }
+            x = xend;
+         }
+      }
+      tmpy++;
+   }
+#else
+   md050sd_setWindow(item, x, MD050SD_WIDTH, y, y + MD050SD_LINES_PER_PAGE);
+   memcpy(item->data_io, buffer, len * 2);
+#endif
+}
+
+static void md050sd_update_all(struct md050sd *item)
+{
+   unsigned short i;
+   struct fb_deferred_io *fbdefio = item->info->fbdefio;
+   for (i = 0; i < item->pages_count; i++) {
+      item->pages[i].must_update = 1;
+   }
+   //printk(KERN_ALERT "md050sd_update_all () occurred!\n");
+   schedule_delayed_work(&item->info->deferred_work, fbdefio->delay);
+}
+
+static void md050sd_update(struct fb_info *info,
+      struct list_head *pagelist)
+{
+   struct md050sd *item = (struct md050sd *) info->par;
+   struct page *page;
+   int i;
+
+   //We can be called because of pagefaults (mmap'ed framebuffer, pages
+   //returned in *pagelist) or because of kernel activity
+   //(pages[i]/must_update!=0). Add the former to the list of the latter.
+   list_for_each_entry(page, pagelist, lru) {
+      item->pages[page->index].must_update = 1;
+   }
+   //printk(KERN_ALERT "md050sd_update() occurred!\n");
+   //Copy changed pages.
+   for (i = 0; i < item->pages_count; i++) {
+      //ToDo: Small race here between checking and setting must_update,
+      //maybe lock?
+      if (item->pages[i].must_update) {
+         item->pages[i].must_update = 0;
+         md050sd_copy(item, i);
+      }
+   }
+
+}
+
+static void __init md050sd_setup(struct md050sd *item)
+{
+   int x;
+   int y;
+   printk(KERN_ALERT "md050sd_setup() called\n");
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+   gpio_direction_output(LED_BACKLIGHT_PIN, 0);
+   gpio_direction_output(LED_RESET_PIN, 0);
+   msleep(200);
+   gpio_direction_output(LED_RESET_PIN, 1);
+   msleep(200);
+
+   md050sd_setWindow(item, 0, 0, MD050SD_WIDTH - 1, MD050SD_HEIGHT - 1);
+   for (x = 0; x < MD050SD_WIDTH * MD050SD_HEIGHT; x++)
+      md050sd_send_data(item, 0x0000);
+
+   gpio_direction_output(LED_BACKLIGHT_PIN, 1);
+   msleep(10);
+   printk(KERN_ALERT
+         "md050sd_setup() end: pages_count: %d, item->pages[x].len: %d\n\n",
+         item->pages_count, item->pages[0].len);
+}
+
+//This routine will allocate the buffer for the complete framebuffer. This
+//is one continuous chunk of 16-bit pixel values; userspace programs
+//will write here.
+static int __init md050sd_video_alloc(struct md050sd *item)
+{
+   unsigned int frame_size;
+
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   frame_size = item->info->fix.line_length * item->info->var.yres;
+   dev_dbg(item->dev, "%s: item=0x%p frame_size=%u\n",
+         __func__, (void *) item, frame_size);
+
+   item->pages_count = frame_size / MD050SD_PAGE_SIZE;
+   if ((item->pages_count * MD050SD_PAGE_SIZE) < frame_size) {
+      item->pages_count++;
+   }
+   dev_dbg(item->dev, "%s: item=0x%p pages_count=%u\n",
+         __func__, (void *) item, item->pages_count);
+
+   item->info->fix.smem_len = item->pages_count * MD050SD_PAGE_SIZE;
+   item->info->fix.smem_start =
+         (unsigned long) vmalloc(item->info->fix.smem_len);
+   if (!item->info->fix.smem_start) {
+      dev_err(item->dev, "%s: unable to vmalloc\n", __func__);
+      return -ENOMEM;
+   }
+   memset((void *) item->info->fix.smem_start, 0,
+         item->info->fix.smem_len);
+
+   return 0;
+}
+
+static void md050sd_video_free(struct md050sd *item)
+{
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   kfree((void *) item->info->fix.smem_start);
+}
+
+//This routine will allocate a md050sd_page struct for each vm page in the
+//main framebuffer memory. Each struct will contain a pointer to the page
+//start, an x- and y-offset, and the length of the pagebuffer which is in the framebuffer.
+static int __init md050sd_pages_alloc(struct md050sd *item)
+{
+   unsigned short pixels_per_page;
+   unsigned short yoffset_per_page;
+   unsigned short xoffset_per_page;
+   unsigned int index;
+   unsigned short x = 0;
+   unsigned short y = 0;
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned int len;
+
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   item->pages =
+         kmalloc(item->pages_count * sizeof(struct md050sd_page),
+               GFP_KERNEL);
+   if (!item->pages) {
+      dev_err(item->dev,
+            "%s: unable to kmalloc for md050sd_page\n",
+            __func__);
+      return -ENOMEM;
+   }
+
+   pixels_per_page =
+         MD050SD_PAGE_SIZE / (item->info->var.bits_per_pixel / 8);
+   yoffset_per_page = pixels_per_page / item->info->var.xres;
+   xoffset_per_page = pixels_per_page -
+         (yoffset_per_page * item->info->var.xres);
+   dev_dbg(item->dev, "%s: item=0x%p pixels_per_page=%hu "
+         "yoffset_per_page=%hu xoffset_per_page=%hu\n",
+         __func__, (void *) item, pixels_per_page,
+         yoffset_per_page, xoffset_per_page);
+
+   oldbuffer = kmalloc(item->pages_count * pixels_per_page * 2,
+         GFP_KERNEL);
+   if (!oldbuffer) {
+      dev_err(item->dev,
+            "%s: unable to kmalloc for md050sd_page oldbuffer\n",
+            __func__);
+      return -ENOMEM;
+   }
+
+   buffer = (unsigned short *) item->info->fix.smem_start;
+   for (index = 0; index < item->pages_count; index++) {
+      len = (item->info->var.xres * item->info->var.yres) -
+            (index * pixels_per_page);
+      if (len > pixels_per_page) {
+         len = pixels_per_page;
+      }
+      dev_dbg(item->dev,
+            "%s: page[%d]: x=%3hu y=%3hu buffer=0x%p len=%3hu\n",
+            __func__, index, x, y, buffer, len);
+      item->pages[index].x = x;
+      item->pages[index].y = y;
+      item->pages[index].buffer = buffer;
+      item->pages[index].oldbuffer = oldbuffer;
+      item->pages[index].len = len;
+
+      x += xoffset_per_page;
+      if (x >= item->info->var.xres) {
+         y++;
+         x -= item->info->var.xres;
+      }
+      y += yoffset_per_page;
+      buffer += pixels_per_page;
+      oldbuffer += pixels_per_page;
+   }
+
+   return 0;
+}
+
+static void md050sd_pages_free(struct md050sd *item)
+{
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   kfree(item->pages);
+}
+
+static inline __u32 CNVT_TOHW(__u32 val, __u32 width)
+{
+   return ((val << width) + 0x7FFF - val) >> 16;
+}
+
+//This routine is needed because the console driver won't work without it.
+static int md050sd_setcolreg(unsigned regno,
+      unsigned red, unsigned green, unsigned blue,
+      unsigned transp, struct fb_info *info)
+{
+   int ret = 1;
+
+   /*
+    * If greyscale is true, then we convert the RGB value
+    * to greyscale no matter what visual we are using.
+    */
+   if (info->var.grayscale)
+      red = green = blue = (19595 * red + 38470 * green +
+            7471 * blue) >> 16;
+   switch (info->fix.visual) {
+   case FB_VISUAL_TRUECOLOR:
+      if (regno < 16) {
+         u32 *pal = info->pseudo_palette;
+         u32 value;
+
+         red = CNVT_TOHW(red, info->var.red.length);
+         green = CNVT_TOHW(green, info->var.green.length);
+         blue = CNVT_TOHW(blue, info->var.blue.length);
+         transp =
+               CNVT_TOHW(transp, info->var.transp.length);
+
+         value = (red << info->var.red.offset) |
+               (green << info->var.green.offset) |
+               (blue << info->var.blue.offset) |
+               (transp << info->var.transp.offset);
+
+         pal[regno] = value;
+         ret = 0;
+      }
+      break;
+   case FB_VISUAL_STATIC_PSEUDOCOLOR:
+   case FB_VISUAL_PSEUDOCOLOR:
+      break;
+   }
+   return ret;
+}
+
+static int md050sd_blank(int blank_mode, struct fb_info *info)
+{
+   struct md050sd *item = (struct md050sd *) info->par;
+   if (blank_mode == FB_BLANK_UNBLANK)
+      item->backlight = 1;
+   else
+      item->backlight = 0;
+   //Item->backlight won't take effect until the LCD is written to. Force that
+   //by dirty'ing a page.
+   item->pages[0].must_update = 1;
+   //printk(KERN_ALERT "md050sd_blank() occurred!\n");
+   schedule_delayed_work(&info->deferred_work, 0);
+   return 0;
+}
+
+static void md050sd_touch(struct fb_info *info, int x, int y, int w, int h)
+{
+   struct fb_deferred_io *fbdefio = info->fbdefio;
+   struct md050sd *item = (struct md050sd *) info->par;
+   int i, ystart, yend;
+   if (fbdefio) {
+      //Touch the pages the y-range hits, so the deferred io will update them.
+      for (i = 0; i < item->pages_count; i++) {
+         ystart = item->pages[i].y;
+         yend =
+               item->pages[i].y +
+               (item->pages[i].len / info->fix.line_length) +
+               1;
+         if (!((y + h) < ystart || y > yend)) {
+            item->pages[i].must_update = 1;
+         }
+      }
+      //Schedule the deferred IO to kick in after a delay.
+      schedule_delayed_work(&info->deferred_work,
+            fbdefio->delay);
+   }
+}
+
+static void md050sd_fillrect(struct fb_info *p,
+      const struct fb_fillrect *rect)
+{
+   sys_fillrect(p, rect);
+   md050sd_touch(p, rect->dx, rect->dy, rect->width, rect->height);
+}
+
+static void md050sd_imageblit(struct fb_info *p,
+      const struct fb_image *image)
+{
+   sys_imageblit(p, image);
+   md050sd_touch(p, image->dx, image->dy, image->width,
+         image->height);
+}
+
+static void md050sd_copyarea(struct fb_info *p,
+      const struct fb_copyarea *area)
+{
+   sys_copyarea(p, area);
+   md050sd_touch(p, area->dx, area->dy, area->width, area->height);
+}
+
+static ssize_t md050sd_write(struct fb_info *p, const char __user * buf,
+      size_t count, loff_t * ppos)
+{
+   ssize_t res;
+   res = fb_sys_write(p, buf, count, ppos);
+   md050sd_touch(p, 0, 0, p->var.xres, p->var.yres);
+   return res;
+}
+
+static struct fb_ops md050sd_fbops = {
+      .owner         = THIS_MODULE,
+      .fb_read       = fb_sys_read,
+      .fb_write      = md050sd_write,
+      .fb_fillrect   = md050sd_fillrect,
+      .fb_copyarea   = md050sd_copyarea,
+      .fb_imageblit  = md050sd_imageblit,
+      .fb_setcolreg  = md050sd_setcolreg,
+      .fb_blank      = md050sd_blank,
+};
+
+static struct fb_fix_screeninfo md050sd_fix __initdata = {
+      .id            = "MD050SD",
+      .type          = FB_TYPE_PACKED_PIXELS,
+      .visual        = FB_VISUAL_TRUECOLOR,
+      .accel         = FB_ACCEL_NONE,
+      .line_length   = 800 * 2,
+};
+
+static struct fb_var_screeninfo md050sd_var __initdata = {
+      .xres = 800,
+      .yres = 480,
+      .xres_virtual = 800,
+      .yres_virtual = 480,
+      .width = 800,
+      .height = 480,
+      .bits_per_pixel = 16,
+      .red = {11, 5, 0},
+      .green = {5, 6, 0},
+      .blue = {0, 5, 0},
+      .activate = FB_ACTIVATE_NOW,
+      .vmode = FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_deferred_io md050sd_defio = {
+      .delay = HZ / 20,
+      .deferred_io = &md050sd_update,
+};
+
+static int __init md050sd_probe(struct platform_device *dev)
+{
+   int ret = 0;
+   struct md050sd *item;
+   struct resource *ctrl_res;
+   struct resource *data_res;
+   unsigned int ctrl_res_size;
+   unsigned int data_res_size;
+   struct resource *ctrl_req;
+   struct resource *data_req;
+   unsigned short int id[6];
+   struct fb_info *info;
+
+   dev_dbg(&dev->dev, "%s\n", __func__);
+
+   item = kzalloc(sizeof(struct md050sd), GFP_KERNEL);
+   if (!item) {
+      dev_err(&dev->dev,
+            "%s: unable to kzalloc for md050sd\n", __func__);
+      ret = -ENOMEM;
+      goto out;
+   }
+   item->dev = &dev->dev;
+   dev_set_drvdata(&dev->dev, item);
+   item->backlight = 1;
+
+   ctrl_res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+   if (!ctrl_res) {
+      dev_err(&dev->dev,
+            "%s: unable to platform_get_resource for ctrl_res\n",
+            __func__);
+      ret = -ENOENT;
+      goto out_item;
+   }
+   ctrl_res_size = ctrl_res->end - ctrl_res->start + 1;
+   ctrl_req = request_mem_region(ctrl_res->start, ctrl_res_size,
+         dev->name);
+   if (!ctrl_req) {
+      dev_err(&dev->dev,
+            "%s: unable to request_mem_region for ctrl_req\n",
+            __func__);
+      ret = -EIO;
+      goto out_item;
+   }
+
+   /* Now that we're sure that we own the memory bus... reset timings */
+   MPMC_STCONFIG0  = 0x81;
+   MPMC_STWTWEN0   = 13;
+   MPMC_STWTOEN0   = 0;
+   MPMC_STWTRD0    = 0;
+   MPMC_STWTPG0    = 0;
+   MPMC_STWTWR0    = 15;
+   MPMC_STWTTURN0  = 0;
+
+   item->ctrl_io = ioremap(ctrl_res->start, ctrl_res_size);
+   if (!item->ctrl_io) {
+      ret = -EINVAL;
+      dev_err(&dev->dev,
+            "%s: unable to ioremap for ctrl_io\n", __func__);
+      goto out_item;
+   }
+
+   data_res = platform_get_resource(dev, IORESOURCE_MEM, 1);
+   if (!data_res) {
+      dev_err(&dev->dev,
+            "%s: unable to platform_get_resource for data_res\n",
+            __func__);
+      ret = -ENOENT;
+      goto out_item;
+   }
+   data_res_size = data_res->end - data_res->start + 1;
+   data_req = request_mem_region(data_res->start,
+         data_res_size, dev->name);
+   if (!data_req) {
+      dev_err(&dev->dev,
+            "%s: unable to request_mem_region for data_req\n",
+            __func__);
+      ret = -EIO;
+      goto out_item;
+   }
+   item->data_io = ioremap(data_res->start, data_res_size);
+   if (!item->data_io) {
+      ret = -EINVAL;
+      dev_err(&dev->dev,
+            "%s: unable to ioremap for data_io\n", __func__);
+      goto out_item;
+   }
+
+   dev_dbg(&dev->dev, "%s: ctrl_io=%p data_io=%p\n",
+         __func__, item->ctrl_io, item->data_io);
+
+   dev_info(&dev->dev, "item=0x%p ctrl=0x%p data=0x%p\n", (void *)item,
+         (void *)ctrl_res->start, (void *)data_res->start);
+
+   info = framebuffer_alloc(sizeof(struct md050sd), &dev->dev);
+   if (!info) {
+      ret = -ENOMEM;
+      dev_err(&dev->dev,
+            "%s: unable to framebuffer_alloc\n", __func__);
+      goto out_item;
+   }
+   info->pseudo_palette = &item->pseudo_palette;
+   item->info = info;
+   info->par = item;
+   info->dev = &dev->dev;
+   info->fbops = &md050sd_fbops;
+   info->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;
+   info->fix = md050sd_fix;
+   info->var = md050sd_var;
+
+   ret = md050sd_video_alloc(item);
+   if (ret) {
+      dev_err(&dev->dev,
+            "%s: unable to md050sd_video_alloc\n", __func__);
+      goto out_info;
+   }
+   info->screen_base = (char __iomem *) item->info->fix.smem_start;
+
+   ret = md050sd_pages_alloc(item);
+   if (ret < 0) {
+      dev_err(&dev->dev,
+            "%s: unable to md050sd_pages_init\n", __func__);
+      goto out_video;
+   }
+
+   info->fbdefio = &md050sd_defio;
+   fb_deferred_io_init(info);
+
+   ret = register_framebuffer(info);
+   if (ret < 0) {
+      dev_err(&dev->dev,
+            "%s: unable to register_frambuffer\n", __func__);
+      goto out_pages;
+   }
+
+
+   md050sd_setup(item);
+   md050sd_update_all(item);
+
+   return ret;
+
+   out_pages:
+   md050sd_pages_free(item);
+   out_video:
+   md050sd_video_free(item);
+   out_info:
+   framebuffer_release(info);
+   out_item:
+   kfree(item);
+   out:
+   return ret;
+}
+
+
+static int md050sd_remove(struct platform_device *dev)
+{
+   struct fb_info *info = dev_get_drvdata(&dev->dev);
+   struct md050sd *item = (struct md050sd *) info->par;
+   unregister_framebuffer(info);
+   md050sd_pages_free(item);
+   md050sd_video_free(item);
+   framebuffer_release(info);
+   kfree(item);
+   return 0;
+}
+
+#ifdef CONFIG_PM
+static int md050sd_suspend(struct platform_device *dev, pm_message_t state)
+{
+   //      struct fb_info *info = dev_get_drvdata(&spi->dev);
+   //      struct md050sd *item = (struct md050sd *)info->par;
+   /* enter into sleep mode */
+
+   return 0;
+}
+
+static int md050sd_resume(struct platform_device *dev)
+{
+   //      struct fb_info *info = dev_get_drvdata(&spi->dev);
+   //      struct md050sd *item = (struct md050sd *)info->par;
+   /* leave sleep mode */
+
+   return 0;
+}
+#else
+#define md050sd_suspend NULL
+#define md050sd_resume NULL
+#endif
+
+static struct platform_driver md050sd_driver = {
+      .probe = md050sd_probe,
+      .remove = md050sd_remove,
+      .driver = {
+            .name = "md050sd",
+      },
+};
+
+static int __init md050sd_init(void)
+{
+   int ret = 0;
+
+   pr_debug("%s\n", __func__);
+
+   ret = platform_driver_register(&md050sd_driver);
+   if (ret) {
+      pr_err("%s: unable to platform_driver_register\n",
+            __func__);
+   }
+
+   return ret;
+}
+
+module_init(md050sd_init);
+module_remove(md050sd_remove);
+
+
+MODULE_DESCRIPTION("MD050SD LCD Driver");
+MODULE_AUTHOR("Jeroen Domburg <jeroen@spritesmods.com>");
+MODULE_AUTHOR("Armin Schlegel <armin.schlegel@gmx.de");
+MODULE_LICENSE("GPL");
diff -uNr linux-2.6.33-lpc313x-vanilla/drivers/video/ssd1289.c linux-2.6.33-lpc313x/drivers/video/ssd1289.c
--- linux-2.6.33-lpc313x-vanilla/drivers/video/ssd1289.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-lpc313x/drivers/video/ssd1289.c	2014-05-08 15:52:21.686434515 +0200
@@ -0,0 +1,823 @@
+/*
+ * SSD1289 Framebuffer
+ *
+ *
+ * Copyright (c) 2014 Armin Schlegel <armin.schlegel@gmx.de>
+ * Original: Copyright (c) 2009 Jean-Christian de Rivaz
+ * Original: Copyright (c) 2012 Jeroen Domburg <jeroen@spritesmods.com>
+ *
+ * This is an adaption from the ili9325.c from Jeroen Domburg to work with
+ * the SSD1289 controller.
+ * Bits and pieces borrowed from the fsl-ili9325.c:
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Author: Alison Wang <b18965@freescale.com>
+ *         Jason Jin <Jason.jin@freescale.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * For direct I/O-mode:
+ *
+ * This driver expect the SSD1289 to be connected to a 16 bits local bus
+ * and to be set in the 16 bits parallel interface mode. To use it you must
+ * define in your board file a struct platform_device with a name set to
+ * "ssd1289" and a struct resource array with two IORESOURCE_MEM: the first
+ * for the control register; the second for the data register.
+ *
+ */
+
+
+#include <linux/kernel.h>
+//#define DEBUG 1
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/fb.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+
+
+#define LED_ENABLE_PIN  20
+#define LED_RESET_PIN  19
+
+#define USE_MEMCPY   0
+
+#define SSD1289_WIDTH                      240
+#define SSD1289_HEIGHT                     320
+
+struct ssd1289_page {
+   unsigned short x;
+   unsigned short y;
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned short len;
+   int must_update;
+};
+
+struct ssd1289 {
+   struct device *dev;
+   struct fb_info *info;
+   unsigned int pages_count;
+   struct ssd1289_page *pages;
+   unsigned long pseudo_palette[17];
+   int backlight;
+   volatile unsigned short *ctrl_io;
+   volatile unsigned short *data_io;
+};
+
+/* Warnig must be: HEIGHT % Lines_per_page == 0 */
+#define SSD1289_LINES_PER_PAGE  16
+
+/* Warning: do not modify this settings! */
+#define SSD1289_BYTES_PER_PIXEL         2
+#define SSD1289_PAGE_SIZE  (SSD1289_LINES_PER_PAGE * SSD1289_WIDTH * SSD1289_BYTES_PER_PIXEL)
+
+inline void ssd1289_send_cmd(struct ssd1289 *item, unsigned short cmd)
+{
+   writew(cmd & 0xFF, item->ctrl_io );
+}
+
+
+inline void ssd1289_send_data(struct ssd1289 *item, unsigned short data)
+{
+   writew(data, item->data_io);
+}
+
+inline void ssd1289_write_reg(struct ssd1289 *item, unsigned short cmd, unsigned short data)
+{
+   writew(cmd & 0xFF, item->ctrl_io );
+   msleep(10);
+   writew(data, item->data_io);
+   msleep(10);
+}
+
+
+
+void ssd1289_setWindow(struct ssd1289 *item, unsigned short xs, unsigned short ys, unsigned short xe, unsigned short ye)
+{
+   ssd1289_send_cmd(item, 0x0044);
+   ssd1289_send_data(item, xe << 8 + xs);
+   ssd1289_send_cmd(item, 0x0045);
+   ssd1289_send_data(item, ys);
+   ssd1289_send_cmd(item, 0x0046);
+   ssd1289_send_data(item, ye);
+
+   ssd1289_send_cmd(item, 0x004E);
+   ssd1289_send_data(item, xs);
+   ssd1289_send_cmd(item, 0x004F);
+   ssd1289_send_data(item, ys);
+
+   ssd1289_send_cmd(item, 0x0022);
+}
+
+void ssd1289_setPointer(struct ssd1289 *item, unsigned short x, unsigned short y)
+{
+   ssd1289_send_cmd(item, 0x004E);
+   ssd1289_send_data(item, x);
+   ssd1289_send_cmd(item, 0x004F);
+   ssd1289_send_data(item, y);
+
+   ssd1289_send_cmd(item, 0x0022);
+}
+
+void ssd1289_copy(struct ssd1289 *item, unsigned int index)
+{
+#define PIXELGROUPLEN 40
+   unsigned short x;
+   unsigned short y;
+   unsigned short y_local;
+
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned int len;
+   //   unsigned int count;
+   unsigned short j;
+   unsigned short tmpy;
+   unsigned short xend;
+   //int pageModified = 0;
+   x = item->pages[index].x;
+   y = item->pages[index].y;
+   buffer = item->pages[index].buffer;
+   oldbuffer = item->pages[index].oldbuffer;
+   len = item->pages[index].len;
+   dev_dbg(item->dev,
+         "%s: page[%u]: x=%3hu y=%3hu buffer=0x%p len=%3hu\n",
+         __func__, index, x, y, buffer, len);
+#if USE_MEMCPY == 0
+   tmpy = 0;
+   xend = 0;
+   for (y_local = y; y_local < y + SSD1289_LINES_PER_PAGE; y_local++)
+   {
+      for (x = 0; x < SSD1289_WIDTH; x++)
+      {
+         if (buffer[x + tmpy * SSD1289_WIDTH] != oldbuffer[x + tmpy * SSD1289_WIDTH])
+         {
+            if ((x + PIXELGROUPLEN) > SSD1289_WIDTH)
+            {
+               xend = SSD1289_WIDTH - 1;
+            }
+            else
+               xend = x + PIXELGROUPLEN;
+//            ssd1289_setPointer(item, x, y);
+            //            ssd1289_setWindow(item, x, y_local, xend, y_local);
+            for (j = x; j <= xend; j++)
+            {
+               ssd1289_setPointer(item, j, y);
+               ssd1289_send_data(item, buffer[j + tmpy * SSD1289_WIDTH]);
+               oldbuffer[j + tmpy * SSD1289_WIDTH] = buffer[j + tmpy * SSD1289_WIDTH];
+            }
+            x = xend;
+         }
+      }
+      tmpy++;
+   }
+#else
+   //ssd1289_setPointer(item, x, y);
+   ssd1289_setWindow(item, x, SSD1289_WIDTH, y, y + SSD1289_LINES_PER_PAGE);
+   memcpy(item->data_io, buffer, len * 2);
+#endif
+}
+
+static void ssd1289_update_all(struct ssd1289 *item)
+{
+   unsigned short i;
+   struct fb_deferred_io *fbdefio = item->info->fbdefio;
+   for (i = 0; i < item->pages_count; i++) {
+      item->pages[i].must_update = 1;
+   }
+   //printk(KERN_ALERT "ssd1289_update_all () occurred!\n");
+   schedule_delayed_work(&item->info->deferred_work, fbdefio->delay);
+}
+
+static void ssd1289_update(struct fb_info *info,
+      struct list_head *pagelist)
+{
+   struct ssd1289 *item = (struct ssd1289 *) info->par;
+   struct page *page;
+   int i;
+
+   //We can be called because of pagefaults (mmap'ed framebuffer, pages
+   //returned in *pagelist) or because of kernel activity
+   //(pages[i]/must_update!=0). Add the former to the list of the latter.
+   list_for_each_entry(page, pagelist, lru) {
+      item->pages[page->index].must_update = 1;
+   }
+   //printk(KERN_ALERT "ssd1289_update() occurred!\n");
+   //Copy changed pages.
+   for (i = 0; i < item->pages_count; i++) {
+      //ToDo: Small race here between checking and setting must_update,
+      //maybe lock?
+      if (item->pages[i].must_update) {
+         item->pages[i].must_update = 0;
+         ssd1289_copy(item, i);
+      }
+   }
+
+}
+
+typedef enum
+{
+   ID00 = 0,
+   ID01 = (0b01 << 4),
+   ID10 = (0b10 << 4),
+   ID11 = (0b11 << 4)
+}IDType;
+
+typedef enum
+{
+   AM0 = 0,
+   AM1 = (1 << 3)
+}AMType;
+
+
+static void __init ssd1289_setup(struct ssd1289 *item)
+{
+   int x;
+   int y;
+   printk(KERN_ALERT "ssd1289_setup() called\n");
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   gpio_direction_output(LED_RESET_PIN, 0);
+   msleep(200);
+   gpio_direction_output(LED_RESET_PIN, 1);
+   msleep(200);
+
+   gpio_direction_output(LED_ENABLE_PIN, 1);
+
+   ssd1289_write_reg(item, 0x0000, 0x0001);
+   msleep(100);
+   ssd1289_write_reg(item, 0x0003, 0xA8A4);
+   ssd1289_write_reg(item, 0x000C, 0x0000);
+   ssd1289_write_reg(item, 0x000D, 0x080C);
+   ssd1289_write_reg(item, 0x000E, 0x2B00);
+   ssd1289_write_reg(item, 0x001E, 0x00B0);
+   ssd1289_write_reg(item, 0x0001, 0x2B3F);
+   ssd1289_write_reg(item, 0x0002, 0x0600);
+   ssd1289_write_reg(item, 0x0010, 0x0000);
+   // LANDSCAPE:
+   //      ssd1289_write_reg(item, 0x11, 0x6098 );
+   // LANDSCAPE_REV:
+   //   ssd1289_write_reg(item, 0x11, 0x60A8 );
+   // PORTRAIT_REV:
+   //ssd1289_write_reg(item, 0x11, 0x6080 );
+   // PORTRAIT:
+   //   ssd1289_write_reg(item, 0x11, 0x6070);
+   ssd1289_write_reg(item, 0x0011, 0x6000 | AM1 | ID01);
+   ssd1289_write_reg(item, 0x0005, 0x0000);
+   ssd1289_write_reg(item, 0x0006, 0x0000);
+   ssd1289_write_reg(item, 0x0016, 0xEF1C);
+   ssd1289_write_reg(item, 0x0017, 0x0003);
+   ssd1289_write_reg(item, 0x0007, 0x0233);
+   ssd1289_write_reg(item, 0x000B, 0x0000);
+   ssd1289_write_reg(item, 0x000F, 0x0000);
+   ssd1289_write_reg(item, 0x0041, 0x0000);
+   ssd1289_write_reg(item, 0x0042, 0x0000);
+   ssd1289_write_reg(item, 0x0048, 0x0000);
+   ssd1289_write_reg(item, 0x0049, 0x013F);
+   ssd1289_write_reg(item, 0x004A, 0x0000);
+   ssd1289_write_reg(item, 0x004B, 0x0000);
+   ssd1289_write_reg(item, 0x0044, 0xEF00);
+   ssd1289_write_reg(item, 0x0045, 0x0000);
+   ssd1289_write_reg(item, 0x0046, 0x013F);
+   ssd1289_write_reg(item, 0x0030, 0x0707);
+   ssd1289_write_reg(item, 0x0031, 0x0204);
+   ssd1289_write_reg(item, 0x0032, 0x0204);
+   ssd1289_write_reg(item, 0x0033, 0x0502);
+   ssd1289_write_reg(item, 0x0034, 0x0507);
+   ssd1289_write_reg(item, 0x0035, 0x0204);
+   ssd1289_write_reg(item, 0x0036, 0x0204);
+   ssd1289_write_reg(item, 0x0037, 0x0502);
+   ssd1289_write_reg(item, 0x003A, 0x0302);
+   ssd1289_write_reg(item, 0x003B, 0x0302);
+   ssd1289_write_reg(item, 0x0023, 0x0000);
+   ssd1289_write_reg(item, 0x0024, 0x0000);
+   ssd1289_write_reg(item, 0x0044, (item->info->var.xres - 1) << 8);
+   ssd1289_write_reg(item, 0x0045, 0x0000);
+   ssd1289_write_reg(item, 0x0046, (item->info->var.yres - 1));
+
+   //   ssd1289_write_reg(item, 0x004f, 0x0000);
+   //   ssd1289_write_reg(item, 0x004e, 0x0000);
+   //   ssd1289_send_cmd(item, 0x0022);
+
+   for (y = 0; y < SSD1289_HEIGHT; y++)
+   {
+
+      for(x = 0; x < SSD1289_WIDTH; x++)
+      {
+         ssd1289_setPointer(item, x, y);
+         ssd1289_send_data(item, 0x123);
+      }
+   }
+
+      msleep(1000);
+   printk(KERN_ALERT
+         "ssd1289_setup() end: pages_count: %d, item->pages[x].len: %d\n\n",
+         item->pages_count, item->pages[0].len);
+}
+
+//This routine will allocate the buffer for the complete framebuffer. This
+//is one continuous chunk of 16-bit pixel values; userspace programs
+//will write here.
+static int __init ssd1289_video_alloc(struct ssd1289 *item)
+{
+   unsigned int frame_size;
+
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   frame_size = item->info->fix.line_length * item->info->var.yres;
+   dev_dbg(item->dev, "%s: item=0x%p frame_size=%u\n",
+         __func__, (void *) item, frame_size);
+
+   item->pages_count = frame_size / SSD1289_PAGE_SIZE;
+   if ((item->pages_count * SSD1289_PAGE_SIZE) < frame_size) {
+      item->pages_count++;
+   }
+   dev_dbg(item->dev, "%s: item=0x%p pages_count=%u\n",
+         __func__, (void *) item, item->pages_count);
+
+   item->info->fix.smem_len = item->pages_count * SSD1289_PAGE_SIZE;
+   item->info->fix.smem_start =
+         (unsigned long) vmalloc(item->info->fix.smem_len);
+   if (!item->info->fix.smem_start) {
+      dev_err(item->dev, "%s: unable to vmalloc\n", __func__);
+      return -ENOMEM;
+   }
+   memset((void *) item->info->fix.smem_start, 0,
+         item->info->fix.smem_len);
+
+   return 0;
+}
+
+static void ssd1289_video_free(struct ssd1289 *item)
+{
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   kfree((void *) item->info->fix.smem_start);
+}
+
+//This routine will allocate a ssd1289_page struct for each vm page in the
+//main framebuffer memory. Each struct will contain a pointer to the page
+//start, an x- and y-offset, and the length of the pagebuffer which is in the framebuffer.
+static int __init ssd1289_pages_alloc(struct ssd1289 *item)
+{
+   unsigned short pixels_per_page;
+   unsigned short yoffset_per_page;
+   unsigned short xoffset_per_page;
+   unsigned int index;
+   unsigned short x = 0;
+   unsigned short y = 0;
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned int len;
+
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   item->pages =
+         kmalloc(item->pages_count * sizeof(struct ssd1289_page),
+               GFP_KERNEL);
+   if (!item->pages) {
+      dev_err(item->dev,
+            "%s: unable to kmalloc for ssd1289_page\n",
+            __func__);
+      return -ENOMEM;
+   }
+
+   pixels_per_page =
+         SSD1289_PAGE_SIZE / (item->info->var.bits_per_pixel / 8);
+   yoffset_per_page = pixels_per_page / item->info->var.xres;
+   xoffset_per_page = pixels_per_page -
+         (yoffset_per_page * item->info->var.xres);
+   dev_dbg(item->dev, "%s: item=0x%p pixels_per_page=%hu "
+         "yoffset_per_page=%hu xoffset_per_page=%hu\n",
+         __func__, (void *) item, pixels_per_page,
+         yoffset_per_page, xoffset_per_page);
+
+   oldbuffer = kmalloc(item->pages_count * pixels_per_page * 2,
+         GFP_KERNEL);
+   if (!oldbuffer) {
+      dev_err(item->dev,
+            "%s: unable to kmalloc for ssd1289_page oldbuffer\n",
+            __func__);
+      return -ENOMEM;
+   }
+
+   buffer = (unsigned short *) item->info->fix.smem_start;
+   for (index = 0; index < item->pages_count; index++) {
+      len = (item->info->var.xres * item->info->var.yres) -
+            (index * pixels_per_page);
+      if (len > pixels_per_page) {
+         len = pixels_per_page;
+      }
+      dev_dbg(item->dev,
+            "%s: page[%d]: x=%3hu y=%3hu buffer=0x%p len=%3hu\n",
+            __func__, index, x, y, buffer, len);
+      item->pages[index].x = x;
+      item->pages[index].y = y;
+      item->pages[index].buffer = buffer;
+      item->pages[index].oldbuffer = oldbuffer;
+      item->pages[index].len = len;
+
+      x += xoffset_per_page;
+      if (x >= item->info->var.xres) {
+         y++;
+         x -= item->info->var.xres;
+      }
+      y += yoffset_per_page;
+      buffer += pixels_per_page;
+      oldbuffer += pixels_per_page;
+   }
+
+   return 0;
+}
+
+static void ssd1289_pages_free(struct ssd1289 *item)
+{
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   kfree(item->pages);
+}
+
+static inline __u32 CNVT_TOHW(__u32 val, __u32 width)
+{
+   return ((val << width) + 0x7FFF - val) >> 16;
+}
+
+//This routine is needed because the console driver won't work without it.
+static int ssd1289_setcolreg(unsigned regno,
+      unsigned red, unsigned green, unsigned blue,
+      unsigned transp, struct fb_info *info)
+{
+   int ret = 1;
+
+   /*
+    * If greyscale is true, then we convert the RGB value
+    * to greyscale no matter what visual we are using.
+    */
+   if (info->var.grayscale)
+      red = green = blue = (19595 * red + 38470 * green +
+            7471 * blue) >> 16;
+   switch (info->fix.visual) {
+   case FB_VISUAL_TRUECOLOR:
+      if (regno < 16) {
+         u32 *pal = info->pseudo_palette;
+         u32 value;
+
+         red = CNVT_TOHW(red, info->var.red.length);
+         green = CNVT_TOHW(green, info->var.green.length);
+         blue = CNVT_TOHW(blue, info->var.blue.length);
+         transp =
+               CNVT_TOHW(transp, info->var.transp.length);
+
+         value = (red << info->var.red.offset) |
+               (green << info->var.green.offset) |
+               (blue << info->var.blue.offset) |
+               (transp << info->var.transp.offset);
+
+         pal[regno] = value;
+         ret = 0;
+      }
+      break;
+   case FB_VISUAL_STATIC_PSEUDOCOLOR:
+   case FB_VISUAL_PSEUDOCOLOR:
+      break;
+   }
+   return ret;
+}
+
+static int ssd1289_blank(int blank_mode, struct fb_info *info)
+{
+   struct ssd1289 *item = (struct ssd1289 *) info->par;
+   if (blank_mode == FB_BLANK_UNBLANK)
+      item->backlight = 1;
+   else
+      item->backlight = 0;
+   //Item->backlight won't take effect until the LCD is written to. Force that
+   //by dirty'ing a page.
+   item->pages[0].must_update = 1;
+   //printk(KERN_ALERT "ssd1289_blank() occurred!\n");
+   schedule_delayed_work(&info->deferred_work, 0);
+   return 0;
+}
+
+static void ssd1289_touch(struct fb_info *info, int x, int y, int w, int h)
+{
+   struct fb_deferred_io *fbdefio = info->fbdefio;
+   struct ssd1289 *item = (struct ssd1289 *) info->par;
+   int i, ystart, yend;
+   if (fbdefio) {
+      //Touch the pages the y-range hits, so the deferred io will update them.
+      for (i = 0; i < item->pages_count; i++) {
+         ystart = item->pages[i].y;
+         yend =
+               item->pages[i].y +
+               (item->pages[i].len / info->fix.line_length) +
+               1;
+         if (!((y + h) < ystart || y > yend)) {
+            item->pages[i].must_update = 1;
+         }
+      }
+      //Schedule the deferred IO to kick in after a delay.
+      schedule_delayed_work(&info->deferred_work,
+            fbdefio->delay);
+   }
+}
+
+static void ssd1289_fillrect(struct fb_info *p,
+      const struct fb_fillrect *rect)
+{
+   sys_fillrect(p, rect);
+   ssd1289_touch(p, rect->dx, rect->dy, rect->width, rect->height);
+}
+
+static void ssd1289_imageblit(struct fb_info *p,
+      const struct fb_image *image)
+{
+   sys_imageblit(p, image);
+   ssd1289_touch(p, image->dx, image->dy, image->width,
+         image->height);
+}
+
+static void ssd1289_copyarea(struct fb_info *p,
+      const struct fb_copyarea *area)
+{
+   sys_copyarea(p, area);
+   ssd1289_touch(p, area->dx, area->dy, area->width, area->height);
+}
+
+static ssize_t ssd1289_write(struct fb_info *p, const char __user * buf,
+      size_t count, loff_t * ppos)
+{
+   ssize_t res;
+   res = fb_sys_write(p, buf, count, ppos);
+   ssd1289_touch(p, 0, 0, p->var.xres, p->var.yres);
+   return res;
+}
+
+static struct fb_ops ssd1289_fbops = {
+      .owner         = THIS_MODULE,
+      .fb_read       = fb_sys_read,
+      .fb_write      = ssd1289_write,
+      .fb_fillrect   = ssd1289_fillrect,
+      .fb_copyarea   = ssd1289_copyarea,
+      .fb_imageblit  = ssd1289_imageblit,
+      .fb_setcolreg  = ssd1289_setcolreg,
+      .fb_blank      = ssd1289_blank,
+};
+
+static struct fb_fix_screeninfo ssd1289_fix __initdata = {
+      .id            = "SSD1289",
+      .type          = FB_TYPE_PACKED_PIXELS,
+      .visual        = FB_VISUAL_TRUECOLOR,
+      .accel         = FB_ACCEL_NONE,
+      .line_length   = 240 * 2,
+};
+
+static struct fb_var_screeninfo ssd1289_var __initdata = {
+      .xres = 240,
+      .yres = 320,
+      .xres_virtual = 240,
+      .yres_virtual = 320,
+      .width = 240,
+      .height = 320,
+      .bits_per_pixel = 16,
+      .red = {11, 5, 0},
+      .green = {5, 6, 0},
+      .blue = {0, 5, 0},
+      .activate = FB_ACTIVATE_NOW,
+      .vmode = FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_deferred_io ssd1289_defio = {
+      .delay = HZ / 20,
+      .deferred_io = &ssd1289_update,
+};
+
+static int __init ssd1289_probe(struct platform_device *dev)
+{
+   int ret = 0;
+   struct ssd1289 *item;
+   struct resource *ctrl_res;
+   struct resource *data_res;
+   unsigned int ctrl_res_size;
+   unsigned int data_res_size;
+   struct resource *ctrl_req;
+   struct resource *data_req;
+   unsigned short int id[6];
+   struct fb_info *info;
+
+   dev_dbg(&dev->dev, "%s\n", __func__);
+
+   item = kzalloc(sizeof(struct ssd1289), GFP_KERNEL);
+   if (!item) {
+      dev_err(&dev->dev,
+            "%s: unable to kzalloc for ssd1289\n", __func__);
+      ret = -ENOMEM;
+      goto out;
+   }
+   item->dev = &dev->dev;
+   dev_set_drvdata(&dev->dev, item);
+   item->backlight = 1;
+
+   ctrl_res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+   if (!ctrl_res) {
+      dev_err(&dev->dev,
+            "%s: unable to platform_get_resource for ctrl_res\n",
+            __func__);
+      ret = -ENOENT;
+      goto out_item;
+   }
+   ctrl_res_size = ctrl_res->end - ctrl_res->start + 1;
+   ctrl_req = request_mem_region(ctrl_res->start, ctrl_res_size,
+         dev->name);
+   if (!ctrl_req) {
+      dev_err(&dev->dev,
+            "%s: unable to request_mem_region for ctrl_req\n",
+            __func__);
+      ret = -EIO;
+      goto out_item;
+   }
+
+   //   /* Now that we're sure that we own the memory bus... reset timings */
+   //   MPMC_STCONFIG0  = 0x81;
+   //   MPMC_STWTWEN0   = 0;
+   //   MPMC_STWTOEN0   = 0;
+   //   MPMC_STWTRD0    = 15;
+   //   MPMC_STWTPG0    = 0;
+   //   MPMC_STWTWR0    = 4;
+   //   MPMC_STWTTURN0  = 0;
+
+   item->ctrl_io = ioremap(ctrl_res->start, ctrl_res_size);
+   if (!item->ctrl_io) {
+      ret = -EINVAL;
+      dev_err(&dev->dev,
+            "%s: unable to ioremap for ctrl_io\n", __func__);
+      goto out_item;
+   }
+
+   data_res = platform_get_resource(dev, IORESOURCE_MEM, 1);
+   if (!data_res) {
+      dev_err(&dev->dev,
+            "%s: unable to platform_get_resource for data_res\n",
+            __func__);
+      ret = -ENOENT;
+      goto out_item;
+   }
+   data_res_size = data_res->end - data_res->start + 1;
+   data_req = request_mem_region(data_res->start,
+         data_res_size, dev->name);
+   if (!data_req) {
+      dev_err(&dev->dev,
+            "%s: unable to request_mem_region for data_req\n",
+            __func__);
+      ret = -EIO;
+      goto out_item;
+   }
+   item->data_io = ioremap(data_res->start, data_res_size);
+   if (!item->data_io) {
+      ret = -EINVAL;
+      dev_err(&dev->dev,
+            "%s: unable to ioremap for data_io\n", __func__);
+      goto out_item;
+   }
+
+   dev_dbg(&dev->dev, "%s: ctrl_io=%p data_io=%p\n",
+         __func__, item->ctrl_io, item->data_io);
+
+   dev_info(&dev->dev, "item=0x%p ctrl=0x%p data=0x%p\n", (void *)item,
+         (void *)ctrl_res->start, (void *)data_res->start);
+
+   info = framebuffer_alloc(sizeof(struct ssd1289), &dev->dev);
+   if (!info) {
+      ret = -ENOMEM;
+      dev_err(&dev->dev,
+            "%s: unable to framebuffer_alloc\n", __func__);
+      goto out_item;
+   }
+   info->pseudo_palette = &item->pseudo_palette;
+   item->info = info;
+   info->par = item;
+   info->dev = &dev->dev;
+   info->fbops = &ssd1289_fbops;
+   info->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;
+   info->fix = ssd1289_fix;
+   info->var = ssd1289_var;
+
+   ret = ssd1289_video_alloc(item);
+   if (ret) {
+      dev_err(&dev->dev,
+            "%s: unable to ssd1289_video_alloc\n", __func__);
+      goto out_info;
+   }
+   info->screen_base = (char __iomem *) item->info->fix.smem_start;
+
+   ret = ssd1289_pages_alloc(item);
+   if (ret < 0) {
+      dev_err(&dev->dev,
+            "%s: unable to ssd1289_pages_init\n", __func__);
+      goto out_video;
+   }
+
+   info->fbdefio = &ssd1289_defio;
+   fb_deferred_io_init(info);
+
+   ret = register_framebuffer(info);
+   if (ret < 0) {
+      dev_err(&dev->dev,
+            "%s: unable to register_frambuffer\n", __func__);
+      goto out_pages;
+   }
+
+
+   ssd1289_setup(item);
+   ssd1289_update_all(item);
+
+   return ret;
+
+   out_pages:
+   ssd1289_pages_free(item);
+   out_video:
+   ssd1289_video_free(item);
+   out_info:
+   framebuffer_release(info);
+   out_item:
+   kfree(item);
+   out:
+   return ret;
+}
+
+
+static int ssd1289_remove(struct platform_device *dev)
+{
+   struct fb_info *info = dev_get_drvdata(&dev->dev);
+   struct ssd1289 *item = (struct ssd1289 *) info->par;
+   unregister_framebuffer(info);
+   ssd1289_pages_free(item);
+   ssd1289_video_free(item);
+   framebuffer_release(info);
+   kfree(item);
+   return 0;
+}
+
+#ifdef CONFIG_PM
+static int ssd1289_suspend(struct platform_device *dev, pm_message_t state)
+{
+   //      struct fb_info *info = dev_get_drvdata(&spi->dev);
+   //      struct ssd1289 *item = (struct ssd1289 *)info->par;
+   /* enter into sleep mode */
+
+   return 0;
+}
+
+static int ssd1289_resume(struct platform_device *dev)
+{
+   //      struct fb_info *info = dev_get_drvdata(&spi->dev);
+   //      struct ssd1289 *item = (struct ssd1289 *)info->par;
+   /* leave sleep mode */
+
+   return 0;
+}
+#else
+#define ssd1289_suspend NULL
+#define ssd1289_resume NULL
+#endif
+
+static struct platform_driver ssd1289_driver = {
+      .probe = ssd1289_probe,
+      .remove = ssd1289_remove,
+      .driver = {
+            .name = "ssd1289",
+      },
+};
+
+static int __init ssd1289_init(void)
+{
+   int ret = 0;
+
+   pr_debug("%s\n", __func__);
+
+   ret = platform_driver_register(&ssd1289_driver);
+   if (ret) {
+      pr_err("%s: unable to platform_driver_register\n",
+            __func__);
+   }
+
+   return ret;
+}
+
+module_init(ssd1289_init);
+module_remove(ssd1289_remove);
+
+
+MODULE_DESCRIPTION("SSD1289 LCD Driver");
+MODULE_AUTHOR("Jeroen Domburg <jeroen@spritesmods.com>");
+MODULE_AUTHOR("Armin Schlegel <armin.schlegel@gmx.de");
+MODULE_LICENSE("GPL");
diff -uNr linux-2.6.33-lpc313x-vanilla/drivers/video/ssd1963.c linux-2.6.33-lpc313x/drivers/video/ssd1963.c
--- linux-2.6.33-lpc313x-vanilla/drivers/video/ssd1963.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-lpc313x/drivers/video/ssd1963.c	2014-04-29 11:26:44.843641869 +0200
@@ -0,0 +1,979 @@
+/*
+* SSD1963 Framebuffer
+*
+*
+* Copyright (c) 2013 Armin Schlegel <armin.schlegel@gmx.de>
+* Original: Copyright (c) 2009 Jean-Christian de Rivaz
+* Original: Copyright (c) 2012 Jeroen Domburg <jeroen@spritesmods.com>
+*
+* This is an adaption from the ili9325.c from Jeroen Domburg to work with
+* the SSD1963 controller.
+* Bits and pieces borrowed from the fsl-ili9325.c:
+* Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+* Author: Alison Wang <b18965@freescale.com>
+*         Jason Jin <Jason.jin@freescale.com>
+*
+* This file is subject to the terms and conditions of the GNU General Public
+* License.  See the file "COPYING" in the main directory of this archive
+* for more details.
+*
+* The Solomon Systech SSD1963 chip drive TFT screen with a resolution of 480x272.
+*
+* For direct I/O-mode:
+*
+* This driver expect the SSD1963 to be connected to a 16 bits local bus
+* and to be set in the 16 bits parallel interface mode. To use it you must
+* define in your board file a struct platform_device with a name set to
+* "ssd1963" and a struct resource array with two IORESOURCE_MEM: the first
+* for the control register; the second for the data register.
+*
+*/
+
+
+#include <linux/kernel.h>
+//#define DEBUG 1
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/fb.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+
+
+#define LED_ENABLE_PIN  20
+
+/* TFT Controler Register defines */
+#define NOCMD                 0xFFFF
+#define NOPARAM               0
+#define PARAM                 1
+
+
+#define SSD1963_NOP           0x0000
+#define SOFT_RESET            0x0001
+#define GET_POWER_MODE        0x000A
+#define GET_ADDRESS_MODE      0x000B
+#define GET_PIXEL_FORMAT      0x000C
+#define GET_DISPLAY_MODE      0x000D
+#define GET_SIGNAL_MODE       0x000E
+#define ENTER_SLEEP_MODE      0x0010
+#define EXIT_SLEEP_MODE       0x0011
+#define ENTER_PARTIAL_MODE    0x0012
+#define ENTER_NORMAL_MODE     0x0013
+#define EXIT_INVERT_MODE      0x0020
+#define ENTER_INVERT_MODE     0x0021
+#define SET_GAMMA_CURVE       0x0026
+#define SET_DISPLAY_OFF       0x0028
+#define SET_DISPLAY_ON        0x0029
+#define SET_COLUMN_ADDRESS    0x002A
+#define SET_PAGE_ADDRESS      0x002B
+#define WRITE_MEMORY_START    0x002C
+#define READ_MEMORY_START     0x002E
+#define SET_PARTIAL_AERA      0x0030
+#define SET_SCROLL_AREA       0x0033
+#define SET_TEAR_OFF          0x0034
+#define SET_TEAR_ON           0x0035
+#define SET_ADDRESS_MODE      0x0036
+#define SET_SCROLL_START      0x0037
+#define EXIT_IDLE_MODE        0x0038
+#define ENTER_IDLE_MODE       0x0039
+#define SET_PIXEL_FORMAT      0x003A
+#define WRITE_MEMORY_CONTINUE 0x003C
+#define READ_MEMORY_CONTINUE  0x003E
+#define SET_TEAR_SCNALINE     0x0044
+#define GET_SCANLINE          0x0045
+#define READ_DDB              0x00A1
+#define SET_LCD_MODE          0x00B0
+#define GET_LCD_MODE          0x00B1
+#define SET_HORI_PERIOD       0x00B4
+#define GET_HORI_PERIOD       0x00B5
+#define SET_VERT_PERIOD       0x00B6
+#define GET_VERT_PERIOD       0x00B7
+#define SET_GPIO_CONF         0x00B8
+#define GET_GPIO_CONF         0x00B9
+#define SET_GPIO_VALUE        0x00BA
+#define GET_GPIO_STATUS       0x00BB
+#define SET_POST_PROC         0x00BC
+#define GET_POST_PROC         0x00BD
+#define SET_PWM_CONF          0x00BE
+#define GET_PWM_CONF          0x00BF
+#define SET_LCD_GEN0          0x00C0
+#define GET_LCD_GEN0          0x00C1
+#define SET_LCD_GEN1          0x00C2
+#define GET_LCD_GEN1          0x00C3
+#define SET_LCD_GEN2          0x00C4
+#define GET_LCD_GEN2          0x00C5
+#define SET_LCD_GEN3          0x00C6
+#define GET_LCD_GEN3          0x00C7
+#define SET_GPIO0_ROP         0x00C8
+#define GET_GPIO0_ROP         0x00C9
+#define SET_GPIO1_ROP         0x00CA
+#define GET_GPIO1_ROP         0x00CB
+#define SET_GPIO2_ROP         0x00CC
+#define GET_GPIO2_ROP         0x00CD
+#define SET_GPIO3_ROP         0x00CE
+#define GET_GPIO3_ROP         0x00CF
+#define SET_DBC_CONF          0x00D0
+#define GET_DBC_CONF          0x00D1
+#define SET_DBC_TH            0x00D4
+#define GET_DBC_TH            0x00D5
+#define SET_PLL               0x00E0
+#define SET_PLL_MN            0x00E2
+#define GET_PLL_MN            0x00E3
+#define GET_PLL_STATUS        0x00E4
+#define SET_DEEP_SLEEP        0x00E5
+#define SET_LSHIFT_FREQ       0x00E6
+#define GET_LSHIFT_FREQ       0x00E7
+#define SET_PIXEL_DATA_INTERFACE 0x00F0
+#define GET_PIXEL_DATA_INTERFACE 0x00F1
+
+
+
+#define WIDTH                      480
+#define HEIGHT                     272
+
+#define HDP                        479        //479
+#define HT                         525        //531
+#define HPS                        40         //43
+#define LPS                        6           //8
+#define HPW                        39         //10
+                                              //
+#define VDP                        271        //271
+#define VT                         288        //288
+#define VPS                        12         //12
+#define FPS                        8          //4
+#define VPW                        11         //10
+
+
+struct ssd1963_page {
+   unsigned short x;
+   unsigned short y;
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned short len;
+   int must_update;
+};
+
+struct ssd1963 {
+   struct device *dev;
+   struct fb_info *info;
+   unsigned int pages_count;
+   struct ssd1963_page *pages;
+   unsigned long pseudo_palette[17];
+   int backlight;
+   volatile unsigned short *ctrl_io;
+   volatile unsigned short *data_io;
+};
+
+//#define SSD1963_PAGE_SIZE  (2048*2)
+#define SSDD1963_LINES_PER_PAGE  32
+#define SSD1963_PAGE_SIZE  (SSDD1963_LINES_PER_PAGE*WIDTH*2)
+
+//#define SSD1963_PAGE_SIZE  (480*2)
+
+
+
+inline void ssd1963_send_cmd(struct ssd1963 *item, unsigned short cmd)
+{
+   unsigned short ctrl = cmd & 0x00ff;
+   writew(ctrl, item->ctrl_io);
+}
+
+
+inline void ssd1963_send_data(struct ssd1963 *item, unsigned short data)
+{
+   writew(data, item->data_io);
+}
+
+
+
+void ssd1963_setDisplayRegister
+    (struct ssd1963 *item,
+     unsigned short tft_register_ui16,
+     unsigned short tft_registerValue_ui16,
+     unsigned short tft_registerParameters_ui16)
+{
+   /* First send Command if it is != NOCMD */
+   if (tft_register_ui16 != NOCMD) {
+      ssd1963_send_cmd(item, tft_register_ui16);
+   }
+   /* Then send or continue sending Parameter to tft controler if needed */
+   if (tft_registerParameters_ui16 != NOPARAM) {
+      ssd1963_send_cmd(item, tft_registerValue_ui16);
+   }
+}
+
+void ssd1963_setWindow(struct ssd1963 *item, unsigned short xs, unsigned short ys,
+             unsigned short xe, unsigned short ye)
+{
+   ssd1963_send_cmd(item, SET_COLUMN_ADDRESS);
+   ssd1963_send_data(item, (xs & 0xFF00) >> 8);
+   ssd1963_send_data(item, (xs & 0x00FF));
+   ssd1963_send_data(item, (xe & 0xFF00) >> 8);
+   ssd1963_send_data(item, (xe & 0x00FF));
+
+   ssd1963_send_cmd(item, SET_PAGE_ADDRESS);
+   ssd1963_send_data(item, (ys & 0xFF00) >> 8);
+   ssd1963_send_data(item, (ys & 0x00FF));
+   ssd1963_send_data(item, (ye & 0xFF00) >> 8);
+   ssd1963_send_data(item, (ye & 0x00FF));
+
+   ssd1963_send_cmd(item, WRITE_MEMORY_START);
+}
+
+void ssd1963_drawPixel(struct ssd1963 *item,
+                       unsigned short xPosition_ui16,
+                       unsigned short yPosition_ui16,
+                       unsigned short rectangleColor_ui16)
+{
+   /* Set window size and position - modified for portrait view */
+   ssd1963_setWindow(item, xPosition_ui16, yPosition_ui16,
+           xPosition_ui16 + 1, yPosition_ui16 + 1);
+   ssd1963_send_data(item, rectangleColor_ui16);
+}
+
+void ssd1963_copy(struct ssd1963 *item, unsigned int index)
+{
+#define PIXELGROUPLEN 40
+   unsigned short x;
+   unsigned short y;
+   unsigned short y_local;
+
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned int len;
+//   unsigned int count;
+   unsigned short j;
+   unsigned short tmpy;
+   unsigned short xend;
+   //int pageModified = 0;
+   x = item->pages[index].x;
+   y = item->pages[index].y;
+   buffer = item->pages[index].buffer;
+   oldbuffer = item->pages[index].oldbuffer;
+   len = item->pages[index].len;
+   dev_dbg(item->dev,
+      "%s: page[%u]: x=%3hu y=%3hu buffer=0x%p len=%3hu\n",
+      __func__, index, x, y, buffer, len);
+
+   tmpy = 0;
+   xend = 0;
+   for (y_local = y; y_local < y+SSDD1963_LINES_PER_PAGE; y_local++) {
+      for (x = 0; x < WIDTH; x++) {
+         if (buffer[x + tmpy * WIDTH] != oldbuffer[x + tmpy * WIDTH]) {
+            if ((x + PIXELGROUPLEN) > WIDTH) {
+               xend = WIDTH - 1;
+            } else
+               xend = x + PIXELGROUPLEN;
+            ssd1963_setWindow(item, x, y_local, xend, y_local);
+            for (j = x; j <= xend; j++) {
+               ssd1963_send_data(item, buffer[j + tmpy * WIDTH]);
+               oldbuffer[j + tmpy * WIDTH] = buffer[j + tmpy * WIDTH];
+            }
+            x = xend;
+         }
+      }
+      tmpy++;
+   }
+}
+
+static void ssd1963_update_all(struct ssd1963 *item)
+{
+   unsigned short i;
+   struct fb_deferred_io *fbdefio = item->info->fbdefio;
+   for (i = 0; i < item->pages_count; i++) {
+      item->pages[i].must_update = 1;
+   }
+   //printk(KERN_ALERT "ssd1963_update_all () occurred!\n");
+   schedule_delayed_work(&item->info->deferred_work, fbdefio->delay);
+}
+
+static void ssd1963_update(struct fb_info *info,
+            struct list_head *pagelist)
+{
+   struct ssd1963 *item = (struct ssd1963 *) info->par;
+   struct page *page;
+   int i;
+   unsigned short id[5] = {0};
+   ssd1963_send_cmd(item, READ_DDB);
+   mdelay(1);
+
+   id[0]=readw(item->data_io);
+   id[1]=readw(item->data_io);
+   id[2]=readw(item->data_io);
+   id[3]=readw(item->data_io);
+   id[4]=readw(item->data_io);
+
+   printk(KERN_ALERT "ssd1963_update signature=%02x %02x %02x %02x %02x\n",id[0],id[1],id[2],id[3],id[4]);
+
+   //We can be called because of pagefaults (mmap'ed framebuffer, pages
+   //returned in *pagelist) or because of kernel activity
+   //(pages[i]/must_update!=0). Add the former to the list of the latter.
+   list_for_each_entry(page, pagelist, lru) {
+      item->pages[page->index].must_update = 1;
+   }
+   //printk(KERN_ALERT "ssd1963_update() occurred!\n");
+   //Copy changed pages.
+   for (i = 0; i < item->pages_count; i++) {
+      //ToDo: Small race here between checking and setting must_update,
+      //maybe lock?
+      if (item->pages[i].must_update) {
+         item->pages[i].must_update = 0;
+         ssd1963_copy(item, i);
+      }
+   }
+
+}
+
+
+
+static void __init ssd1963_setup(struct ssd1963 *item)
+{
+   int x;
+   int y;
+   printk(KERN_ALERT "ssd1963_setup() called\n");
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   gpio_direction_output(LED_ENABLE_PIN, 1);
+
+   msleep(20);
+
+   ssd1963_setDisplayRegister(item, 0x00E2, 0x002D, PARAM); // PLL config
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0002, PARAM);
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0004, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, 0x00E0, 0x0001, PARAM);
+   msleep(6U);    // PLL config - continued
+   ssd1963_setDisplayRegister(item, 0x00E0, 0x0003, PARAM);
+   msleep(5U);    // PLL config - continued
+   ssd1963_setDisplayRegister(item, 0x0001, 0x0000, NOPARAM);
+   msleep(10U);      // software reset
+   ssd1963_setDisplayRegister(item, 0x00E6, 0x0000, PARAM); // LSHIFT freq
+   ssd1963_setDisplayRegister(item, NOCMD, 0x00FF, PARAM);
+   ssd1963_setDisplayRegister(item, NOCMD, 0x00BE, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, 0x00B0, 0x0020, PARAM);
+   msleep(6U);    // set lcd mode
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0000, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, ((HDP >> 8U) & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, (HDP & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, ((HDP >> 8U) & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, (VDP & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0000, PARAM);
+   msleep(5U);
+   ssd1963_setDisplayRegister(item, 0x00B4, ((HT >> 8U) & 0x00FF), PARAM);
+   msleep(6U);    // horizontal period
+   ssd1963_setDisplayRegister(item, NOCMD, (HT & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, ((HPS >> 8U) & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, (HPS & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, HPW, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, ((LPS >> 8U) & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, (LPS & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0000, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, 0x00B6, ((VT >> 8U) & 0x00FF), PARAM);
+   msleep(6U);    // vertical period
+   ssd1963_setDisplayRegister(item, NOCMD, (VT & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, (VPS >> 8U) & 0x00FF, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, (VPS & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, VPW, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, ((FPS >> 8U) & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, (FPS & 0x00FF), PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, 0x0036, 0x0000, PARAM);
+   msleep(6U);    // rotation - landscape
+   ssd1963_setDisplayRegister(item, 0x00F0, 0x0003, PARAM);
+   msleep(5U);    // pixel data interface 16 bit    0b011 is 16 Bit
+   ssd1963_setDisplayRegister(item, 0x0029, 0x0000, NOPARAM);
+   msleep(6U);    // set display on
+   ssd1963_setDisplayRegister(item, 0x00BE, 0x0006, PARAM);
+   msleep(6U);    // pwm config
+   ssd1963_setDisplayRegister(item, NOCMD, 0x00F0, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0001, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, 0x00F0, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0000, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0000, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, 0x00D0, 0x000D, PARAM);
+   msleep(6U);    // pwm coffig continued
+   ssd1963_setDisplayRegister(item, 0x00B8, 0x0000, PARAM);
+   msleep(6U);    // gpio config
+   ssd1963_setDisplayRegister(item, NOCMD, 0x0000, PARAM);
+   msleep(6U);
+   ssd1963_setDisplayRegister(item, 0x00BA, 0x0000, PARAM);
+   msleep(6U);    // gpio to 0x00
+
+   ssd1963_setWindow(item, 0, 0, WIDTH - 1, HEIGHT - 1);
+   for (x = 0; x < WIDTH * HEIGHT; x++)
+      ssd1963_send_data(item, 0x0000);
+
+
+   ssd1963_setWindow(item, 0, 0, WIDTH - 1, HEIGHT - 1);
+   for (y = 0; y < item->pages_count; y++) {
+      for (x = 0; x < item->pages[y].len; x++) {
+         ssd1963_send_data(item, item->pages[y].buffer[x]);
+      }
+   }
+
+   msleep(10);
+   printk(KERN_ALERT
+          "ssd1963_setup() end: pages_count: %d, item->pages[x].len: %d\n\n",
+          item->pages_count, item->pages[0].len);
+}
+
+#undef GPIOSET
+
+
+//This routine will allocate the buffer for the complete framebuffer. This
+//is one continuous chunk of 16-bit pixel values; userspace programs
+//will write here.
+static int __init ssd1963_video_alloc(struct ssd1963 *item)
+{
+   unsigned int frame_size;
+
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   frame_size = item->info->fix.line_length * item->info->var.yres;
+   dev_dbg(item->dev, "%s: item=0x%p frame_size=%u\n",
+      __func__, (void *) item, frame_size);
+
+   item->pages_count = frame_size / SSD1963_PAGE_SIZE;
+   if ((item->pages_count * SSD1963_PAGE_SIZE) < frame_size) {
+      item->pages_count++;
+   }
+   dev_dbg(item->dev, "%s: item=0x%p pages_count=%u\n",
+      __func__, (void *) item, item->pages_count);
+
+   item->info->fix.smem_len = item->pages_count * SSD1963_PAGE_SIZE;
+   item->info->fix.smem_start =
+       (unsigned long) vmalloc(item->info->fix.smem_len);
+   if (!item->info->fix.smem_start) {
+      dev_err(item->dev, "%s: unable to vmalloc\n", __func__);
+      return -ENOMEM;
+   }
+   memset((void *) item->info->fix.smem_start, 0,
+          item->info->fix.smem_len);
+
+   return 0;
+}
+
+static void ssd1963_video_free(struct ssd1963 *item)
+{
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   kfree((void *) item->info->fix.smem_start);
+}
+
+//This routine will allocate a ssd1963_page struct for each vm page in the
+//main framebuffer memory. Each struct will contain a pointer to the page
+//start, an x- and y-offset, and the length of the pagebuffer which is in the framebuffer.
+static int __init ssd1963_pages_alloc(struct ssd1963 *item)
+{
+   unsigned short pixels_per_page;
+   unsigned short yoffset_per_page;
+   unsigned short xoffset_per_page;
+   unsigned int index;
+   unsigned short x = 0;
+   unsigned short y = 0;
+   unsigned short *buffer;
+   unsigned short *oldbuffer;
+   unsigned int len;
+
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   item->pages =
+       kmalloc(item->pages_count * sizeof(struct ssd1963_page),
+          GFP_KERNEL);
+   if (!item->pages) {
+      dev_err(item->dev,
+         "%s: unable to kmalloc for ssd1963_page\n",
+         __func__);
+      return -ENOMEM;
+   }
+
+   pixels_per_page =
+       SSD1963_PAGE_SIZE / (item->info->var.bits_per_pixel / 8);
+   yoffset_per_page = pixels_per_page / item->info->var.xres;
+   xoffset_per_page = pixels_per_page -
+       (yoffset_per_page * item->info->var.xres);
+   dev_dbg(item->dev, "%s: item=0x%p pixels_per_page=%hu "
+      "yoffset_per_page=%hu xoffset_per_page=%hu\n",
+      __func__, (void *) item, pixels_per_page,
+      yoffset_per_page, xoffset_per_page);
+
+   oldbuffer = kmalloc(item->pages_count * pixels_per_page * 2,
+             GFP_KERNEL);
+   if (!oldbuffer) {
+      dev_err(item->dev,
+         "%s: unable to kmalloc for ssd1963_page oldbuffer\n",
+         __func__);
+      return -ENOMEM;
+   }
+
+   buffer = (unsigned short *) item->info->fix.smem_start;
+   for (index = 0; index < item->pages_count; index++) {
+      len = (item->info->var.xres * item->info->var.yres) -
+          (index * pixels_per_page);
+      if (len > pixels_per_page) {
+         len = pixels_per_page;
+      }
+      dev_dbg(item->dev,
+         "%s: page[%d]: x=%3hu y=%3hu buffer=0x%p len=%3hu\n",
+         __func__, index, x, y, buffer, len);
+      item->pages[index].x = x;
+      item->pages[index].y = y;
+      item->pages[index].buffer = buffer;
+      item->pages[index].oldbuffer = oldbuffer;
+      item->pages[index].len = len;
+
+      x += xoffset_per_page;
+      if (x >= item->info->var.xres) {
+         y++;
+         x -= item->info->var.xres;
+      }
+      y += yoffset_per_page;
+      buffer += pixels_per_page;
+      oldbuffer += pixels_per_page;
+   }
+
+   return 0;
+}
+
+static void ssd1963_pages_free(struct ssd1963 *item)
+{
+   dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *) item);
+
+   kfree(item->pages);
+}
+
+static inline __u32 CNVT_TOHW(__u32 val, __u32 width)
+{
+   return ((val << width) + 0x7FFF - val) >> 16;
+}
+
+//This routine is needed because the console driver won't work without it.
+static int ssd1963_setcolreg(unsigned regno,
+              unsigned red, unsigned green, unsigned blue,
+              unsigned transp, struct fb_info *info)
+{
+   int ret = 1;
+
+   /*
+    * If greyscale is true, then we convert the RGB value
+    * to greyscale no matter what visual we are using.
+    */
+   if (info->var.grayscale)
+      red = green = blue = (19595 * red + 38470 * green +
+                  7471 * blue) >> 16;
+   switch (info->fix.visual) {
+   case FB_VISUAL_TRUECOLOR:
+      if (regno < 16) {
+         u32 *pal = info->pseudo_palette;
+         u32 value;
+
+         red = CNVT_TOHW(red, info->var.red.length);
+         green = CNVT_TOHW(green, info->var.green.length);
+         blue = CNVT_TOHW(blue, info->var.blue.length);
+         transp =
+             CNVT_TOHW(transp, info->var.transp.length);
+
+         value = (red << info->var.red.offset) |
+             (green << info->var.green.offset) |
+             (blue << info->var.blue.offset) |
+             (transp << info->var.transp.offset);
+
+         pal[regno] = value;
+         ret = 0;
+      }
+      break;
+   case FB_VISUAL_STATIC_PSEUDOCOLOR:
+   case FB_VISUAL_PSEUDOCOLOR:
+      break;
+   }
+   return ret;
+}
+
+static int ssd1963_blank(int blank_mode, struct fb_info *info)
+{
+   struct ssd1963 *item = (struct ssd1963 *) info->par;
+   if (blank_mode == FB_BLANK_UNBLANK)
+      item->backlight = 1;
+   else
+      item->backlight = 0;
+   //Item->backlight won't take effect until the LCD is written to. Force that
+   //by dirty'ing a page.
+   item->pages[0].must_update = 1;
+   printk(KERN_ALERT "ssd1963_blank() occurred!\n");
+   schedule_delayed_work(&info->deferred_work, 0);
+   return 0;
+}
+
+static void ssd1963_touch(struct fb_info *info, int x, int y, int w, int h)
+{
+   struct fb_deferred_io *fbdefio = info->fbdefio;
+   struct ssd1963 *item = (struct ssd1963 *) info->par;
+   int i, ystart, yend;
+   if (fbdefio) {
+      //Touch the pages the y-range hits, so the deferred io will update them.
+      for (i = 0; i < item->pages_count; i++) {
+         ystart = item->pages[i].y;
+         yend =
+             item->pages[i].y +
+             (item->pages[i].len / info->fix.line_length) +
+             1;
+         if (!((y + h) < ystart || y > yend)) {
+            item->pages[i].must_update = 1;
+         }
+      }
+      //Schedule the deferred IO to kick in after a delay.
+      schedule_delayed_work(&info->deferred_work,
+                  fbdefio->delay);
+   }
+}
+
+static void ssd1963_fillrect(struct fb_info *p,
+              const struct fb_fillrect *rect)
+{
+   sys_fillrect(p, rect);
+   ssd1963_touch(p, rect->dx, rect->dy, rect->width, rect->height);
+}
+
+static void ssd1963_imageblit(struct fb_info *p,
+               const struct fb_image *image)
+{
+   sys_imageblit(p, image);
+   ssd1963_touch(p, image->dx, image->dy, image->width,
+            image->height);
+}
+
+static void ssd1963_copyarea(struct fb_info *p,
+              const struct fb_copyarea *area)
+{
+   sys_copyarea(p, area);
+   ssd1963_touch(p, area->dx, area->dy, area->width, area->height);
+}
+
+static ssize_t ssd1963_write(struct fb_info *p, const char __user * buf,
+              size_t count, loff_t * ppos)
+{
+   ssize_t res;
+   res = fb_sys_write(p, buf, count, ppos);
+   ssd1963_touch(p, 0, 0, p->var.xres, p->var.yres);
+   return res;
+}
+
+static struct fb_ops ssd1963_fbops = {
+   .owner         = THIS_MODULE,
+   .fb_read       = fb_sys_read,
+   .fb_write      = ssd1963_write,
+   .fb_fillrect   = ssd1963_fillrect,
+   .fb_copyarea   = ssd1963_copyarea,
+   .fb_imageblit  = ssd1963_imageblit,
+   .fb_setcolreg  = ssd1963_setcolreg,
+   .fb_blank      = ssd1963_blank,
+};
+
+static struct fb_fix_screeninfo ssd1963_fix __initdata = {
+   .id            = "SSD1963",
+   .type          = FB_TYPE_PACKED_PIXELS,
+   .visual        = FB_VISUAL_TRUECOLOR,
+   .accel         = FB_ACCEL_NONE,
+   .line_length   = 480 * 2,
+};
+
+static struct fb_var_screeninfo ssd1963_var __initdata = {
+   .xres = 480,
+   .yres = 272,
+   .xres_virtual = 480,
+   .yres_virtual = 272,
+   .width = 480,
+   .height = 272,
+   .bits_per_pixel = 16,
+   .red = {11, 5, 0},
+   .green = {5, 6, 0},
+   .blue = {0, 5, 0},
+   .activate = FB_ACTIVATE_NOW,
+   .vmode = FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_deferred_io ssd1963_defio = {
+   .delay = HZ / 50,
+   .deferred_io = &ssd1963_update,
+};
+
+static int __init ssd1963_probe(struct platform_device *dev)
+{
+   int ret = 0;
+   struct ssd1963 *item;
+   struct resource *ctrl_res;
+   struct resource *data_res;
+   unsigned int ctrl_res_size;
+   unsigned int data_res_size;
+   struct resource *ctrl_req;
+   struct resource *data_req;
+   unsigned short int id[6];
+   struct fb_info *info;
+
+   dev_dbg(&dev->dev, "%s\n", __func__);
+
+   item = kzalloc(sizeof(struct ssd1963), GFP_KERNEL);
+   if (!item) {
+      dev_err(&dev->dev,
+         "%s: unable to kzalloc for ssd1963\n", __func__);
+      ret = -ENOMEM;
+      goto out;
+   }
+   item->dev = &dev->dev;
+   dev_set_drvdata(&dev->dev, item);
+   item->backlight = 1;
+
+   ctrl_res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+   if (!ctrl_res) {
+      dev_err(&dev->dev,
+         "%s: unable to platform_get_resource for ctrl_res\n",
+         __func__);
+      ret = -ENOENT;
+      goto out_item;
+   }
+   ctrl_res_size = ctrl_res->end - ctrl_res->start + 1;
+   ctrl_req = request_mem_region(ctrl_res->start, ctrl_res_size,
+                  dev->name);
+   if (!ctrl_req) {
+      dev_err(&dev->dev,
+         "%s: unable to request_mem_region for ctrl_req\n",
+         __func__);
+      ret = -EIO;
+      goto out_item;
+   }
+
+      /* Now that we're sure that we own the memory bus... reset timings */
+// MPMC_STCONFIG0 = 0x81;
+// MPMC_STWTWEN0  = 0;
+// MPMC_STWTOEN0  = 0;
+// MPMC_STWTRD0   = 31;
+// MPMC_STWTPG0   = 0;
+// MPMC_STWTWR0   = 3;
+// MPMC_STWTTURN0 = 0;
+
+   MPMC_STCONFIG0  = 0x81;
+   MPMC_STWTWEN0   = 2;
+   MPMC_STWTOEN0   = 1;
+   MPMC_STWTRD0    = 15;
+   MPMC_STWTPG0    = 2;
+   MPMC_STWTWR0    = 4;
+   MPMC_STWTTURN0  = 2;
+
+   item->ctrl_io = ioremap(ctrl_res->start, ctrl_res_size);
+   if (!item->ctrl_io) {
+      ret = -EINVAL;
+      dev_err(&dev->dev,
+         "%s: unable to ioremap for ctrl_io\n", __func__);
+      goto out_item;
+   }
+
+   data_res = platform_get_resource(dev, IORESOURCE_MEM, 1);
+   if (!data_res) {
+      dev_err(&dev->dev,
+         "%s: unable to platform_get_resource for data_res\n",
+         __func__);
+      ret = -ENOENT;
+      goto out_item;
+   }
+   data_res_size = data_res->end - data_res->start + 1;
+   data_req = request_mem_region(data_res->start,
+                  data_res_size, dev->name);
+   if (!data_req) {
+      dev_err(&dev->dev,
+         "%s: unable to request_mem_region for data_req\n",
+         __func__);
+      ret = -EIO;
+      goto out_item;
+   }
+   item->data_io = ioremap(data_res->start, data_res_size);
+   if (!item->data_io) {
+      ret = -EINVAL;
+      dev_err(&dev->dev,
+         "%s: unable to ioremap for data_io\n", __func__);
+      goto out_item;
+   }
+
+   dev_dbg(&dev->dev, "%s: ctrl_io=%p data_io=%p\n",
+      __func__, item->ctrl_io, item->data_io);
+
+
+   ssd1963_send_cmd(item, SOFT_RESET);
+   mdelay(200);
+   ssd1963_send_cmd(item, READ_DDB);
+   //mdelay(1);
+
+   id[0]=readw(item->data_io);
+   id[1]=readw(item->data_io);
+   id[2]=readw(item->data_io);
+   id[3]=readw(item->data_io);
+   id[4]=readw(item->data_io);
+
+   dev_dbg(&dev->dev, "%s: signature=%02x %02x %02x %02x %02x\n", __func__, id[0],id[1],id[2],id[3],id[4]);
+
+   if (!(id[0]==0x01 && id[1]==0x57 && id[2]==0x61 && id[3]==0x01)) {
+      ret = -ENODEV;
+      dev_err(&dev->dev,
+         "%s: unknown signature %02x %02x %02x %02x %02x\n", __func__, id[0],id[1],id[2],id[3],id[4]);
+      goto out_item;
+   }
+
+   dev_info(&dev->dev, "item=0x%p ctrl=0x%p data=0x%p\n", (void *)item,
+       (void *)ctrl_res->start, (void *)data_res->start);
+
+   info = framebuffer_alloc(sizeof(struct ssd1963), &dev->dev);
+   if (!info) {
+      ret = -ENOMEM;
+      dev_err(&dev->dev,
+         "%s: unable to framebuffer_alloc\n", __func__);
+      goto out_item;
+   }
+   info->pseudo_palette = &item->pseudo_palette;
+   item->info = info;
+   info->par = item;
+   info->dev = &dev->dev;
+   info->fbops = &ssd1963_fbops;
+   info->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;
+   info->fix = ssd1963_fix;
+   info->var = ssd1963_var;
+
+   ret = ssd1963_video_alloc(item);
+   if (ret) {
+      dev_err(&dev->dev,
+         "%s: unable to ssd1963_video_alloc\n", __func__);
+      goto out_info;
+   }
+   info->screen_base = (char __iomem *) item->info->fix.smem_start;
+
+   ret = ssd1963_pages_alloc(item);
+   if (ret < 0) {
+      dev_err(&dev->dev,
+         "%s: unable to ssd1963_pages_init\n", __func__);
+      goto out_video;
+   }
+
+   info->fbdefio = &ssd1963_defio;
+   fb_deferred_io_init(info);
+
+   ret = register_framebuffer(info);
+   if (ret < 0) {
+      dev_err(&dev->dev,
+         "%s: unable to register_frambuffer\n", __func__);
+      goto out_pages;
+   }
+
+
+   ssd1963_setup(item);
+   ssd1963_update_all(item);
+
+   return ret;
+
+      out_pages:
+   ssd1963_pages_free(item);
+      out_video:
+   ssd1963_video_free(item);
+      out_info:
+   framebuffer_release(info);
+      out_item:
+   kfree(item);
+      out:
+   return ret;
+}
+
+
+static int ssd1963_remove(struct platform_device *dev)
+{
+   struct fb_info *info = dev_get_drvdata(&dev->dev);
+   struct ssd1963 *item = (struct ssd1963 *) info->par;
+   unregister_framebuffer(info);
+   ssd1963_pages_free(item);
+   ssd1963_video_free(item);
+   framebuffer_release(info);
+   kfree(item);
+   return 0;
+}
+
+#ifdef CONFIG_PM
+static int ssd1963_suspend(struct platform_device *dev, pm_message_t state)
+{
+//      struct fb_info *info = dev_get_drvdata(&spi->dev);
+//      struct ssd1963 *item = (struct ssd1963 *)info->par;
+   /* enter into sleep mode */
+//      ssd1963_reg_set(item, SSD1963_REG_SLEEP_MODE, 0x0001);
+   return 0;
+}
+
+static int ssd1963_resume(struct platform_device *dev)
+{
+//      struct fb_info *info = dev_get_drvdata(&spi->dev);
+//      struct ssd1963 *item = (struct ssd1963 *)info->par;
+   /* leave sleep mode */
+//      ssd1963_reg_set(item, SSD1963_REG_SLEEP_MODE, 0x0000);
+   return 0;
+}
+#else
+#define ssd1963_suspend NULL
+#define ssd1963_resume NULL
+#endif
+
+static struct platform_driver ssd1963_driver = {
+   .probe = ssd1963_probe,
+   .remove = ssd1963_remove,
+   .driver = {
+         .name = "ssd1963",
+         },
+};
+
+static int __init ssd1963_init(void)
+{
+   int ret = 0;
+
+   pr_debug("%s\n", __func__);
+
+   ret = platform_driver_register(&ssd1963_driver);
+   if (ret) {
+      pr_err("%s: unable to platform_driver_register\n",
+             __func__);
+   }
+
+   return ret;
+}
+
+module_init(ssd1963_init);
+module_remove(ssd1963_remove);
+
+
+MODULE_DESCRIPTION("SSD1963 LCD Driver");
+MODULE_AUTHOR("Jeroen Domburg <jeroen@spritesmods.com>");
+MODULE_AUTHOR("Armin Schlegel <armin.schlegel@gmx.de");
+MODULE_LICENSE("GPL");
diff -uNr linux-2.6.33-lpc313x-vanilla/drivers/video/vfb.c linux-2.6.33-lpc313x/drivers/video/vfb.c
--- linux-2.6.33-lpc313x-vanilla/drivers/video/vfb.c	2014-05-13 18:17:09.679515010 +0200
+++ linux-2.6.33-lpc313x/drivers/video/vfb.c	2014-02-23 14:15:10.833737002 +0100
@@ -80,15 +80,15 @@
 }
 
 static struct fb_var_screeninfo vfb_default __initdata = {
-	.xres =		640,
-	.yres =		480,
-	.xres_virtual =	640,
-	.yres_virtual =	480,
-	.bits_per_pixel = 8,
-	.red =		{ 0, 8, 0 },
-      	.green =	{ 0, 8, 0 },
-      	.blue =		{ 0, 8, 0 },
-      	.activate =	FB_ACTIVATE_TEST,
+	.xres =		480,
+	.yres =		272,
+	.xres_virtual =	480,
+	.yres_virtual =	272,
+	.bits_per_pixel = 16,
+	.red =		{ 11, 5, 0 },
+      	.green =	{ 5, 6, 0 },
+      	.blue =		{ 0, 5, 0 },
+      	.activate =	FB_ACTIVATE_NOW,
       	.height =	-1,
       	.width =	-1,
       	.pixclock =	20000,
@@ -240,11 +240,11 @@
 			var->transp.offset = 15;
 			var->transp.length = 1;
 		} else {	/* RGB 565 */
-			var->red.offset = 0;
+			var->red.offset = 11;
 			var->red.length = 5;
 			var->green.offset = 5;
 			var->green.length = 6;
-			var->blue.offset = 11;
+			var->blue.offset = 0;
 			var->blue.length = 5;
 			var->transp.offset = 0;
 			var->transp.length = 0;
diff -uNr linux-2.6.33-lpc313x-vanilla/install_SD.sh linux-2.6.33-lpc313x/install_SD.sh
--- linux-2.6.33-lpc313x-vanilla/install_SD.sh	2014-05-13 18:17:18.608515149 +0200
+++ linux-2.6.33-lpc313x/install_SD.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-#!/bin/bash
-
-
-path1=$(pwd)
-path2="$1"
-
-if [ ! -e .config ]
-then
-  make gnublin_defconfig
-fi
-
-make zImage  || exit 1 
-make modules || exit 1
-sudo rm -r /home/brenson/tmp/modules_install/*
-make modules_install INSTALL_MOD_PATH=/home/brenson/tmp/modules_install || exit 1
-
-sudo cp -r "/home/brenson/tmp/modules_install/lib" "${path2}"
-sudo cp arch/arm/boot/zImage "${path2}"
-sleep 1
-sudo sync
-sleep 1
-sudo umount "${path2}"
diff -uNr linux-2.6.33-lpc313x-vanilla/install_SD_all.sh linux-2.6.33-lpc313x/install_SD_all.sh
--- linux-2.6.33-lpc313x-vanilla/install_SD_all.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-lpc313x/install_SD_all.sh	2014-05-13 18:21:37.412519178 +0200
@@ -0,0 +1,28 @@
+#!/bin/bash
+
+# Armin Schlegel (2014)
+# This script installs the kernel and the modules on the sd card
+# Usage: ./intall_SD_all.sh sdX
+# Note: sdX is the device for the sd card.
+# Note: /dev/sdX3 must be the root partition and /dev/sdX1 the boot partition.
+
+sd=$1
+ready_path=$(pwd)/ready
+mkdir $ready_path
+
+echo mounting sd card
+mount /dev/$13 /mnt/hd
+mount /dev/$11 /mnt/hd/boot
+
+cd /mnt/hd
+
+echo  extracting $ready_path/ready.tar.gz
+
+tar xvfz $ready_path/ready.tar.gz
+cd $ready_path/..
+
+echo unmounting sd card
+umount /mnt/hd/boot
+umount /mnt/hd
+
+echo done ...
diff -uNr linux-2.6.33-lpc313x-vanilla/install_SD_kernel.sh linux-2.6.33-lpc313x/install_SD_kernel.sh
--- linux-2.6.33-lpc313x-vanilla/install_SD_kernel.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-lpc313x/install_SD_kernel.sh	2014-05-13 18:22:02.880519574 +0200
@@ -0,0 +1,20 @@
+#!/bin/bash
+# Armin Schlegel (2014)
+# This script installs the kernel on the sd card
+# Usage: ./intall_SD_kernel.sh sdX
+# Note: sdX is the device for the sd card.
+# Note: /dev/sdX1 must be the boot partition.
+
+sd=$1
+ready_path=$(pwd)/ready
+mkdir $ready_path
+
+echo mounting sd card
+mount /dev/$11 /mnt/hd
+
+cp ready/boot/zImage /mnt/hd
+sleep 1
+echo unmounting sd card
+umount /mnt/hd
+
+echo done ...
