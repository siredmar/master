#include "../inc/std_types.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>


#define SCREENWIDTH     1024
#define SCREENHEIGHT    700
#define SCREENDEPTH     16

#define IMAGEHEIGHT 272
#define IMAGEWIDTH  480

#define ORG_X_OFFSET 0
#define ORG_Y_OFFSET 0

#define MOD_X_OFFSET 0
#define MOD_Y_OFFSET 300

typedef struct
{
   uint8 R;
   uint8 G;
   uint8 B;
}image_rgb888_type;

typedef struct
{
   uint16 xres;
   uint16 yres;
   uint16 *content;
   uint16 x_offset;
   uint16 y_offset;

}framebuffer_type;

image_rgb888_type convert565to888(uint16 pixel)
{
   image_rgb888_type returnvalue;
   returnvalue.R = (pixel & 0xF800) >> 8;
   returnvalue.G = (pixel & 0x07E0) >> 3;
   returnvalue.B = (pixel & 0x001F) << 3;

   return returnvalue;
}



void drawPixel(SDL_Surface *screen, int x, int y, image_rgb888_type rgb)// int y,uint8 R, uint8 G,uint8 B)
{
   uint8 R = rgb.R;
   uint8 G = rgb.G;
   uint8 B = rgb.B;

   uint32 color = SDL_MapRGB(screen->format, R, G, B);
 if ( SDL_MUSTLOCK(screen) )
 {
 if ( SDL_LockSurface(screen) < 0 ) {
 return;
 }
 }
 switch (screen->format->BytesPerPixel) {
 case 1: { /* vermutlich 8 Bit */
 uint8 *bufp;
 bufp = (uint8 *)screen->pixels + y*screen->pitch + x;
 *bufp = color;
 }
 break;
 case 2: { /* vermutlich 15 Bit oder 16 Bit */
 uint16 *bufp;
 bufp = (uint16 *)screen->pixels + y*screen->pitch/2 + x;
 *bufp = color;
 }
 break;
 case 3: { /* langsamer 24-Bit-Modus, selten verwendet */
 uint8 *bufp;
 bufp = (uint8 *)screen->pixels + y*screen->pitch + x * 3;
 if(SDL_BYTEORDER == SDL_LIL_ENDIAN) {
 bufp[0] = color;
 bufp[1] = color >> 8;
 bufp[2] = color >> 16;
 } else {
 bufp[2] = color;
 bufp[1] = color >> 8;
 bufp[0] = color >> 16;
 }
 }
 break;
 case 4: { /* vermutlich 32 Bit */
 uint32 *bufp;
 bufp = (uint32 *)screen->pixels + y*screen->pitch/4 + x;
 *bufp = color;
 }
 break;
 }
 if ( SDL_MUSTLOCK(screen) )
 {
 SDL_UnlockSurface(screen);
 }
}

void drawFramebuffer(SDL_Surface *screen, framebuffer_type fb)
{
   uint16 x, y;
   for (y = 0; y < IMAGEHEIGHT; y++)
     {
       for (x = 0; x < IMAGEWIDTH; x++)
         {
          drawPixel(screen, x+fb.x_offset, y+fb.y_offset, convert565to888(fb.content[y*IMAGEWIDTH + x]));
         }
     }
}



int
main (sint32 * argc, uint8 * argv[])
{


  SDL_Event event;
  int quit = 0;
  int key_pressed = 0;
  SDL_Surface *screen;//, *temp;
  //SDL_Surface *image;
  //image_rgb888_type currentPixel;
  FILE *fb;
  framebuffer_type source_framebuffer;
  uint16 buf_source[IMAGEHEIGHT * IMAGEWIDTH * 2];
  //uint16 x, y;
//  uint8* texture;

  if (SDL_Init (SDL_INIT_VIDEO) < 0)
    {
      fprintf (stderr, "Konnte SDL nicht initialisieren: %s\n",
	       SDL_GetError ());
      exit (-1);
    }
  screen = SDL_SetVideoMode (SCREENWIDTH, SCREENHEIGHT, SCREENDEPTH,
			     SDL_SWSURFACE);

  if (screen < 0)
    {
      fprintf (stderr, "Konnte video mode nicht setzen: %s\n",
	       SDL_GetError ());
    }
  atexit (SDL_Quit);
// Algorithm start

  fb = fopen(argv[1], "rb");
  if(fb == NULL){
      fprintf (stderr, "Konnte Bild nicht laden\n");
      exit (-1);
}
  fseek (fb, 0, SEEK_SET);   // rewind source framebuffer
  fread (buf_source, 1, IMAGEWIDTH * IMAGEHEIGHT * 2, fb);  // read complete source framebuffer

  source_framebuffer.content = buf_source;
  source_framebuffer.x_offset = 0;
  source_framebuffer.y_offset = 0;
  source_framebuffer.xres = 480;
  source_framebuffer.yres = 272;

  drawFramebuffer(screen, source_framebuffer);


  //  for (y = 0; y < IMAGEHEIGHT; y++)
//    {
//      for (x = 0; x < IMAGEWIDTH; x++)
//        {
//         currentPixel = convert565to888(buf_source[y*IMAGEWIDTH + x]);
//         drawPixel(screen, x+ORG_X_OFFSET, y+ORG_Y_OFFSET, currentPixel);
//        }
//    }




 // SDL_BlitSurface(image, 0, screen, 0);
  SDL_UpdateRect(screen, 0, 0, 0, 0);

// Algorithm stop
  while (quit == 0)
    {
      while (SDL_PollEvent (&event))
	{
	  switch (event.type)
	    {
	    case SDL_KEYDOWN:
	      //      printf("Press: ");
	      //      printf(" Name: %s\n",

	      key_pressed = event.key.keysym.sym;
	      if (key_pressed == SDLK_ESCAPE)
		quit = 1;
	      break;
	    case SDL_QUIT:	// SDL_QUIT int ein schliessen des windows
	      quit = 1;
	      break;
	    default:
	      break;
	    }
	}

    }
  exit (0);
}
