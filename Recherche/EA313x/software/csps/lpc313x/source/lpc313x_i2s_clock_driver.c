/***********************************************************************
 * $Id:: lpc313x_i2s_clock_driver.c 3557 2010-05-20 00:31:30Z usb10131 $
 *
 * Project: LPC313X I2S clock control driver
 *
 * Description:
 *     This file provides the necessary clock rate setup functions for
 *     The I2S signals on the LPC313X. These functions include clock
 *     enable and disable, and clock frequency setup on the WS, BCLK,
 *     and SYSCLK pins. All standard audio rates (8KHz, 11.025KHz,
 *     16KHz, 22.05KHz, 32KHz, 44.1KHz, 48KHz) and some substandard
 *     rates (12KHz, 24KHz) are supported with FS clock multipliers
 *     of 128, 256, 384, 512, 768, and 1024. All standard bit clock
 *     rates are supported (8 bits x 2 channels, 16-bits x 2 channels,
 *     24-bits x 2 channels).
 *
 * Notes:
 *     The audio channel clocks use the fractional dividers as set up
 *     in the CDL startup code. If the selecting clocking groups are
 *     changed, this driver must also be changed. All PLL frequencies
 *     generated from the PLL setup structures in this driver are based
 *     on a 12MHz rate into the FCLKIN input of the LPC313x device.
 *
 ***********************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
 **********************************************************************/
/*
 * Note: Fractional clock divider domains are defined in the startup
 * code. As of the time this driver was developed, the fractional
 * divider groupings are mapped as follows:
 *     Group 17 -> TX0 WS, TX1, WS, RX0 WS, RX1 WS
 *     Group 18 -> TX0 BCK, TX1 BCK
 *     Group 19 -> CLK_256FS, TX_CLK0
 *     Group 20 -> RX0 BCK, RX1 BCK
 *
 * The driver supports the following sample rates and FS clock
 * multipliers. These rates are dependent on an external 12MHz
 * oscillator input. All these rates are generated from a small set of
 * PLL frequencies and a fractional divider. Some of the rates can be
 * generated by more than 1PLL frequency.
 *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
 *  128FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
 *  256FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
 *  384FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
 *  512FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
 *  768FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
 *  1024FS    Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
 */

/* Driver usage examples:
   Example 1: The LPC3152 audio CODEC at 128FS, 44.1KHz sample rate,
              and 16-bit stereo samples on I2S channel 0
       lpc313x_set_fsmult_rate(128);
	   lpc313x_main_clk_rate(44100);
	   lpc313x_chan_clk_enable(CLK_TX_0, 44100, (44100 * 16 * 2));

   Example 2: The LPC3131 with an external UDA1380 audio CODEC at 256FS,
              32KHz sample rate, and 16-bit stereo samples on I2S
			  channel 1
       lpc313x_set_fsmult_rate(256);
	   lpc313x_main_clk_rate(32000);
	   lpc313x_chan_clk_enable(CLK_TX_1, 32000, (32000 * 16 * 2));
*/

#include "lpc313x_i2s_clock_driver.h"
#include "lpc313x_cgu_driver.h"

/***********************************************************************
 * Local driver data
 **********************************************************************/

struct i2s_clk_setup
{
  UNS_32 target_codec_rate;
  UNS_32 real_fs_codec_rate;
  UNS_32 fsdmult;
  UNS_32 clk_use_mask;
};
static struct i2s_clk_setup i2s_clk_state = {0, 0, 256, CLK_USE_256FS};

/*
 * clock setup enable/disable selection arrays - these clocks are enabled as a group
 * for a specific I2S channel
 */
static CGU_CLOCK_ID_T rx0clks[] =
{
  CGU_SB_I2SRX_IF_0_PCLK_ID,
  CGU_SB_I2SRX_FIFO_0_PCLK_ID,
  CGU_SB_I2SRX_BCK0_N_ID,
  CGU_SB_I2SRX_WS0_ID,
  CGU_SB_I2SRX_BCK0_ID,
  CGU_SB_INVALID_CLK_ID
};
static CGU_CLOCK_ID_T tx0clks[] =
{
  CGU_SB_I2STX_IF_0_PCLK_ID,
  CGU_SB_I2STX_FIFO_0_PCLK_ID,
  CGU_SB_I2STX_BCK0_N_ID,
  CGU_SB_I2STX_WS0_ID,
  CGU_SB_INVALID_CLK_ID
};
static CGU_CLOCK_ID_T rx1clks[] =
{
  CGU_SB_I2SRX_IF_1_PCLK_ID,
  CGU_SB_I2SRX_FIFO_1_PCLK_ID,
  CGU_SB_I2SRX_BCK1_N_ID,
  CGU_SB_I2SRX_WS1_ID,
  CGU_SB_I2SRX_BCK1_ID,
  CGU_SB_INVALID_CLK_ID
};
static CGU_CLOCK_ID_T tx1clks[] =
{
  CGU_SB_I2STX_IF_1_PCLK_ID,
  CGU_SB_I2STX_FIFO_1_PCLK_ID,
  CGU_SB_I2STX_BCK1_N_ID,
  CGU_SB_I2STX_WS1_ID,
  CGU_SB_INVALID_CLK_ID
};

typedef CGU_CLOCK_ID_T * P_CGU_CLOCK_ID_T;
static P_CGU_CLOCK_ID_T clkarray[CLK_TX_1 + 1] =
{
  rx0clks,
  tx0clks,
  rx1clks,
  tx1clks
};

/* 48K*1024 sysclk rate settings (12M oscillator input),
   49152000Hz FS clock, error .003999Hz
   used for the following rates with the following dividers:
 *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
 *  128FS     48          32  24         16  12        8
 *  256FS     24          16  12         8   6         4
 *  384FS     16              8              4
 *  512FS     12          8              4   3         2
 *  768FS     8               4              2
 *  1024FS    6           4   3          2             1
*/
static CGU_HPLL_SETUP_T pllsetup_48K_1024 =
{
  CGU_FIN_SELECT_FFAST, 514, 21708, 5, 0, 44, 21, 0, (48000 * 1024)
};

/* 48K*768 sysclk rate settings (12M oscillator input),
   36864000Hz FS clock, error .003999Hz
   used for the following rates with the following dividers:
 *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
 *  128FS     36          24  18         12            6
 *  256FS     18          12  9          6             3
 *  384FS     12          8   6          4   3         2
 *  512FS     9           6
 *  768FS     6           4              2             1
 *  1024FS
*/
static CGU_HPLL_SETUP_T pllsetup_48K_768 =
{
  CGU_FIN_SELECT_FFAST, 514, 21299, 21, 0, 44, 22, 0, (48000 * 768)
};

/* 44.1K*1024 sysclk rate settings (12M oscillator input),
   45158400Hz FS clock, error .0131999Hz
   used for the following rates with the following dividers:
 *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
 *  128FS         32              16              8
 *  256FS         16              8               4
 *  384FS
 *  512FS         8               4               2
 *  768FS
 *  1024FS        4               2               1
*/
static CGU_HPLL_SETUP_T pllsetup_44_1K_1024 =
{
  CGU_FIN_SELECT_FFAST, 770, 8191, 2, 0, 16, 8, 0, (44100 * 1024)
};

/* 44.1K*768 sysclk rate settings (12M oscillator input),
   33868800Hz FS clock, error .0099Hz
   used for the following rates with the following dividers:
 *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
 *  128FS         24              12              6
 *  256FS         12              6               3
 *  384FS         8               4               2
 *  512FS         6               3
 *  768FS         4               2               1
 *  1024FS        3
*/
static CGU_HPLL_SETUP_T pllsetup_44_1K_768 =
{
  CGU_FIN_SELECT_FFAST, 514, 19660, 11, 0, 48, 23, 0, (44100 * 768)
};

/* 32K*1024 sysclk rate settings (12M oscillator input),
   32768000Hz FS clock, error .01638Hz
   used for the following rates with the following dividers:
 *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
 *  128FS     32              16             8
 *  256FS     16              8              4
 *  384FS
 *  512FS     8               4              2
 *  768FS
 *  1024FS                                   1
*/
static CGU_HPLL_SETUP_T pllsetup_32K_1024 =
{
  CGU_FIN_SELECT_FFAST, 770, 32765, 21, 0, 20, 10, 0, (32000 * 1024)
};

static CGU_HPLL_SETUP_T *ppll_list[] =
{
  &pllsetup_32K_1024,
  &pllsetup_44_1K_768,
  &pllsetup_44_1K_1024,
  &pllsetup_48K_768,
  &pllsetup_48K_1024,
  NULL
};

/***********************************************************************
 *
 * Function: lpc313x_set_best_rate
 *
 * Purpose: Find the closest matching CLK256FS or SYSCLK pin rates
 *
 * Processing:
 *     Based on the rate previously setup with the
 *     lpc313x_set_fsmult_rate() function and the passed target
 *     frequency function, find the best PLL setup data and the best
 *     fractional divider to generate the required rate.
 *
 * Parameters:
 *     freq : Target rate (divided by fsdmult)
 *
 * Outputs: None
 *
 * Returns:
 *    The actual programmed rate or 0 if disabled or if the rate
 *    can't be set.
 *
 * Notes: None
 *
 **********************************************************************/
static UNS_32 lpc313x_set_best_rate(UNS_32 freq)
{
  CGU_FDIV_SETUP_T clk_div;
  UNS_32 diff;
  int i = 0;

  clk_div.stretch = 1;

  while (ppll_list[i] != NULL)
  {
    /* Find match divider based on current FS divider and rate */
    diff = ppll_list[i]->freq / i2s_clk_state.fsdmult;
    clk_div.m = diff / freq;
    diff = diff - (freq * clk_div.m);

    if (diff == 0)
    {
      if (clk_div.m <= 1)
      {
        clk_div.n = 0;
        clk_div.m = 0;
      }
      else
      {
        clk_div.n = 1;
      }

      /* Set PLL rate and divider for CODEC clock */
      i2s_clk_state.real_fs_codec_rate = ppll_list[i]->freq;
      cgu_hpll_config(CGU_HPLL0_ID, ppll_list[i]);
      cgu_fdiv_config(19, clk_div, 1, 0);
      return freq;
    }

    i++;
  }

  return 0;
}

/***********************************************************************
 *
 * Function: lpc313x_set_codec_freq
 *
 * Purpose: Sets up the audio PLL to generate a frequency as close as
 *          possible to the target clkrate frequency
 *
 * Processing:
 *     Disables clocks if the input rate is 0. Otherwise, trys to find
 *     and set the PLL rate and divider to generate this rate.
 *
 * Parameters:
 *     freq : Target rate (divided by fsdmult)
 *
 * Outputs: None
 *
 * Returns:
 *    The actual programmed rate or 0 if disabled or if the rate
 *    can't be set.
 *
 * Notes: None
 *
 **********************************************************************/
static UNS_32 lpc313x_set_codec_freq(UNS_32 freq)
{
  if (freq == 0)
  {
    /* Disable the required audio CODEC clocks */
    cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 0);
    if (i2s_clk_state.clk_use_mask & CLK_USE_256FS)
      cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 0);
    if (i2s_clk_state.clk_use_mask & CLK_USE_TXCLKO)
      cgu_clk_en_dis(CGU_SB_I2STX_CLK0_ID, 0);
  }
  else if (freq != i2s_clk_state.target_codec_rate)
  {
    /* Disable the required audio CODEC clocks during frequency change */
    cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 0);
    if (i2s_clk_state.clk_use_mask & CLK_USE_256FS)
      cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 0);
    if (i2s_clk_state.clk_use_mask & CLK_USE_TXCLKO)
      cgu_clk_en_dis(CGU_SB_I2STX_CLK0_ID, 0);

    freq = lpc313x_set_best_rate(freq);
    if (freq > 0)
    {
      /* Enable clock */
      if (i2s_clk_state.clk_use_mask & CLK_USE_256FS)
        cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 1);
      if (i2s_clk_state.clk_use_mask & CLK_USE_TXCLKO)
        cgu_clk_en_dis(CGU_SB_I2STX_CLK0_ID, 1);
      cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 1);
    }
  }

  i2s_clk_state.target_codec_rate = freq;

  return freq;
}

/***********************************************************************
 *
 * Function: lpc313x_ch_clk_disen
 *
 * Purpose: Start or stop a channel's clocks
 *
 * Processing:
 *     Disables or enables a group of channel clocks.
 *
 * Parameters:
 *     chclk : Clock group to start or stop
 *     en    : 0 to stop the clocks in the group, !o to start
 *
 * Outputs: None
 *
 * Returns: Nothing
 *
 * Notes: None
 *
 **********************************************************************/
static void lpc313x_ch_clk_disen(enum i2s_supp_clks chclk, int en)
{
  int i = 0;
  P_CGU_CLOCK_ID_T pclks = (P_CGU_CLOCK_ID_T) clkarray[chclk];

  while (pclks[i] != CGU_SB_INVALID_CLK_ID)
  {
    cgu_clk_en_dis(pclks[i], en);
    i++;
  }
}

/***********************************************************************
 *
 * Function: lpc313x_set_ch_freq
 *
 * Purpose: Sets up the channel bit clock to generate a rate as close
 *          as possible to the target clkrate frequency
 *
 * Processing:
 *     Sets the sample rate and bit clock for an I2S channel.
 *
 * Parameters:
 *     chclk    : Clock group to change rates on
 *     ws_freq  : Sample rate frequency
 *     bit_freq : Bit rate frequency
 *
 * Outputs: None
 *
 * Returns:
 *    The actual programmed rate or 0 if disabled or if the rate
 *    can't be set.
 *
 * Notes: None
 *
 **********************************************************************/
static UNS_32 lpc313x_set_ch_freq(enum i2s_supp_clks chclk,
                                  UNS_32 ws_freq, UNS_32 bit_freq)
{
  CGU_FDIV_SETUP_T ch_div;

  if (ws_freq == 0)
  {
    /* Turn channel clock off */
    lpc313x_ch_clk_disen(chclk, 0);
    bit_freq = 0;
  }
  else
  {
    /* Stop channel clocks for the change */
    lpc313x_ch_clk_disen(chclk, 0);

    ch_div.stretch = 1;
    ch_div.n = 1;

    /* Find divider to generate target WS frequency from PLL */
    ch_div.m = i2s_clk_state.real_fs_codec_rate / ws_freq;
    cgu_fdiv_config(17, ch_div, 1, 0);

    /* Find divider to generate target bck frequency from PLL */
    ch_div.m = i2s_clk_state.real_fs_codec_rate / bit_freq;

    if ((chclk == CLK_RX_0) || (chclk == CLK_RX_1))
    {
      cgu_fdiv_config(20, ch_div, 1, 0);
    }
    if ((chclk == CLK_TX_0) || (chclk == CLK_TX_1))
    {
      cgu_fdiv_config(18, ch_div, 1, 0);
    }

    /* Enable channel clock */
    lpc313x_ch_clk_disen(chclk, 1);
  }

  return ws_freq;
}

/***********************************************************************
 *
 * Function: lpc313x_chan_clk_enable
 *
 * Purpose: Setup the FS clock rate (multiplier) of the audio system
 *
 * Processing:
 *     Setup the FS clock rate of the audio system. This must be called
 *     prior to any other functions of this driver. It sets up the
 *     divider ratio between the WS rate and the CODEC clock rate
 *     (FS256 or SYSCLK). Valid rates are 128, 256, 384, 512, 768, and
 *     1024. Also selects which clocks (CLK_USE_256FS or CLK_USE_CLKO
 *     or both or none) to use for the main CODEC clock pin. Returns
 *     the currently selected rate or 0 if the function fails
 *
 * Parameters:
 *     fsmult    : FS multiplier value
 *     main_clks : Clock(s) to use (0 or and or'd value of
 *                 CLK_USE_256FS or CLK_USE_CLKO)
 *
 * Outputs: None
 *
 * Returns: the programmed multiplier value or 0 if it fails
 *
 * Notes: None
 *
 **********************************************************************/
UNS_32 lpc313x_set_fsmult_rate(UNS_32 fsmult, UNS_32 main_clks)
{
  UNS_32 lfsdmult = 0;

  switch (fsmult)
  {
    case 128:
    case 256:
    case 384:
    case 512:
    case 768:
    case 1024:
      lfsdmult = i2s_clk_state.fsdmult = fsmult;

    default:
      break;
  }

  i2s_clk_state.clk_use_mask = (main_clks & (CLK_USE_256FS |
                                             CLK_USE_TXCLKO));

  return lfsdmult;
}

/***********************************************************************
 *
 * Function: lpc313x_chan_clk_enable
 *
 * Purpose: Set the audio CODEC clock rate or 0 to disable the clock
 *
 * Processing:
 *     Set the audio CODEC clock rate or 0 to disable the clock. This
 *     value is the desired audio sample rate in Hz. It is used with
 *     fsmult to use to generate the FS256 or SYSCLK values, which
 *     are computed from (fsmult * freq
 *
 * Parameters:
 *     chclk    : I2S pin group
 *     ws_freq  : Target sample rate
 *     bit_freq : Target bit frequency
 *
 * Outputs: None
 *
 * Returns:
 *    The actual programmed sample rate (WS) or 0 if disabled or if the
 *    rate can't be set.
 *
 * Notes:
 *    The frequency multiplier must be set with a call to
 *    lpc313x_set_fsmult_rate() prior to using this function.
 *
 **********************************************************************/
UNS_32 lpc313x_main_clk_rate(UNS_32 freq)
{
  /* Compute and set proper divider */
  return lpc313x_set_codec_freq(freq);
}

/***********************************************************************
 *
 * Function: lpc313x_chan_clk_enable
 *
 * Purpose: Set a specific channel's bit clock and word select rates
 *
 * Processing:
 *     Based on the rate previously setup with the
 *     lpc313x_set_fsmult_rate() function and lpc313x_main_clk_rate()
 *     functions, the correct dividers are
 *
 * Parameters:
 *     chclk    : I2S pin group
 *     ws_freq  : Target sample rate
 *     bit_freq : Target bit frequency
 *
 * Outputs: None
 *
 * Returns:
 *    The actual programmed sample rate (WS) or 0 if disabled or if the
 *    rate can't be set.
 *
 * Notes:
 *    The main CODEC clock must be setup prior to this call with the
 *    lpc313x_set_fsmult_rate() and lpc313x_main_clk_rate() functions.
 *
 **********************************************************************/
UNS_32 lpc313x_chan_clk_enable(enum i2s_supp_clks chclk,
                               UNS_32 ws_freq, UNS_32 bit_freq)
{
  /* Compute and set proper divider */
  return lpc313x_set_ch_freq(chclk, ws_freq, bit_freq);
}
