watchdog for lpc31xx

From: Jon Smirl <jonsmirl@terra.(none)>


---
 arch/arm/mach-lpc31xx/clock.c  |   10 +
 drivers/watchdog/Kconfig       |    9 +
 drivers/watchdog/Makefile      |    2 
 drivers/watchdog/wdt_lpc313x.c |  367 ++++++++++++++++++++++++++++++++++++++++
 4 files changed, 388 insertions(+), 0 deletions(-)
 create mode 100644 drivers/watchdog/wdt_lpc313x.c

diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index b0aade5..69ab97a 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -950,6 +950,15 @@ static struct clk clk_mmc_cclk_in = {
 	.id		= CGU_SB_SD_MMC_CCLK_IN_ID,
 };
 
+static struct clk clk_wdog_pclk = {
+	.parent		= &sys_base,
+	.enable		= local_onoff_enable,
+	.enable_reg	= &CGU_SB->clk_pcr[CGU_SB_WDOG_PCLK_ID],
+	.enable_mask	= CGU_SB_PCR_RUN,
+	.get_rate	= get_rate,
+	.id		= CGU_SB_WDOG_PCLK_ID,
+};
+
 static DEFINE_MUTEX(clkm_lock);
 
 static inline void clk_lock(void)
@@ -1064,6 +1073,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "spi_clk_gated", clk_spi_clk_gated)
 	_REGISTER_CLOCK(NULL, "mmc_hclk", clk_mmc_hclk)
 	_REGISTER_CLOCK(NULL, "mmc_cclk_in", clk_mmc_cclk_in)
+	_REGISTER_CLOCK(NULL, "wdog_pclk", clk_wdog_pclk)
 };
 
 static int __init clk_init(void)
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 79fd606..6bebb40 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -343,6 +343,15 @@ config IMX2_WDT
 	  To compile this driver as a module, choose M here: the
 	  module will be called imx2_wdt.
 
+config LPC313X_WATCHDOG
+	tristate "NXP LPC313x watchdog"
+	depends on ARCH_LPC31XX
+	help
+	  Say Y here if to include support for the watchdog timer
+	  for the NXP's LPC313x uC SoC.
+	  To compile this driver as a module, choose M here: the
+	  module will be called wdt_lpc313x.
+
 # AVR32 Architecture
 
 config AT32AP700X_WDT
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index fe893e9..85042db 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_USBPCWATCHDOG) += pcwd_usb.o
 # ALPHA Architecture
 
 # ARM Architecture
+EXTRA_CFLAGS=-DDEBUG -DVERBOSE_DEBUG
 obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp805_wdt.o
 obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
 obj-$(CONFIG_AT91SAM9X_WATCHDOG) += at91sam9_wdt.o
@@ -53,6 +54,7 @@ obj-$(CONFIG_STMP3XXX_WATCHDOG) += stmp3xxx_wdt.o
 obj-$(CONFIG_NUC900_WATCHDOG) += nuc900_wdt.o
 obj-$(CONFIG_TS72XX_WATCHDOG) += ts72xx_wdt.o
 obj-$(CONFIG_IMX2_WDT) += imx2_wdt.o
+obj-$(CONFIG_LPC313X_WATCHDOG) += wdt_lpc313x.o
 
 # AVR32 Architecture
 obj-$(CONFIG_AT32AP700X_WDT) += at32ap700x_wdt.o
diff --git a/drivers/watchdog/wdt_lpc313x.c b/drivers/watchdog/wdt_lpc313x.c
new file mode 100644
index 0000000..22e12e2
--- /dev/null
+++ b/drivers/watchdog/wdt_lpc313x.c
@@ -0,0 +1,367 @@
+/*
+ * LPC313x Watchdog timer driver
+ *
+ * drivers/watchdog/wdt_lpc313x.c
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/watchdog.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+
+#include <mach/hardware.h>
+
+#define MAX_HEARTBEAT 120
+#define DEFAULT_HEARTBEAT 25
+#define WDT_IN_USE        0
+#define WDT_OK_TO_CLOSE   1
+
+/* Set when a watchdog reset has occurred (read only). 
+ * This bit is cleared only by a power on reset.
+ */
+#define LPC313x_WD_BARK      (0x13004C04)
+
+/* Offset of WDT registers */
+#define LPC313x_WDT_IR       0x00
+#define LPC313x_WDT_TCR      0x04
+#define LPC313x_WDT_TC       0x08
+#define LPC313x_WDT_PR       0x0C
+#define LPC313x_WDT_PC       0x10
+#define LPC313x_WDT_MCR      0x14
+#define LPC313x_WDT_MR0      0x18
+#define LPC313x_WDT_MR1      0x1C
+#define LPC313x_WDT_EMR      0x3C
+
+#define INTR_M0      0x01
+#define INTR_M1      0x02
+
+#define TCR_EN       0x01
+#define TCR_RST      0x02
+
+#define INTEN_MR0    (1 << 0)
+#define RESET_MR0    (1 << 1)
+#define STOP_MR0     (1 << 2)
+#define INTEN_MR1    (1 << 3)
+#define RESET_MR1    (1 << 4)
+#define STOP_MR1     (1 << 5)
+
+#define TOGGLE_EMR1   	(3 << 6)
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+static int heartbeat = DEFAULT_HEARTBEAT;
+
+static struct lpc313x_wdt {
+	spinlock_t lock;
+	void __iomem *base;
+	unsigned long status;
+	unsigned long boot_status;
+	struct device *dev;
+} lpc313x_wdt;
+
+static void lpc313x_wdt_stop(struct lpc313x_wdt *wdt)
+{
+	struct clk *clk;
+	void __iomem *base = wdt->base;
+
+	/* Disable watchdog clock */
+	clk = clk_get(NULL, "wdog_pclk");
+	clk_disable(clk);
+	clk_put(clk);
+
+	/* Disable and reset counter */
+	writel(TCR_RST, base + LPC313x_WDT_TCR);
+
+	/* Clear interrupts */
+	writel(INTR_M1, base + LPC313x_WDT_TCR);
+	writel(0, base + LPC313x_WDT_MCR);
+	writel(0, base + LPC313x_WDT_PC);
+	writel(0, base + LPC313x_WDT_PR);
+
+	writel(0, base + LPC313x_WDT_EMR);
+
+	/* Bring counter out of reset */
+	writel(0, base + LPC313x_WDT_TCR);
+}
+
+static void lpc313x_wdt_start(struct lpc313x_wdt *wdt)
+{
+	struct clk *clk;
+	uint32_t freq;
+	void __iomem *base = wdt->base;
+	int ret;
+
+	/* Enable WDOG_PCLK and get its frequency */
+	clk = clk_get(NULL, "wdog_pclk");
+	ret = clk_enable(clk);
+	freq = clk_get_rate(clk);
+	clk_put(clk);
+	writel(freq - 1, base + LPC313x_WDT_PR);
+	writel(heartbeat, base + LPC313x_WDT_MR1);
+	writel(TOGGLE_EMR1, base + LPC313x_WDT_EMR);
+
+	/* Start WDT */
+	writel(TCR_EN, base + LPC313x_WDT_TCR);
+}
+
+static void lpc313x_wdt_keepalive(struct lpc313x_wdt *wdt)
+{
+	void __iomem *base = wdt->base;
+	writel(0, base + LPC313x_WDT_PC);
+	writel(0, base + LPC313x_WDT_TC);
+}
+
+/**
+ *	wdt_open:
+ *	@inode: inode of device
+ *	@file: file handle to device
+ *
+ *	The watchdog device has been opened. The watchdog device is single
+ *	open and on opening we load the counters. Counter zero is a 100Hz
+ *	cascade, into counter 1 which downcounts to reboot. When the counter
+ *	triggers counter 2 downcounts the length of the reset pulse which
+ *	set set to be as long as possible.
+ */
+
+static int lpc313x_wdt_open(struct inode *inode, struct file *file)
+{
+	struct lpc313x_wdt *wdt = &lpc313x_wdt;
+	if (test_and_set_bit(WDT_IN_USE, &wdt->status))
+		return -EBUSY;
+	clear_bit(WDT_OK_TO_CLOSE, &wdt->status);
+
+	/*
+	 *      Activate
+	 */
+	lpc313x_wdt_start(wdt);
+	return nonseekable_open(inode, file);
+}
+
+static ssize_t lpc313x_wdt_write(struct file *file, const char *data,
+				 size_t len, loff_t * ppos)
+{
+	struct lpc313x_wdt *wdt = &lpc313x_wdt;
+	if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			clear_bit(WDT_OK_TO_CLOSE, &wdt->status);
+
+			for (i = 0; i != len; i++) {
+				char c;
+
+				if (get_user(c, data + i))
+					return -EFAULT;
+				if (c == 'V')
+					set_bit(WDT_OK_TO_CLOSE, &wdt->status);
+			}
+		}
+		lpc313x_wdt_keepalive(wdt);
+	}
+
+	return len;
+}
+
+static const struct watchdog_info ident = {
+	.options = WDIOF_CARDRESET | WDIOF_MAGICCLOSE |
+	    WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	.identity = "LPC313x Watchdog",
+};
+
+static long lpc313x_wdt_ioctl(struct file *file, unsigned int cmd,
+			      unsigned long arg)
+{
+	int ret = -ENOTTY;
+	int time;
+	struct lpc313x_wdt *wdt = &lpc313x_wdt;
+	void __iomem *base = wdt->base;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		ret = copy_to_user((struct watchdog_info *)arg, &ident,
+				   sizeof(ident)) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETSTATUS:
+		ret = put_user(0, (int *)arg);
+		break;
+
+	case WDIOC_GETBOOTSTATUS:
+		ret = put_user(wdt->boot_status, (int *)arg);
+		break;
+
+	case WDIOC_KEEPALIVE:
+		lpc313x_wdt_keepalive(wdt);
+		dev_vdbg(wdt->dev, "Hearbeat received.\n");
+		ret = 0;
+		break;
+
+	case WDIOC_SETTIMEOUT:
+		ret = get_user(time, (int *)arg);
+		if (ret)
+			break;
+
+		if (time <= 0 || time > MAX_HEARTBEAT) {
+			dev_err(wdt->dev, "Timeout value should be an "
+				"integer between 1 to %d\n", MAX_HEARTBEAT);
+			ret = -EINVAL;
+			break;
+		}
+
+		heartbeat = time;
+		writel(heartbeat, base + LPC313x_WDT_MR1);
+		lpc313x_wdt_keepalive(wdt);
+		dev_vdbg(wdt->dev, "Timeout set to: %d\n", time);
+		/* Fall through */
+
+	case WDIOC_GETTIMEOUT:
+		ret = put_user(heartbeat, (int *)arg);
+		break;
+	}
+	return ret;
+}
+
+static int lpc313x_wdt_release(struct inode *inode, struct file *file)
+{
+	struct lpc313x_wdt *wdt = &lpc313x_wdt;
+	if (!test_bit(WDT_OK_TO_CLOSE, &wdt->status))
+		dev_warn(wdt->dev, "Watchdog timer closed unexpectedly\n");
+
+	if (!nowayout) {
+		lpc313x_wdt_stop(wdt);
+	}
+
+	clear_bit(WDT_IN_USE, &wdt->status);
+	clear_bit(WDT_OK_TO_CLOSE, &wdt->status);
+
+	return 0;
+}
+
+static const struct file_operations lpc313x_wdt_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.unlocked_ioctl = lpc313x_wdt_ioctl,
+	.open = lpc313x_wdt_open,
+	.write = lpc313x_wdt_write,
+	.release = lpc313x_wdt_release,
+};
+
+static struct miscdevice lpc313x_wdt_misc = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &lpc313x_wdt_fops,
+};
+
+static int lpc313x_wdt_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct resource *res;
+	struct lpc313x_wdt *wdt = &lpc313x_wdt;
+	uint32_t size;
+
+	spin_lock_init(&wdt->lock);
+	wdt->dev = &pdev->dev;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "Unable to get resources.\n");
+		return -ENXIO;
+	}
+
+	size = res->end - res->start + 1;
+	if (devm_request_mem_region(&pdev->dev,
+				    res->start, size, pdev->name) == NULL) {
+		dev_err(&pdev->dev, "Requested memory region unavailable\n");
+		return -EBUSY;
+	}
+
+	wdt->base = devm_ioremap(&pdev->dev, res->start, size);
+	if (wdt->base == NULL) {
+		dev_err(&pdev->dev, "Unable to remap memory region\n");
+		return -ENOMEM;
+	}
+
+	ret = misc_register(&lpc313x_wdt_misc);
+	if (ret < 0) {
+		dev_err(&pdev->dev, " lpc313x_wdt : failed to register\n");
+		return ret;
+	}
+	platform_set_drvdata(pdev, wdt);
+
+	wdt->boot_status =
+	    (readl((void __iomem *)io_p2v(LPC313x_WD_BARK)) & 0x1) ?
+	    WDIOF_CARDRESET : 0;
+	//lpc313x_wdt_stop(wdt); /* it defaults to stopped at boot */
+	dev_info(&pdev->dev, "Watchdog device driver initialized.\n");
+	return 0;
+}
+
+static int lpc313x_wdt_remove(struct platform_device *pdev)
+{
+	struct lpc313x_wdt *wdt = &lpc313x_wdt;
+
+	/* Stop the hardware */
+	lpc313x_wdt_stop(wdt);
+
+	misc_deregister(&lpc313x_wdt_misc);
+	/* All other resources are automatically de-allocated */
+	return 0;
+}
+
+static struct platform_driver lpc313x_wdt_driver = {
+	.probe = lpc313x_wdt_probe,
+	.remove = __devexit_p(lpc313x_wdt_remove),
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "lpc313x-wdt",
+		   },
+};
+
+static int __init lpc313x_wdt_init(void)
+{
+	return platform_driver_register(&lpc313x_wdt_driver);
+}
+
+static void __exit lpc313x_wdt_exit(void)
+{
+	platform_driver_unregister(&lpc313x_wdt_driver);
+}
+
+module_init(lpc313x_wdt_init);
+module_exit(lpc313x_wdt_exit);
+
+MODULE_AUTHOR("NXP Semiconductors");
+MODULE_DESCRIPTION("Driver for the LPC313x watchdog");
+MODULE_LICENSE("GPL");
+module_param(heartbeat, int, 0);
+MODULE_PARM_DESC(heartbeat,
+		 "Watchdog heartbeat period in seconds from 1 to "
+		 __MODULE_STRING(MAX_HEARTBEAT) ", default "
+		 __MODULE_STRING(DEFAULT_HEARTBEAT));
+
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout,
+		 "Set to 1 to keep watchdog running after device release");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_ALIAS("platform:lpc313x-wdt");
