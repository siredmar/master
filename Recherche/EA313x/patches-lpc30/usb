USB support for lpc31xx

From: Jon Smirl (none) <jonsmirl@terra>


---
 arch/arm/mach-lpc31xx/board-ea313x.c |   24 ++
 arch/arm/mach-lpc31xx/usb.c          |    4 
 drivers/usb/Kconfig                  |    1 
 drivers/usb/core/hub.c               |   14 +
 drivers/usb/core/otg_whitelist.h     |   16 +-
 drivers/usb/host/Kconfig             |   22 ++
 drivers/usb/host/Makefile            |    4 
 drivers/usb/host/ehci-hcd.c          |   12 +
 drivers/usb/host/ehci-lpc.c          |  359 ++++++++++++++++++++++++++++++++++
 drivers/usb/host/ehci.h              |   10 +
 drivers/usb/host/lpc-ehset.c         |  353 +++++++++++++++++++++++++++++++++
 11 files changed, 802 insertions(+), 17 deletions(-)
 create mode 100644 drivers/usb/host/ehci-lpc.c
 create mode 100644 drivers/usb/host/lpc-ehset.c

diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index bfd5678..b7864a4 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -602,7 +602,13 @@ static struct map_desc ea313x_io_desc[] __initdata = {
 	},
 };
 
+#define PCA9532_GPIO_BASE 0x340
+#define VBUS_PWR_EN	(6 + PCA9532_GPIO_BASE)
+#define START_STOP_LED	8  /*led5 */
+#define IDLE_LED	9  /*led6 */
+
 static struct pca9532_platform_data ea313x_leds = {
+	.gpio_base = PCA9532_GPIO_BASE,
 	.leds = {
 	{	.type = PCA9532_TYPE_GPIO }, /* key joy 1 */
 	{	.type = PCA9532_TYPE_GPIO }, /* key joy 2 */
@@ -648,7 +654,6 @@ static struct pca9532_platform_data ea313x_leds = {
 	},
 	.psc = { 0, 0 },
 	.pwm = { 0, 0 },
-	.gpio_base = 0x340,
 };
 
 static struct i2c_board_info ea313x_i2c_devices[] __initdata = {
@@ -666,6 +671,11 @@ static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
 };
 #endif
 
+void lpc313x_vbus_power(int enable)
+{
+	printk (KERN_INFO "enabling USB host vbus_power %d\n", enable);
+	gpio_set_value(VBUS_PWR_EN, enable);
+}
 
 static void __init ea313x_init(void)
 {
@@ -690,6 +700,17 @@ static void __init ea313x_init(void)
 #endif
 }
 
+#if defined(CONFIG_USB_EHCI_HCD)
+static void __init ea_usb_power(void)
+{
+	int ret; 
+
+	ret = gpio_request(VBUS_PWR_EN, "vbus power");
+	ret = gpio_direction_output(VBUS_PWR_EN, 1);
+}
+late_initcall(ea_usb_power);
+#endif
+
 static void __init ea313x_map_io(void)
 {
 	lpc313x_map_io();
@@ -717,3 +738,4 @@ MACHINE_START(EA313X, "NXP EA313X")
 MACHINE_END
 #endif
 
+
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 37ff9f0..57699b7 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -241,10 +241,6 @@ int __init usbotg_init(void)
 #endif
 	} else {
 #if defined(CONFIG_USB_EHCI_HCD)
-		/* enable VBUS power */
-		lpc313x_vbus_power(1);
-		msleep(2);
-
 		/* register host */
 		printk(KERN_INFO "Registering USB host 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
 		retval = platform_device_register(&lpc313x_ehci_device);
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 791f11b..9e2fb8a 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -71,6 +71,7 @@ config USB_ARCH_HAS_EHCI
 	default y if ARCH_VT8500
 	default y if PLAT_SPEAR
 	default y if PLAT_S5P
+	default y if ARCH_LPC31XX
 	default y if ARCH_MSM
 	default y if MICROBLAZE
 	default y if SPARC_LEON
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 7978146..7e80bb5 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1306,7 +1306,7 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
 #ifdef	CONFIG_USB_OTG_BLACKLIST_HUB
 	if (hdev->parent) {
-		dev_warn(&intf->dev, "ignoring external hub\n");
+		dev_warn(&intf->dev, "External hub not Supported\n");
 		return -ENODEV;
 	}
 #endif
@@ -1718,7 +1718,7 @@ static void announce_device(struct usb_device *udev)
 static inline void announce_device(struct usb_device *udev) { }
 #endif
 
-#ifdef	CONFIG_USB_OTG
+#ifdef	CONFIG_USB_OTG_WHITELIST
 #include "otg_whitelist.h"
 #endif
 
@@ -1792,8 +1792,16 @@ static int usb_enumerate_device_otg(struct usb_device *udev)
 		err = -ENOTSUPP;
 		goto fail;
 	}
-fail:
+#elif defined(CONFIG_USB_OTG_WHITELIST)
+	if (!is_targeted(udev)) {
+
+		dev_warn(&udev->dev, "This device is not Supported\n");
+		err = -ENOTSUPP;
+		goto fail;
+	}
+
 #endif
+fail:
 	return err;
 }
 
diff --git a/drivers/usb/core/otg_whitelist.h b/drivers/usb/core/otg_whitelist.h
index e8cdce5..45ae696 100644
--- a/drivers/usb/core/otg_whitelist.h
+++ b/drivers/usb/core/otg_whitelist.h
@@ -21,6 +21,7 @@ static struct usb_device_id whitelist_table [] = {
 /* hubs are optional in OTG, but very handy ... */
 { USB_DEVICE_INFO(USB_CLASS_HUB, 0, 0), },
 { USB_DEVICE_INFO(USB_CLASS_HUB, 0, 1), },
+{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 2), },
 
 #ifdef	CONFIG_USB_PRINTER		/* ignoring nonstatic linkage! */
 /* FIXME actually, printers are NOT supposed to use device classes;
@@ -42,7 +43,6 @@ static struct usb_device_id whitelist_table [] = {
 /* gadget zero, for testing */
 { USB_DEVICE(0x0525, 0xa4a0), },
 #endif
-
 { }	/* Terminating entry */
 };
 
@@ -50,14 +50,22 @@ static int is_targeted(struct usb_device *dev)
 {
 	struct usb_device_id	*id = whitelist_table;
 
-	/* possible in developer configs only! */
+#if defined(CONFIG_USB_OTG)
+  /* possible in developer configs only! */
 	if (!dev->bus->otg_port)
 		return 1;
-
-	/* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
+	
+  /* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
 	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&
 	     le16_to_cpu(dev->descriptor.idProduct) == 0xbadd))
 		return 0;
+#endif
+
+#if defined(CONFIG_USB_EHCI_EHSET)
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a))
+		return 1;
+
+#endif
 
 	/* NOTE: can't use usb_match_id() since interface caches
 	 * aren't set up yet. this is cut/paste from that code.
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 060e0e2..de19d0a 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -59,6 +59,21 @@ config USB_EHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
+config USB_EHCI_EHSET
+	bool "Embedded High-speed Host Electrical Test Support (EXPERIMENTAL)"
+	depends on USB_EHCI_HCD && EXPERIMENTAL
+	---help---
+	  This option is only used if you are developing firmware for
+	  an embedded device with a Hi-speed USB Host or OTG port.
+
+	  If you say Y here, software support for the Embedded High-speed
+	  Host Electrical Tests will be added to the EHCI driver. This is
+	  one of the tests performed during High-speed USB Host certification
+	  testing.
+
+	  If you are at all unsure then say N here.
+
+
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators"
 	depends on USB_EHCI_HCD
@@ -230,6 +245,13 @@ config USB_OXU210HP_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called oxu210hp-hcd.
 
+config USB_EHCI_LPC
+	bool "Support for NXP on-chip EHCI USB controller"
+	depends on USB_EHCI_HCD && ARCH_LPC31XX
+	select USB_EHCI_ROOT_HUB_TT
+	---help---
+	  Variation of ARC USB block used in some NXP chips.
+
 config USB_ISP116X_HCD
 	tristate "ISP116X HCD support"
 	depends on USB
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 7ca290f..f3b292b 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
 obj-$(CONFIG_USB_FHCI_HCD)	+= fhci.o
 obj-$(CONFIG_USB_XHCI_HCD)	+= xhci-hcd.o
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
+obj-$(CONFIG_USB_EHCI_EHSET)	+= lpc-ehset.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
 obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
@@ -37,3 +38,6 @@ obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_MIPS_ALCHEMY)	+= alchemy-common.o
+
+
+
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 3ff9f82..82085a8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1324,11 +1324,21 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_pxa168_driver
 #endif
 
-#ifdef CONFIG_NLM_XLR
+#ifdef CONFIG_USB_EHCI_LPC
+#include "ehci-lpc.c"
+#define	PLATFORM_DRIVER		ehci_lpc_driver
+#endif
+
+#ifdef CONFIG_CPU_XLR
 #include "ehci-xls.c"
 #define PLATFORM_DRIVER		ehci_xls_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_MV
+#include "ehci-mv.c"
+#define        PLATFORM_DRIVER         ehci_mv_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)
diff --git a/drivers/usb/host/ehci-lpc.c b/drivers/usb/host/ehci-lpc.c
new file mode 100644
index 0000000..9932f36
--- /dev/null
+++ b/drivers/usb/host/ehci-lpc.c
@@ -0,0 +1,359 @@
+/*
+ * LPC313x & LPC315x EHCI Host Controller Driver
+ *
+ * Author: Durgesh Pattamatta <durgesh.pattamatta@nxp.com>
+ *
+ * Based on "ehci-fsl.c" by Randy Vinson <rvinson@mvista.com>
+ *
+ * 2009 (c) NXP Semiconductors. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <mach/board.h>
+
+static struct platform_driver ehci_lpc_driver;
+
+static int lpc_ehci_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval = 0;
+
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100
+		+ HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	/* data structure init */
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+	
+	hcd->has_tt = 1;
+
+	ehci->sbrn = 0x20;
+	ehci_reset(ehci);
+
+	ehci_port_power(ehci, 0);
+	/* board vbus power */
+	//lpc313x_vbus_power(0);
+
+	return retval;
+}
+
+static const struct hc_driver lpc_ehci_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "LPC EHCI Host Controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+	.reset			= lpc_ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.get_frame_number	= ehci_get_frame,
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+};
+
+static int lpc_ehci_probe(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	struct usb_hcd *hcd;
+	const struct hc_driver *driver = &lpc_ehci_hc_driver;
+	struct resource *res;
+	int irq;
+	int retval;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	/* Need platform data for setup */
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	/*
+	 * This is a host mode driver, verify that we're supposed to be
+	 * in host mode.
+	 */
+	if (!((pdata->operating_mode == FSL_USB2_DR_HOST) ||
+	      (pdata->operating_mode == FSL_USB2_DR_OTG))) {
+		dev_err(&pdev->dev,
+			"Non Host Mode configured for %s. Wrong driver linked.\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto fail_create_hcd;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		retval = -ENODEV;
+		goto fail_request_resource;
+	}
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+/*	
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+				driver->description)) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto fail_request_resource;
+	}
+*/
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (hcd->regs == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto fail_ioremap;
+	}
+
+	/* Set to Host mode */
+	writel(USBMODE_CM_HC, (hcd->regs + 0x1a8));
+
+	
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto fail_add_hcd;
+
+#if defined(CONFIG_USB_OTG)
+	if (pdata->operating_mode == FSL_USB2_DR_OTG) {
+		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+		dbg("pdev=0x%p  hcd=0x%p  ehci=0x%p\n", pdev, hcd, ehci);
+
+		ehci->transceiver = otg_get_transceiver();
+
+		printk(KERN_INFO "ehci->transceiver=0x%p, driver=0x%p\n", (void*)ehci->transceiver, (void*)&ehci_lpc_driver);
+
+		if (ehci->transceiver) {
+			retval = otg_set_host(ehci->transceiver,
+					      &ehci_to_hcd(ehci)->self);
+			if (retval) {
+				if (ehci->transceiver)
+					otg_put_transceiver(ehci->transceiver);
+				goto fail_add_hcd;
+			}
+		} else {
+			printk(KERN_ERR "can't find transceiver\n");
+			retval = -ENODEV;
+			goto fail_add_hcd;
+		}
+	}
+#endif
+	return retval;
+
+fail_add_hcd:
+	iounmap(hcd->regs);
+fail_ioremap:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+fail_request_resource:
+	usb_put_hcd(hcd);
+fail_create_hcd:
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
+	return retval;
+}
+
+static int lpc_ehci_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+#if defined(CONFIG_USB_OTG)
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	if (ehci->transceiver) {
+		(void)otg_set_host(ehci->transceiver, 0);
+		otg_put_transceiver(ehci->transceiver);
+	}
+#endif
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_OTG
+volatile static struct ehci_regs usb_ehci_regs;
+
+/* suspend/resume, section 4.3 */
+
+/* These routines rely on the bus (pci, platform, etc)
+ * to handle powerdown and wakeup, and currently also on
+ * transceivers that don't need any software attention to set up
+ * the right sort of wakeup.
+ *
+ * They're also used for turning on/off the port when doing OTG.
+ */
+static int lpc_ehci_suspend(struct device *dev, pm_message_t state)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 cmd;
+
+	dev_dbg(dev, "%s pdev=0x%p  ehci=0x%p  hcd=0x%p\n",
+		 __FUNCTION__, pdev, ehci, hcd);
+	dev_dbg(dev, "%s ehci->regs=0x%p  hcd->regs=0x%p  hcd->state=%d\n",
+		 __FUNCTION__, ehci->regs, hcd->regs, hcd->state);
+
+	hcd->state = HC_STATE_SUSPENDED;
+	pdev->dev.power.power_state = PMSG_SUSPEND;
+
+	/* ignore non-host interrupts */
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	cmd = ehci_readl(ehci, &ehci->regs->command);
+	cmd &= ~CMD_RUN;
+	ehci_writel(ehci, cmd, &ehci->regs->command);
+
+	memcpy((void *)&usb_ehci_regs, ehci->regs, sizeof(struct ehci_regs));
+	usb_ehci_regs.port_status[0] &=
+	    cpu_to_le32(~(PORT_PEC | PORT_OCC | PORT_CSC));
+
+	/* put the device in idele mode */
+	writel(0, (hcd->regs + 0x1a8));
+	/* board vbus power */
+	//lpc313x_vbus_power(0);
+
+	return 0;
+}
+
+static int lpc_ehci_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 tmp;
+
+	dbg("%s pdev=0x%p  pdata=0x%p  ehci=0x%p  hcd=0x%p\n",
+	    __FUNCTION__, pdev, pdata, ehci, hcd);
+
+	vdbg("%s ehci->regs=0x%p  hcd->regs=0x%p  usbmode=0x%x\n",
+	     __FUNCTION__, ehci->regs, hcd->regs, pdata->usbmode);
+
+	/* Set to Host mode */
+	writel(USBMODE_CM_HC, (hcd->regs + 0x1a8));
+
+	memcpy(ehci->regs, (void *)&usb_ehci_regs, sizeof(struct ehci_regs));
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	hcd->state = HC_STATE_RUNNING;
+	pdev->dev.power.power_state = PMSG_ON;
+
+	tmp = ehci_readl(ehci, &ehci->regs->command);
+	tmp |= CMD_RUN;
+	ehci_writel(ehci, tmp, &ehci->regs->command);
+
+	/* board vbus power */
+	//lpc313x_vbus_power(1);
+
+
+	usb_hcd_resume_root_hub(hcd);
+
+	return 0;
+}
+#endif				/* CONFIG_USB_OTG */
+/**
+ * FIXME: This should get into a common header
+ * currently declared in arch/arm/mach-lpc313x/usb.c
+ **/
+#define USB_DEV_PORTSC1			__REG(USBOTG_PHYS + 0x184)
+#define USBPRTS_PLPSCD	_BIT(23)
+static int lpc313x_ehci_suspend(struct platform_device *pdev, pm_message_t state)
+{
+#ifdef CONFIG_PM
+	disable_irq(IRQ_VBUS_OVRC);
+	/* Shutoff vbus power */
+	lpc313x_vbus_power(0);
+	/* Bring PHY to low power state */
+	USB_DEV_PORTSC1 |= USBPRTS_PLPSCD;
+	/* Bring PLL to low power state */
+	SYS_USB_ATX_PLL_PD_REG = 0x1;
+	/* Shutoff IP Clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 0);
+#endif
+	return 0;
+}
+
+static int lpc313x_ehci_resume(struct platform_device * pdev)
+{
+#ifdef CONFIG_PM
+	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	int tout = 100;
+
+	/* Turn on IP Clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 1);
+	/* Bring PLL to low power state */
+	SYS_USB_ATX_PLL_PD_REG = 0x0;
+	/* wait for PLL to lock */
+	while (!(EVRT_RSR(bank) & _BIT(bit_pos))){
+		udelay(5);
+		if (!tout--)
+			break;
+	}
+	/* Bring PHY to active state */
+	USB_DEV_PORTSC1 &= ~USBPRTS_PLPSCD;
+	lpc313x_vbus_power(1);
+	enable_irq(IRQ_VBUS_OVRC);
+#endif
+	return 0;
+}
+
+static struct platform_driver ehci_lpc_driver = {
+	.probe = lpc_ehci_probe,
+	.remove = lpc_ehci_remove,
+	.suspend = lpc313x_ehci_suspend,
+	.resume = lpc313x_ehci_resume,
+	.driver = {
+		.name = "lpc-ehci",
+#ifdef CONFIG_USB_OTG
+		.suspend = lpc_ehci_suspend,
+		.resume  = lpc_ehci_resume,
+#endif
+	},
+};
+
+MODULE_ALIAS("platform:lpc-ehci");
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 0a5fda7..3c8d637 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -161,6 +161,12 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		has_ppcd:1; /* support per-port change bits */
 	u8			sbrn;		/* packed release number */
 
+	/*
+	 * OTG controllers and transceivers need software interaction;
+	 * other external transceivers should be software-transparent 
+	 */
+	struct otg_transceiver   *transceiver;
+
 	/* irq statistics */
 #ifdef EHCI_STATS
 	struct ehci_stats	stats;
@@ -173,10 +179,6 @@ struct ehci_hcd {			/* one per controller */
 #ifdef DEBUG
 	struct dentry		*debug_dir;
 #endif
-	/*
-	 * OTG controllers and transceivers need software interaction
-	 */
-	struct otg_transceiver	*transceiver;
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
diff --git a/drivers/usb/host/lpc-ehset.c b/drivers/usb/host/lpc-ehset.c
new file mode 100644
index 0000000..6a0e669
--- /dev/null
+++ b/drivers/usb/host/lpc-ehset.c
@@ -0,0 +1,353 @@
+/* linux/arch/arm/mach-lpc313x/usb.c -- platform level USB initialization
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * USB initialization code.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/usb.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include "../core/usb.h"
+#include "../core/hcd.h"
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <mach/hardware.h>
+
+/****************************************************************************
+* USBOTG register definition
+****************************************************************************/
+#define USB_DEV_PORTSC1			__REG(USBOTG_PHYS + 0x184)
+
+/*-------------------------------------------------------------------------*/
+
+#define USB_PORT_TEST_DISABLE			0x00
+#define USB_PORT_TEST_J				0x01
+#define USB_PORT_TEST_K				0x02
+#define USB_PORT_TEST_SE0_NAK			0x03
+#define USB_PORT_TEST_PACKET			0x04
+#define USB_PORT_TEST_FORCE_ENABLE_HS		0x05
+#define USB_PORT_TEST_FORCE_ENABLE_FS		0x06
+#define USB_PORT_TEST_FORCE_ENABLE_LS		0x07
+
+/*---------------------------------------------------------------------------*/
+/* This is the list of VID/PID that the HS OPT card will use. */
+static struct usb_device_id hset_table [] = {
+	{ USB_DEVICE(6666, 0x0101) },	/* TEST_SE0_NAK */
+	{ USB_DEVICE(6666, 0x0102) },	/* TEST_J */
+	{ USB_DEVICE(6666, 0x0103) },	/* TEST_K */
+	{ USB_DEVICE(6666, 0x0104) },	/* TEST_PACKET */
+	{ USB_DEVICE(6666, 0x0105) },	/* TEST_FORCE_ENABLE */
+	{ USB_DEVICE(6666, 0x0106) },	/* HS_HOST_PORT_SUSPEND_RESUME */
+	{ USB_DEVICE(6666, 0x0107) },	/* SINGLE_STEP_GET_DEV_DESC */
+	{ USB_DEVICE(6666, 0x0108) },	/* SINGLE_STEP_SET_FEATURE */
+	{ }				/* Terminating entry */
+};
+MODULE_DEVICE_TABLE (usb, hset_table);
+
+/* Structure to hold all of our device specific stuff */
+struct usb_hset {
+	struct usb_device *	udev;	/* the usb device for this device */
+	struct usb_interface *	interface; /* the interface for this device */
+	struct kref		kref;
+	struct usb_hcd *	hcd;
+};
+#define to_hset_dev(d) container_of(d, struct usb_hset, kref)
+
+static struct usb_hset *the_hset;
+static struct usb_driver hset_driver;
+
+/*---------------------------------------------------------------------------*/
+/* Test routines */
+static inline void test_se0_nak(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_SE0_NAK << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static inline void test_j(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_J << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static inline void test_k(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_K << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static inline void test_packet(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_PACKET << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static inline void test_force_enable(struct usb_hset *hset)
+{
+	u32 temp = USB_DEV_PORTSC1;
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	temp &= ~(0xF << 16);
+	temp |= USB_PORT_TEST_FORCE_ENABLE_HS << 16;
+	USB_DEV_PORTSC1 = temp;
+}
+
+static void suspend(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	
+	USB_DEV_PORTSC1 |= (1 << 7);
+}
+
+static void resume(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	USB_DEV_PORTSC1 |= (1 << 6);
+}
+
+static void test_suspend_resume(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	suspend(hset);
+	msleep(15000);	/* Wait for 15 sec */
+	resume(hset);
+}
+
+static void test_single_step_get_dev_desc(struct usb_hset *hset)
+{
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(hset->hcd);
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_DEBUG "No device connected.\n");
+		return;
+	}
+	usb_get_device_descriptor(udev, sizeof(struct usb_device_descriptor));
+}
+
+static void test_single_step_set_feature(struct usb_hset *hset)
+{
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(hset->hcd);
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_DEBUG "No device connected.\n");
+		return;
+	}
+	usb_control_msg(udev,
+			usb_sndctrlpipe(udev, 0),
+			USB_REQ_SET_FEATURE, 0, 0,
+			0, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
+}
+
+static void enumerate_bus(struct work_struct *ignored)
+{
+	struct usb_hset *hset = the_hset;
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(hset->hcd);
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (udev)
+		usb_reset_device(udev);
+}
+
+DECLARE_WORK(enumerate, enumerate_bus);
+
+/*---------------------------------------------------------------------------*/
+
+/* This function can be called either by musb_init_hset() or usb_hset_probe().
+ * musb_init_hset() is called by the controller driver during its init(),
+ * while usb_hset_probe() is called when an OPT is attached. We take care not
+ * to allocate the usb_hset structure twice.
+ */
+static struct usb_hset* init_hset_dev(void *controller)
+{
+	struct usb_hset *hset = NULL;
+
+	/* if already allocated, just increment use count and return */
+	if (the_hset) {
+		kref_get(&the_hset->kref);
+		return the_hset;
+	}
+
+	hset = kmalloc(sizeof(*hset), GFP_KERNEL);
+	if (hset == NULL) {
+		err("Out of memory");
+		return NULL;
+	}
+	memset(hset, 0x00, sizeof(*hset));
+	hset->hcd = (struct usb_hcd *)(controller);
+
+	kref_init(&hset->kref);
+	the_hset = hset;
+	return hset;
+}
+
+static void hset_delete(struct kref *kref)
+{
+	struct usb_hset *dev = to_hset_dev(kref);
+
+	kfree (dev);
+}
+/*---------------------------------------------------------------------------*/
+/* Usage of HS OPT */
+
+
+/* Called when the HS OPT is attached as a device */
+static int hset_probe(struct usb_interface *interface,
+		      const struct usb_device_id *id)
+{
+	struct usb_hset *hset;
+	struct usb_device *udev;
+	struct usb_hcd *hcd;
+	int retval = -ENOMEM;
+
+	udev = usb_get_dev(interface_to_usbdev(interface));
+	hcd = bus_to_hcd(udev->bus);
+	hset = init_hset_dev(hcd);
+	if (!hset)
+		return retval;
+
+	hset->udev = udev;
+	hset->interface = interface;
+	usb_set_intfdata(interface, hset);
+
+	switch(id->idProduct) {
+	case 0x0101:
+		test_se0_nak(hset);
+		break;
+	case 0x0102:
+		test_j(hset);
+		break;
+	case 0x0103:
+		test_k(hset);
+		break;
+	case 0x0104:
+		test_packet(hset);
+		break;
+	case 0x0105:
+		test_force_enable(hset);
+		break;
+	case 0x0106:
+		test_suspend_resume(hset);
+		break;
+	case 0x0107:
+		msleep(15000);	/* SOFs for 15 sec */
+		test_single_step_get_dev_desc(hset);
+		break;
+	case 0x0108:
+		test_single_step_get_dev_desc(hset);
+		msleep(15000);	/* SOFs for 15 sec */
+		test_single_step_set_feature(hset);
+		break;
+	};
+	return 0;
+}
+
+static void hset_disconnect(struct usb_interface *interface)
+{
+	struct usb_hset *hset;
+
+	/* prevent hset_open() from racing hset_disconnect() */
+	//lock_kernel();
+	hset = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+	//unlock_kernel();
+
+	usb_put_dev(hset->udev);
+	kref_put(&hset->kref, hset_delete);
+}
+
+static struct usb_driver hset_driver = {
+//	.owner =	THIS_MODULE,
+	.name =		"hset",
+	.probe =	hset_probe,
+	.disconnect =	hset_disconnect,
+	.id_table =	hset_table,
+};
+
+static int __init usb_hset_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&hset_driver);
+	if (result)
+		err("usb_register failed. Error number %d", result);
+
+	return result;
+}
+
+static void __exit usb_hset_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&hset_driver);
+}
+
+module_init (usb_hset_init);
+module_exit (usb_hset_exit);
+
+MODULE_LICENSE("GPL");
+
