base patches minus 8250

From: Jon Smirl <jonsmirl@terra.(none)>


---
 arch/arm/Kconfig                                  |   22 
 arch/arm/Makefile                                 |    1 
 arch/arm/mach-lpc31xx/Kconfig                     |   37 +
 arch/arm/mach-lpc31xx/Makefile                    |   23 
 arch/arm/mach-lpc31xx/Makefile.boot               |    4 
 arch/arm/mach-lpc31xx/board-ea313x.c              |  682 +++++++++++++++
 arch/arm/mach-lpc31xx/board-val3153.c             |  460 ++++++++++
 arch/arm/mach-lpc31xx/borad-val3154.c             |  304 +++++++
 arch/arm/mach-lpc31xx/clock.c                     |  970 +++++++++++++++++++++
 arch/arm/mach-lpc31xx/dma.c                       |  551 ++++++++++++
 arch/arm/mach-lpc31xx/generic.c                   |  271 ++++++
 arch/arm/mach-lpc31xx/gpio.c                      |  135 +++
 arch/arm/mach-lpc31xx/gpiolib.c                   |  224 +++++
 arch/arm/mach-lpc31xx/i2c.c                       |  156 +++
 arch/arm/mach-lpc31xx/include/mach/board.h        |  151 +++
 arch/arm/mach-lpc31xx/include/mach/clkdev.h       |    7 
 arch/arm/mach-lpc31xx/include/mach/clock.h        |  656 ++++++++++++++
 arch/arm/mach-lpc31xx/include/mach/constants.h    |  107 ++
 arch/arm/mach-lpc31xx/include/mach/debug-macro.S  |   26 +
 arch/arm/mach-lpc31xx/include/mach/dma.h          |  383 ++++++++
 arch/arm/mach-lpc31xx/include/mach/entry-macro.S  |   35 +
 arch/arm/mach-lpc31xx/include/mach/event_router.h |  201 ++++
 arch/arm/mach-lpc31xx/include/mach/gpio.h         |  252 +++++
 arch/arm/mach-lpc31xx/include/mach/hardware.h     |   79 ++
 arch/arm/mach-lpc31xx/include/mach/i2c.h          |   76 ++
 arch/arm/mach-lpc31xx/include/mach/io.h           |   33 +
 arch/arm/mach-lpc31xx/include/mach/irqs.h         |  198 ++++
 arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h   |   25 +
 arch/arm/mach-lpc31xx/include/mach/memory.h       |   29 +
 arch/arm/mach-lpc31xx/include/mach/registers.h    |  658 ++++++++++++++
 arch/arm/mach-lpc31xx/include/mach/system.h       |   52 +
 arch/arm/mach-lpc31xx/include/mach/timex.h        |   29 +
 arch/arm/mach-lpc31xx/include/mach/uncompress.h   |   88 ++
 arch/arm/mach-lpc31xx/include/mach/vmalloc.h      |   21 
 arch/arm/mach-lpc31xx/irq.c                       |  346 +++++++
 arch/arm/mach-lpc31xx/leds.c                      |  102 ++
 arch/arm/mach-lpc31xx/pm.c                        |  279 ++++++
 arch/arm/mach-lpc31xx/pm_standby.S                |  216 +++++
 arch/arm/mach-lpc31xx/psu.c                       |  227 +++++
 arch/arm/mach-lpc31xx/time.c                      |   96 ++
 arch/arm/mach-lpc31xx/usb.c                       |  301 +++++++
 arch/arm/mach-lpc31xx/wdt.c                       |   47 +
 arch/arm/tools/mach-types                         |   40 +
 drivers/i2c/busses/Kconfig                        |    2 
 drivers/i2c/busses/i2c-pnx.c                      |    3 
 drivers/net/ethernet/cirrus/cs89x0.c              |   63 +
 drivers/net/ethernet/davicom/dm9000.c             |    1 
 include/linux/serial_core.h                       |    3 
 48 files changed, 8664 insertions(+), 8 deletions(-)
 create mode 100644 arch/arm/mach-lpc31xx/Kconfig
 create mode 100644 arch/arm/mach-lpc31xx/Makefile
 create mode 100644 arch/arm/mach-lpc31xx/Makefile.boot
 create mode 100644 arch/arm/mach-lpc31xx/board-ea313x.c
 create mode 100644 arch/arm/mach-lpc31xx/board-val3153.c
 create mode 100644 arch/arm/mach-lpc31xx/borad-val3154.c
 create mode 100644 arch/arm/mach-lpc31xx/clock.c
 create mode 100644 arch/arm/mach-lpc31xx/dma.c
 create mode 100644 arch/arm/mach-lpc31xx/generic.c
 create mode 100644 arch/arm/mach-lpc31xx/gpio.c
 create mode 100644 arch/arm/mach-lpc31xx/gpiolib.c
 create mode 100644 arch/arm/mach-lpc31xx/i2c.c
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/board.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/clock.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/constants.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/dma.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/event_router.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/gpio.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/hardware.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/i2c.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/io.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/irqs.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/memory.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/registers.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/system.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/timex.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-lpc31xx/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-lpc31xx/irq.c
 create mode 100644 arch/arm/mach-lpc31xx/leds.c
 create mode 100644 arch/arm/mach-lpc31xx/pm.c
 create mode 100644 arch/arm/mach-lpc31xx/pm_standby.S
 create mode 100644 arch/arm/mach-lpc31xx/psu.c
 create mode 100644 arch/arm/mach-lpc31xx/time.c
 create mode 100644 arch/arm/mach-lpc31xx/usb.c
 create mode 100644 arch/arm/mach-lpc31xx/wdt.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index b259c7c..e535b3e 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -977,6 +977,20 @@ config ARCH_ZYNQ
 	select USE_OF
 	help
 	  Support for Xilinx Zynq ARM Cortex A9 Platform
+
+config ARCH_LPC31XX
+	bool "NXP LPC31XX series"
+	select CPU_ARM926T
+	select GENERIC_GPIO
+	select CLKDEV_LOOKUP
+	select ARCH_REQUIRE_GPIOLIB
+	select ARCH_USES_GETTIMEOFFSET
+	help
+	  Say Y here for systems based on one of the NXP LPC313x & LPC315x
+	  System on a Chip processors.  These CPUs include an ARM926EJS
+	  core with a wide array of integrated devices for
+	  hand-held and low-power applications.
+
 endchoice
 
 #
@@ -1099,6 +1113,8 @@ source "arch/arm/mach-vt8500/Kconfig"
 
 source "arch/arm/mach-w90x900/Kconfig"
 
+source "arch/arm/mach-lpc31xx/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -1719,7 +1735,7 @@ config LEDS
 		   ARCH_LUBBOCK || MACH_MAINSTONE || ARCH_NETWINDER || \
 		   ARCH_OMAP || ARCH_P720T || ARCH_PXA_IDP || \
 		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE || \
-		   ARCH_AT91 || ARCH_DAVINCI || \
+		   ARCH_AT91 || ARCH_DAVINCI || ARCH_LPC31XX || \
 		   ARCH_KS8695 || MACH_RD88F5182 || ARCH_REALVIEW
 	help
 	  If you say Y here, the LEDs on your machine will be used
@@ -1735,7 +1751,7 @@ config LEDS
 config LEDS_TIMER
 	bool "Timer LED" if (!ARCH_CDB89712 && !ARCH_OMAP) || \
 			    OMAP_OSK_MISTRAL || MACH_OMAP_H2 \
-			    || MACH_OMAP_PERSEUS2
+			    || MACH_OMAP_PERSEUS2 || ARCH_LPC31XX
 	depends on LEDS
 	depends on !GENERIC_CLOCKEVENTS
 	default y if ARCH_EBSA110
@@ -1754,7 +1770,7 @@ config LEDS_CPU
 	bool "CPU usage LED" if (!ARCH_CDB89712 && !ARCH_EBSA110 && \
 			!ARCH_OMAP) \
 			|| OMAP_OSK_MISTRAL || MACH_OMAP_H2 \
-			|| MACH_OMAP_PERSEUS2
+			|| MACH_OMAP_PERSEUS2 || ARCH_LPC31XX
 	depends on LEDS
 	help
 	  If you say Y here, the red LED will be used to give a good real
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index dfcf3b0..f32515c 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -198,6 +198,7 @@ machine-$(CONFIG_MACH_SPEAR310)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR320)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR600)		:= spear6xx
 machine-$(CONFIG_ARCH_ZYNQ)		:= zynq
+machine-$(CONFIG_ARCH_LPC31XX)		:= lpc31xx
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
diff --git a/arch/arm/mach-lpc31xx/Kconfig b/arch/arm/mach-lpc31xx/Kconfig
new file mode 100644
index 0000000..63ce681
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/Kconfig
@@ -0,0 +1,37 @@
+menu "LPC313x Implementations"
+	depends on ARCH_LPC31XX
+
+choice
+	prompt "LPC313x Platform type"
+	default MACH_EA313X
+
+config MACH_EA313X
+	bool "ea313x board"
+	help
+	  Say Y here if you are using the Embedded Artist's EA313x board
+
+config MACH_EA3152
+	bool "ea3152 board"
+	select LPC3152_AD
+	help
+	  Say Y here if you are using Embedded Artist's EA3152 board
+	  
+config MACH_VAL3153
+	bool "val3153 board"
+	help
+	  Say Y here if you are using the NXP val3153 board
+
+config MACH_VAL3154
+	bool "val3154 board"
+	select LPC3152_AD
+	help
+	  Say Y here if you are using the NXP val3154 board
+	  
+endchoice
+
+config LPC3152_AD
+	bool
+
+source "kernel/Kconfig.hz"
+
+endmenu
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
new file mode 100644
index 0000000..5298fdf
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -0,0 +1,23 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y			+= irq.o time.o generic.o i2c.o gpio.o dma.o usb.o wdt.o clock.o
+obj-$(CONFIG_GPIOLIB) += gpiolib.o
+
+
+# Specific board support
+obj-$(CONFIG_MACH_VAL3153) += board-val3153.o leds.o
+obj-$(CONFIG_MACH_EA313X) += board-ea313x.o
+obj-$(CONFIG_MACH_EA3152) += board-ea313x.o
+obj-$(CONFIG_MACH_VAL3154) += board-val3154.o leds.o
+obj-$(CONFIG_LPC3152_AD) += psu.o
+
+# Power Management
+obj-$(CONFIG_PM)		+= pm.o pm_standby.o
+
+ifeq ($(CONFIG_PM_DEBUG),y)
+CFLAGS_pm.o += -DDEBUG
+endif
diff --git a/arch/arm/mach-lpc31xx/Makefile.boot b/arch/arm/mach-lpc31xx/Makefile.boot
new file mode 100644
index 0000000..7f30366
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/Makefile.boot
@@ -0,0 +1,4 @@
+zreladdr-y	:= 0x30008000
+params_phys-y	:= 0x30000100
+initrd_phys-y	:= 0x32000000
+
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
new file mode 100644
index 0000000..038bebf
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -0,0 +1,682 @@
+/*  arch/arm/mach-lpc313x/ea313x.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  ea313x board init routines.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dm9000.h>
+#include <linux/spi/ads7846.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+#include <linux/leds-pca9532.h>
+#include <linux/gpio.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <mach/gpio.h>
+#include <mach/i2c.h>
+#include <mach/board.h>
+
+static struct lpc313x_mci_irq_data irq_data = {
+	.irq = IRQ_SDMMC_CD,
+};
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value(GPIO_MI2STX_BCK0);
+}
+
+static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+
+	irq_set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	int level;
+
+	/* enable power to the slot */
+	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
+	gpio_set_value(GPIO_MI2STX_DATA0, 0);
+	/* set cd pins as GPIO pins */
+	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
+	gpio_direction_input(GPIO_MI2STX_BCK0);
+
+	/* select the opposite level senstivity */
+	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+	/* set card detect irq info */
+	irq_data.data = data;
+	irq_data.irq_hdlr = irqhdlr;
+	irq_set_irq_type(irq_data.irq, level);
+	ret = request_irq(irq_data.irq,
+			ea313x_mci_detect_interrupt,
+			level,
+			"mmc-cd", 
+			&irq_data);
+	/****temporary for PM testing */
+	enable_irq_wake(irq_data.irq);
+
+	return irq_data.irq;
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return 0;
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	/* on current version of EA board the card detect
+	 * pull-up in on switched power side. So can't do
+	 * power management so use the always enable power 
+	 * jumper.
+	 */
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data.irq, &irq_data);
+}
+
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+static struct lpc313x_mci_board ea313x_mci_platform_data = {
+	.num_slots		= 1,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.exit			= mci_exit,
+};
+
+static u64 mci_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_mci_device = {
+	.name		= "lpc313x_mmc",
+	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
+	.dev		= {
+		.dma_mask		= &mci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &ea313x_mci_platform_data,
+	},
+	.resource	= lpc313x_mci_resources,
+};
+
+#if defined (CONFIG_FB_SSD1289)
+static struct resource ssd1289_resource[] = {
+	[0] = {
+		.start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
+		.end   = EXT_SRAM0_PHYS + 0x00000 + 0xffff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = EXT_SRAM0_PHYS + 0x10000 + 0x0000,
+		.end   = EXT_SRAM0_PHYS + 0x10000 + 0xffff,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ssd1289_device = {
+	.name          = "ssd1289",
+	.id            = 0,
+	.num_resources = ARRAY_SIZE(ssd1289_resource),
+	.resource      = ssd1289_resource,
+};
+
+static void __init ea_add_device_ssd1289(void)
+{
+	MPMC_STCONFIG0 = 0x81;
+	MPMC_STWTWEN0  = 0;
+	MPMC_STWTOEN0  = 0;
+	MPMC_STWTRD0   = 31;
+	MPMC_STWTPG0   = 0;
+	MPMC_STWTWR0   = 3;
+	MPMC_STWTTURN0 = 0;
+
+	platform_device_register(&ssd1289_device);
+}
+#else
+static void __init ea_add_device_ssd1289(void) {}
+#endif /* CONFIG_SSD1289 */
+
+/*
+ * DM9000 ethernet device
+ */
+#if defined(CONFIG_DM9000)
+static struct resource dm9000_resource[] = {
+	[0] = {
+		.start	= EXT_SRAM1_PHYS,
+		.end	= EXT_SRAM1_PHYS + 0xFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= EXT_SRAM1_PHYS + 0x10000,
+		.end	= EXT_SRAM1_PHYS + 0x100FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= IRQ_DM9000_ETH_INT,
+		.end	= IRQ_DM9000_ETH_INT,
+		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	}
+};
+/* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive 
+reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
+other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time 
+such as 80 usecs. 
+LPC313x has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
+The latest Apex bootloader pacth makes use of this feture.
+For this to work SYS_MPMC_WTD_DEL0 & SYS_MPMC_WTD_DEL1 should be programmed with MPMC_STWTRD0
+& MPMC_STWTRD1 values. The logic only deactivates the nOE for one clock cycle which is
+11nsec but DM9000 needs 80nsec between nOEs. So lets add some dummy instructions such as
+reading a GPIO register to compensate for extra 70nsec.
+*/
+# define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
+
+static void dm9000_dumpblk(void __iomem *reg, int count)
+{
+	int i;
+	int tmp;
+
+	count = (count + 1) >> 1;
+	for (i = 0; i < count; i++) {
+		DM_IO_DELAY();
+		tmp = readw(reg);
+	}
+}
+
+static void dm9000_inblk(void __iomem *reg, void *data, int count)
+{
+	int i;
+	u16* pdata = (u16*)data;
+	count = (count + 1) >> 1;
+	for (i = 0; i < count; i++) {
+		DM_IO_DELAY();
+		*pdata++ = readw(reg);
+	}
+}
+
+static struct dm9000_plat_data dm9000_platdata = {
+	.flags		= DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM | DM9000_PLATF_SIMPLE_PHY,
+	.dumpblk = dm9000_dumpblk,
+	.inblk = dm9000_inblk,
+};
+
+static struct platform_device dm9000_device = {
+	.name		= "dm9000",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dm9000_resource),
+	.resource	= dm9000_resource,
+	.dev		= {
+		.platform_data	= &dm9000_platdata,
+	}
+};
+static void __init ea_add_device_dm9000(void)
+{
+	/*
+	 * Configure Chip-Select 2 on SMC for the DM9000.
+	 * Note: These timings were calculated for MASTER_CLOCK = 90000000
+	 *  according to the DM9000 timings.
+	 */
+	MPMC_STCONFIG1 = 0x81;
+	MPMC_STWTWEN1 = 1;
+	MPMC_STWTOEN1 = 1;
+	MPMC_STWTRD1 = 4;
+	MPMC_STWTPG1 = 1;
+	MPMC_STWTWR1 = 1;
+	MPMC_STWTTURN1 = 2;
+	/* enable oe toggle between consec reads */
+	SYS_MPMC_WTD_DEL1 = _BIT(5) | 4;
+
+	/* Configure Interrupt pin as input, no pull-up */
+	if (gpio_request(GPIO_MNAND_RYBN3, "dm9000 interrupt"))
+		return;
+
+	gpio_direction_input(GPIO_MNAND_RYBN3);
+
+	platform_device_register(&dm9000_device);
+}
+#else
+static void __init ea_add_device_dm9000(void) {}
+#endif /* CONFIG_DM9000 */
+
+
+#if defined (CONFIG_MTD_NAND_LPC313X)
+static struct resource lpc313x_nand_resources[] = {
+	[0] = {
+		.start  = IO_NAND_PHYS,
+		.end	= IO_NAND_PHYS + IO_NAND_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= IO_NAND_BUF_PHYS,
+		.end 	= IO_NAND_BUF_PHYS + IO_NAND_BUF_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start 	= IRQ_NAND_FLASH,
+		.end 	= IRQ_NAND_FLASH,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition ea313x_nand0_partitions[] = {
+	/* The EA3131 board uses the following block scheme:
+	128K: Blocks 0   - 0    - LPC31xx info and bad block table
+	384K: Blocks 1   - 3    - Apex bootloader
+	256K: Blocks 4   - 5    - Apex environment
+	4M:   Blocks 6   - 37   - Kernel image
+	16M:  Blocks 38  - 165  - Ramdisk image (if used)
+	???:  Blocks 166 - end  - Root filesystem/storage */
+	{
+		.name	= "lpc313x-rootfs",
+		.offset	= (BLK_SIZE * 166),
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct lpc313x_nand_timing ea313x_nanddev_timing = {
+	.ns_trsd	= 36,
+	.ns_tals	= 36,
+	.ns_talh	= 12,
+	.ns_tcls	= 36,
+	.ns_tclh	= 12,
+	.ns_tdrd	= 36,
+	.ns_tebidel	= 12,
+	.ns_tch		= 12,
+	.ns_tcs		= 48,
+	.ns_treh	= 24,
+	.ns_trp		= 48,
+	.ns_trw		= 24,
+	.ns_twp		= 36
+};
+
+static struct lpc313x_nand_dev_info ea313x_ndev[] = {
+	{
+		.name		= "nand0",
+		.nr_partitions	= ARRAY_SIZE(ea313x_nand0_partitions),
+		.partitions	= ea313x_nand0_partitions
+	}
+};
+
+static struct lpc313x_nand_cfg ea313x_plat_nand = {
+	.nr_devices	= ARRAY_SIZE(ea313x_ndev),
+	.devices	= ea313x_ndev,
+	.timing		= &ea313x_nanddev_timing,
+	.support_16bit	= 0,
+};
+
+static u64 nand_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_nand_device = {
+	.name		= "lpc313x_nand",
+	.dev		= {
+		.dma_mask		= &nand_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+				.platform_data	= &ea313x_plat_nand,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_nand_resources),
+	.resource	= lpc313x_nand_resources,
+};
+#endif
+
+#if defined(CONFIG_SPI_LPC313X)
+static struct resource lpc313x_spi_resources[] = {
+	[0] = {
+		.start	= SPI_PHYS,
+		.end	= SPI_PHYS + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SPI,
+		.end	= IRQ_SPI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static void spi_set_cs0_state(int cs_num, int state)
+{
+	(void) cs_num;
+	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
+}
+
+static void spi_set_cs1_state(int cs_num, int state)
+{
+	(void) cs_num;
+printk("cs1 state %d\n", state);
+	lpc313x_gpio_set_value(GPIO_MUART_CTS_N, state);
+}
+
+static void spi_set_cs2_state(int cs_num, int state)
+{
+printk("cs2 state %d\n", state);
+	(void) cs_num;
+	lpc313x_gpio_set_value(GPIO_MUART_RTS_N, state);
+}
+
+struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
+{
+	/* SPI CS0 */
+	[0] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs0_state,
+	},
+	[1] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs1_state,
+	},
+	[2] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 1, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs2_state,
+	},
+};
+
+struct lpc313x_spi_cfg lpc313x_spidata =
+{
+	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
+	.spics_cfg		= lpc313x_stdspics_cfg,
+};
+
+static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
+static struct platform_device lpc313x_spi_device = {
+	.name		= "spi_lpc313x",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &lpc313x_spi_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data	= &lpc313x_spidata,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
+	.resource	= lpc313x_spi_resources,
+};
+
+/* spi_board_info.controller_data for SPI slave devices,
+ * copied to spi_device.platform_data ... mostly for dma tuning
+ */
+struct lpc313x_spi_chip {
+	u8 tx_threshold;
+	u8 rx_threshold;
+	u8 dma_burst_size;
+	u32 timeout;
+	u8 enable_loopback;
+	int gpio_cs;
+	void (*cs_control)(u32 command);
+};
+
+static struct ads7846_platform_data ea313x_ads7846_info = {
+	.model			= 7846,
+	.vref_delay_usecs	= 100,
+	.x_plate_ohms		= 419,
+	.y_plate_ohms		= 486,
+	.gpio_pendown		= GPIO_GPIO4,
+};
+
+static struct lpc313x_spi_chip ea313x_ads7846_chip = {
+	.gpio_cs	= GPIO_MUART_CTS_N,
+};
+
+/* If both SPIDEV and MTD data flash are enabled with the same chip select, only 1 will work */
+#if defined(CONFIG_SPI_SPIDEV)
+/* SPIDEV driver registration */
+static int __init lpc313x_spidev_register(void)
+{
+	struct spi_board_info info[] = {
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	}, {
+		.modalias	= "ads7846",
+		.max_speed_hz	= 1200000,
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.platform_data	= &ea313x_ads7846_info,
+		.controller_data= &ea313x_ads7846_chip,
+		.irq		= IRQ_PENDOWN,
+	}};
+	gpio_request(GPIO_MUART_CTS_N, "touchscreen CS");
+	gpio_direction_output(GPIO_MUART_CTS_N, 1);
+
+	return spi_register_board_info(info, 3);
+}
+arch_initcall(lpc313x_spidev_register);
+#endif
+
+#if defined(CONFIG_MTD_DATAFLASH)
+/* MTD Data FLASH driver registration */
+static int __init lpc313x_spimtd_register(void)
+{
+	struct spi_board_info info =
+	{
+		.modalias = "mtd_dataflash",
+		.max_speed_hz = 30000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	};
+
+	return spi_register_board_info(&info, 1);
+}
+arch_initcall(lpc313x_spimtd_register);
+#endif
+#endif
+
+static struct platform_device *devices[] __initdata = {
+	&lpc313x_mci_device,
+#if defined (CONFIG_MTD_NAND_LPC313X)
+	&lpc313x_nand_device,
+#endif
+#if defined(CONFIG_SPI_LPC313X)
+	&lpc313x_spi_device,
+#endif
+};
+
+static struct map_desc ea313x_io_desc[] __initdata = {
+	{
+		.virtual	= io_p2v(EXT_SRAM0_PHYS),
+		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
+		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_USB_PHYS),
+		.pfn		= __phys_to_pfn(IO_USB_PHYS),
+		.length		= IO_USB_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+static struct pca9532_platform_data ea313x_leds = {
+	.leds = {
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 1 */
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 2 */
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 3 */
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 4 */
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 5 */
+	{	.type = PCA9532_TYPE_GPIO }, /* OTP gpio */
+	{	.type = PCA9532_TYPE_GPIO }, /* V_BUS_EN gpio */
+	{	.type = PCA9532_TYPE_GPIO }, /* V_PWR_CTRL gpio */
+
+	{	.name = "ea313x:red:led5",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led6",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led7",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led8",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led9",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led10",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led11",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led12",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	},
+	.psc = { 0, 0 },
+	.pwm = { 0, 0 },
+	.gpio_base = 0x340,
+};
+
+static struct i2c_board_info ea313x_i2c_devices[] __initdata = {
+	{
+		I2C_BOARD_INFO("pca9532", 0x60),
+		.platform_data = &ea313x_leds,
+	},
+};
+
+#if defined(CONFIG_MACH_EA3152)
+static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
+	{
+		I2C_BOARD_INFO("lpc3152-psu", 0x0C),
+	},
+};
+#endif
+
+
+static void __init ea313x_init(void)
+{
+	lpc313x_init();
+	/* register i2cdevices */
+	lpc313x_register_i2c_devices();
+	
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	/* add DM9000 device */
+	ea_add_device_dm9000();
+	
+	ea_add_device_ssd1289();
+
+	i2c_register_board_info(0, ea313x_i2c_devices,
+		ARRAY_SIZE(ea313x_i2c_devices));
+
+#if defined(CONFIG_MACH_EA3152)
+	i2c_register_board_info(1, ea3152_i2c1_devices,
+		ARRAY_SIZE(ea3152_i2c1_devices));
+#endif
+}
+
+static void __init ea313x_map_io(void)
+{
+	lpc313x_map_io();
+	iotable_init(ea313x_io_desc, ARRAY_SIZE(ea313x_io_desc));
+}
+
+#if defined(CONFIG_MACH_EA3152)
+MACHINE_START(EA3152, "NXP EA3152")
+	/* Maintainer: Durgesh Pattamatta, NXP */
+	.boot_params	= 0x30000100,
+	.map_io		= ea313x_map_io,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= ea313x_init,
+MACHINE_END
+#endif
+
+#if defined(CONFIG_MACH_EA313X)
+MACHINE_START(EA313X, "NXP EA313X")
+	/* Maintainer: Durgesh Pattamatta, NXP */
+	.map_io		= ea313x_map_io,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= ea313x_init,
+MACHINE_END
+#endif
+
diff --git a/arch/arm/mach-lpc31xx/board-val3153.c b/arch/arm/mach-lpc31xx/board-val3153.c
new file mode 100644
index 0000000..addfb0f
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/board-val3153.c
@@ -0,0 +1,460 @@
+/*  arch/arm/mach-lpc313x/val3153.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  VAL3153 board init routines.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <asm/system.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <mach/gpio.h>
+#include <mach/board.h>
+
+/* mci platform functions */
+static int mci_init(u32 slot_id, irq_handler_t , void *);
+static int mci_get_ro(u32 slot_id);
+static int mci_get_cd(u32 slot_id);
+static int mci_get_ocr(u32 slot_id);
+static void mci_setpower(u32 slot_id, u32 volt);
+static void mci_exit(u32 slot_id);
+static void mci_select_slot(u32 slot_id);
+static int mci_get_bus_wd(u32 slot_id);
+
+
+static struct resource cs89x0_resources[] = {
+	[0] = {
+		.start	= EXT_SRAM1_PHYS + 0x10000,
+		.end	= EXT_SRAM1_PHYS + 0x10000 + 16,
+		.flags	= IORESOURCE_MEM,
+	} ,
+	[1] = {
+		.start	= IRQ_CS8900_ETH_INT,
+		.end	= IRQ_CS8900_ETH_INT,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cs89x0_device = {
+	.name		= "cs89x0",
+	.num_resources	= ARRAY_SIZE(cs89x0_resources),
+	.resource	= cs89x0_resources,
+};
+
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+#if defined (CONFIG_MTD_NAND_LPC313X)
+static struct resource lpc313x_nand_resources[] = {
+	[0] = {
+		.start  = IO_NAND_PHYS,
+		.end	= IO_NAND_PHYS + IO_NAND_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= IO_NAND_BUF_PHYS,
+		.end 	= IO_NAND_BUF_PHYS + IO_NAND_BUF_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start 	= IRQ_NAND_FLASH,
+		.end 	= IRQ_NAND_FLASH,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition val3153_nand0_partitions[] = {
+	{
+		.name	= "lpc313x-boot",
+		.offset	= 0,
+		.size	= (BLK_SIZE * 1)
+	},
+	{
+		.name	= "apex",
+		.offset	= (BLK_SIZE * 1),
+		.size	= (BLK_SIZE * 3)
+	},
+	{
+		.name	= "apex-prms",
+		.offset	= (BLK_SIZE * 4),
+		.size	= (BLK_SIZE * 2)
+	},
+	{
+		.name	= "lpc313x-kernel",
+		.offset	= (BLK_SIZE * 6),
+		.size	= (BLK_SIZE * 32) /* 4MB space */
+	},
+	{
+		.name	= "lpc313x-ramdsk",
+		.offset	= (BLK_SIZE * 38),
+		.size	= (BLK_SIZE * 128) /* 16MB space */
+	},
+	{
+		.name	= "lpc313x-rootfs",
+		.offset	= (BLK_SIZE * 166),
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct lpc313x_nand_timing val3153_nanddev_timing = {
+	.ns_trsd	= 80, // FIXME - need to optimize timings
+	.ns_tals	= 80,
+	.ns_talh	= 80,
+	.ns_tcls	= 80,
+	.ns_tclh	= 80,
+	.ns_tdrd	= 80,
+	.ns_tebidel	= 80,
+	.ns_tch		= 80,
+	.ns_tcs		= 80,
+	.ns_treh	= 80,
+	.ns_trp		= 80,
+	.ns_trw		= 80,
+	.ns_twp		= 80
+};
+
+static struct lpc313x_nand_dev_info val3153_ndev[] = {
+	{
+		.name		= "nand0",
+		.nr_partitions	= ARRAY_SIZE(val3153_nand0_partitions),
+		.partitions	= val3153_nand0_partitions
+	}
+};
+
+static struct lpc313x_nand_cfg val3153_plat_nand = {
+	.nr_devices	= ARRAY_SIZE(val3153_ndev),
+	.devices	= val3153_ndev,
+	.timing		= &val3153_nanddev_timing,
+	.support_16bit	= 0,
+};
+
+static u64 nand_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_nand_device = {
+	.name		= "lpc313x_nand",
+	.dev		= {
+		.dma_mask		= &nand_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+				.platform_data	= &val3153_plat_nand,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_nand_resources),
+	.resource	= lpc313x_nand_resources,
+};
+#endif
+
+#if defined(CONFIG_SPI_LPC313X)
+static struct resource lpc313x_spi_resources[] = {
+	[0] = {
+		.start	= SPI_PHYS,
+		.end	= SPI_PHYS + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SPI,
+		.end	= IRQ_SPI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static void spi_set_cs_state(int cs_num, int state)
+{
+	/* Only CS0 is supported, so no checks are needed */
+	(void) cs_num;
+
+	/* Set GPO state for CS0 */
+	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
+}
+
+struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
+{
+	/* SPI CS0 */
+	[0] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs_state,
+	},
+};
+
+struct lpc313x_spi_cfg lpc313x_spidata =
+{
+	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
+	.spics_cfg		= lpc313x_stdspics_cfg,
+};
+
+static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
+static struct platform_device lpc313x_spi_device = {
+	.name		= "spi_lpc313x",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &lpc313x_spi_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data	= &lpc313x_spidata,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
+	.resource	= lpc313x_spi_resources,
+};
+
+/* If both SPIDEV and MTD data flash are enabled with the same chip select, only 1 will work */
+#if defined(CONFIG_SPI_SPIDEV)
+/* SPIDEV driver registration */
+static int __init lpc313x_spidev_register(void)
+{
+	struct spi_board_info info =
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	};
+
+	return spi_register_board_info(&info, 1);
+}
+arch_initcall(lpc313x_spidev_register);
+#endif
+#endif
+
+
+static struct lpc313x_mci_board val3153_mci_platform_data = {
+	.num_slots		= 2,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.select_slot		= mci_select_slot,
+	.exit			= mci_exit,
+};
+
+static u64 mci_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_mci_device = {
+	.name		= "lpc313x_mmc",
+	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
+	.dev		= {
+		.dma_mask		= &mci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &val3153_mci_platform_data,
+	},
+	.resource	= lpc313x_mci_resources,
+};
+
+
+
+static struct platform_device *devices[] __initdata = {
+	&cs89x0_device,
+	&lpc313x_mci_device,
+#if defined (CONFIG_MTD_NAND_LPC313X)
+	&lpc313x_nand_device,
+#endif
+#if defined(CONFIG_SPI_LPC313X)
+	&lpc313x_spi_device,
+#endif
+
+};
+
+static struct map_desc val3153_io_desc[] __initdata = {
+	{
+		.virtual	= io_p2v(EXT_SRAM0_PHYS),
+		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
+		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_NAND_PHYS),
+		.pfn		= __phys_to_pfn(IO_NAND_PHYS),
+		.length		= IO_NAND_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
+		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
+		.length		= IO_NAND_BUF_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_USB_PHYS),
+		.pfn		= __phys_to_pfn(IO_USB_PHYS),
+		.length		= IO_USB_SIZE,
+		.type		= MT_DEVICE
+	},
+
+};
+
+static struct lpc313x_mci_irq_data irq_data[2] = {
+	{
+		.irq = IRQ_SDMMC_CD0,
+	},
+	{
+		.irq = IRQ_SDMMC_CD1,
+	},
+};
+
+static irqreturn_t val313x_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+	u32 slot_id = (pdata->irq == irq_data[0].irq)?0:1;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(slot_id)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(slot_id)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	/* set slot_select, cd and wp pins as GPIO pins */
+	gpio_direction_input(GPIO_GPIO12);
+	gpio_direction_input(GPIO_GPIO13);
+	gpio_direction_input(GPIO_GPIO14);
+	gpio_direction_input(GPIO_GPIO15);
+	gpio_direction_input(GPIO_MI2STX_DATA0);
+
+	/* set card detect irq info */
+	irq_data[slot_id].data = data;
+	irq_data[slot_id].irq_hdlr = irqhdlr;
+	set_irq_type(irq_data[slot_id].irq, level);
+	ret = request_irq(irq_data[slot_id].irq,
+			val313x_mci_detect_interrupt,
+			level,
+			(slot_id)?"mmc-cd1":"mmc-cd0",
+			&irq_data[slot_id]);
+
+	/****temporary for PM testing */
+	enable_irq_wake(irq_data[0].irq);
+	enable_irq_wake(irq_data[1].irq);
+	return ret;
+
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return gpio_get_value((slot_id)?GPIO_GPIO15:GPIO_GPIO14);
+}
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value((slot_id)?GPIO_GPIO13:GPIO_GPIO12);
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	/* power is always on for both slots nothing to do*/
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data[slot_id].irq, &irq_data[slot_id]);
+}
+
+static void mci_select_slot(u32 slot_id)
+{
+	/* select slot 1 for anything other than 0*/
+	gpio_set_value(GPIO_MI2STX_DATA0, (slot_id)?1:0);
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+void lpc313x_vbus_power(int enable)
+{
+	printk(KERN_INFO "%s VBUS power!!!\n", (enable)?"Enabling":"Disabling" );
+	if (enable) 
+		gpio_set_value(GPIO_GPIO18, 0);
+	else
+		gpio_set_value(GPIO_GPIO18, 1);
+
+	udelay(500);
+	udelay(500);
+}
+
+
+static void __init val3153_init(void)
+{
+	lpc313x_init();
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static void __init val3153_map_io(void)
+{
+	lpc313x_map_io();
+	iotable_init(val3153_io_desc, ARRAY_SIZE(val3153_io_desc));
+}
+
+MACHINE_START(VAL3153, "NXP VAL3153")
+	/* Maintainer: Durgesh Pattamatta, NXP */
+	.phys_io	= IO_APB01_PHYS,
+	.io_pg_offst	= (io_p2v(IO_APB01_PHYS) >> 18) & 0xfffc,
+	.boot_params	= 0x30000100,
+	.map_io		= val3153_map_io,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= val3153_init,
+MACHINE_END
diff --git a/arch/arm/mach-lpc31xx/borad-val3154.c b/arch/arm/mach-lpc31xx/borad-val3154.c
new file mode 100644
index 0000000..4cc59d0
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/borad-val3154.c
@@ -0,0 +1,304 @@
+/*  arch/arm/mach-lpc313x/val3154.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  val3154 board init routines.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <mach/gpio.h>
+#include <mach/i2c.h>
+#include <mach/board.h>
+
+/* mci platform functions */
+static int mci_init(u32 slot_id, irq_handler_t , void *);
+static int mci_get_ro(u32 slot_id);
+static int mci_get_cd(u32 slot_id);
+static int mci_get_ocr(u32 slot_id);
+static void mci_setpower(u32 slot_id, u32 volt);
+static void mci_exit(u32 slot_id);
+static int mci_get_bus_wd(u32 slot_id);
+
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+static struct lpc313x_mci_board val3154_mci_platform_data = {
+	.num_slots		= 1,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.exit			= mci_exit,
+};
+
+static u64 mci_dmamask = 0xffffffffUL;
+static struct platform_device	lpc313x_mci_device = {
+	.name		= "lpc313x_mmc",
+	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
+	.dev		= {
+		.dma_mask		= &mci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &val3154_mci_platform_data,
+	},
+	.resource	= lpc313x_mci_resources,
+};
+
+
+#if defined(CONFIG_SPI_LPC313X)
+static struct resource lpc313x_spi_resources[] = {
+	[0] = {
+		.start	= SPI_PHYS,
+		.end	= SPI_PHYS + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SPI,
+		.end	= IRQ_SPI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static void spi_set_cs_state(int cs_num, int state)
+{
+	/* Only CS0 is supported, so no checks are needed */
+	(void) cs_num;
+
+	/* Set GPO state for CS0 */
+	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
+}
+
+struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
+{
+	/* SPI CS0 */
+	[0] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs_state,
+	},
+};
+
+struct lpc313x_spi_cfg lpc313x_spidata =
+{
+	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
+	.spics_cfg		= lpc313x_stdspics_cfg,
+};
+
+static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
+static struct platform_device lpc313x_spi_device = {
+	.name		= "spi_lpc313x",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &lpc313x_spi_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data	= &lpc313x_spidata,
+	},
+	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
+	.resource	= lpc313x_spi_resources,
+};
+
+/* If both SPIDEV and MTD data flash are enabled, only 1 will work */
+#if defined(CONFIG_SPI_SPIDEV)
+/* SPIDEV driver registration */
+static int __init lpc313x_spidev_register(void)
+{
+	struct spi_board_info info =
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	};
+
+	return spi_register_board_info(&info, 1);
+}
+arch_initcall(lpc313x_spidev_register);
+#endif
+#endif
+
+
+static struct platform_device *devices[] __initdata = {
+	&lpc313x_mci_device,
+#if defined(CONFIG_SPI_LPC313X)
+	&lpc313x_spi_device,
+#endif
+};
+
+static struct map_desc val3154_io_desc[] __initdata = {
+	{
+		.virtual	= io_p2v(EXT_SRAM0_PHYS),
+		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
+		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+static struct i2c_board_info val3154_i2c_devices[] __initdata = {
+	{
+		I2C_BOARD_INFO("lpc3152-psu", 0x0C),
+	},
+};
+
+static struct lpc313x_mci_irq_data irq_data = {
+	.irq = IRQ_SDMMC_CD,
+};
+
+static irqreturn_t val3154_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
+
+	/* set slot_select, cd and wp pins as GPIO pins */
+	gpio_direction_input(GPIO_MI2STX_BCK0);
+
+	/* set card detect irq info */
+	irq_data.data = data;
+	irq_data.irq_hdlr = irqhdlr;
+	set_irq_type(irq_data.irq, level);
+	ret = request_irq(irq_data.irq,
+			val3154_mci_detect_interrupt,
+			level,
+			"mmc-cd", 
+			&irq_data);
+	return ret;
+
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return 0;
+}
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value(GPIO_MI2STX_BCK0);
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	gpio_set_value(GPIO_MI2STX_DATA0, 0);
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data.irq, &irq_data);
+}
+
+void lpc313x_vbus_power(int enable)
+{
+	if (enable) 
+		gpio_set_value(GPIO_I2SRX_DATA0, 1);
+	else
+		gpio_set_value(GPIO_I2SRX_DATA0, 0);
+}
+
+static void __init val3154_init(void)
+{
+	lpc313x_init();
+	/* register i2cdevices */
+	lpc313x_register_i2c_devices();
+	
+	i2c_register_board_info(1, val3154_i2c_devices,
+		ARRAY_SIZE(val3154_i2c_devices));
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static void __init val3154_map_io(void)
+{
+	lpc313x_map_io();
+	iotable_init(val3154_io_desc, ARRAY_SIZE(val3154_io_desc));
+}
+
+
+MACHINE_START(VAL3154, "NXP VAL3154")
+	/* Maintainer: Durgesh Pattamatta, NXP */
+	.phys_io	= IO_APB01_PHYS,
+	.io_pg_offst	= (io_p2v(IO_APB01_PHYS) >> 18) & 0xfffc,
+	.boot_params	= 0x30000100,
+	.map_io		= val3154_map_io,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= val3154_init,
+MACHINE_END
diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
new file mode 100644
index 0000000..36d62f1
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -0,0 +1,970 @@
+/*  arch/arm/mach-lpc313x/clock.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  CGU driver for LPC313x & LPC315x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/cpufreq.h>
+#include <linux/err.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <mach/hardware.h>
+
+#include <mach/clock.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+
+/***********************************************************************
+* CGU driver package data
+***********************************************************************/
+static u32 g_clkin_freq[CGU_FIN_SELECT_MAX];
+
+/***********************************************************************
+* CGU driver private functions
+**********************************************************************/
+/***********************************************************************
+* calculate int(log2(i))+1
+*
+* Processing:
+*     This algorithm is used to calculate the above said formula.
+*     This is used to calculate the madd and msub width in frac div
+*     registers.Reasonably fast.
+**********************************************************************/
+static u32 cgu_fdiv_num_bits(unsigned int i)
+{
+	u32 x = 0, y = 16;
+
+	for (; y > 0; y = y >> 1) {
+		if (i >> y) {
+			x += y;
+			i = i >> y;
+		}
+	}
+
+	if (i)
+		x++;
+
+	return x;
+}
+
+static inline u32 f_mult_m_div_n(u32 f_in, u32 m, u32 n)
+{
+	u32 temp;
+	union {
+		unsigned long word[2];
+		unsigned long long longword;
+	} work;
+
+	/* extract low 16 bits ,multiply */
+	work.word[0]=(f_in & 0xFFFF) * m;
+	/* extract high 16 bits ,multiply */
+	work.word[1]=(f_in >> 16)    * m;
+	/* low half of base_clk[1] add to high half of base_clk[0] */
+	temp = (work.word[1] &0xFFFF) << 16;
+	work.word[0] += temp;
+	/* put high half of base_clk[1] in low half */
+	work.word[1] >>= 16; 
+
+	/* detect and correct  overflow from adding bottom 16 bits of high word to top of low word */
+	if (work.word[0] < temp) {
+		work.word[1] ++;
+	}
+	/* do division ignoring remainder */
+	do_div(work.longword, n);
+	return work.word[0];
+}
+
+/***********************************************************************
+*     Decode m value from mdec reg value.
+**********************************************************************/
+static unsigned int pl550_m(int x)
+{
+	int m = 1;
+
+	if ((x<0) || (x>0x40000))
+		return 0;
+	if (x == 0x18003)
+		return 1;
+	if (x == 0x10003)
+		return 2;
+
+	while (x!=0x4000) {
+		int new = (x & 1)^((x >> 1) & 1);
+		x = (x >> 1) | (new << 14);
+		m++;
+		if (m > 0x8000) 
+			return 0;
+	}
+	return m+1;
+}
+
+/***********************************************************************
+*     Decode n value from ndec reg value.
+**********************************************************************/
+static unsigned int pl550_n( int x)
+{
+	int n = 1;
+
+	if ((x<0) || (x>0x400)) 
+		return 0;
+	if ( x == 0x302)
+		return 1;
+	if ( x == 0x202)
+		return 2;
+
+	while (x != 0x80) {
+		int new = (((x&1) ^ ((x>>2)&1)) ^ ((x>>3)&1)) ^ ((x>>4)&1);
+		x = (x>>1) | (new<<7);
+		n++;
+		if (n > 255)
+			return 0;
+	}
+
+	return n+1;
+}
+
+/***********************************************************************
+*     Decode p value from pdec reg value.
+**********************************************************************/
+static unsigned int pl550_p(int x)
+{
+	int p = 1;
+
+	if ((x<0) || (x>0x62))
+		return 0;
+	if (x==0x62)
+		return 1;
+	if (x==0x42)
+		return 2;
+
+	while (x!=0x10) {
+		int new = (x&1)^((x>>2)&1);
+		x = (x>>1)|(new<<4);
+		p++;
+		if (p>31)
+			return 0;
+	}
+
+	return p+1;
+}
+
+/***********************************************************************
+*     Finds ESR index corresponding to the requested clock Id.
+**********************************************************************/
+u32 cgu_clkid2esrid(CGU_CLOCK_ID_T clkid)
+{
+	u32 esrIndex = (u32)clkid;
+
+	switch (clkid)
+	{
+	case CGU_SB_I2SRX_BCK0_ID:
+	case CGU_SB_I2SRX_BCK1_ID:
+	case CGU_SB_SYSCLK_O_ID:
+		/* invalid esr index. No ESR register for these clocks */
+		esrIndex = CGU_INVALID_ID;
+		break;
+
+	case CGU_SB_SPI_CLK_ID:
+	case CGU_SB_SPI_CLK_GATED_ID:
+		esrIndex = esrIndex - 2;
+		break;
+	default:
+		/* do nothing */
+		break;
+	}
+
+	return esrIndex;
+}
+/***********************************************************************
+*     Finds BCR index corresponding to the requested domain Id.
+**********************************************************************/
+u32 cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid)
+{
+	u32 bcridx = CGU_INVALID_ID;
+	switch (domainid)
+	{
+	case CGU_SB_SYS_BASE_ID:
+	case CGU_SB_AHB0_APB0_BASE_ID:
+	case CGU_SB_AHB0_APB1_BASE_ID:
+	case CGU_SB_AHB0_APB2_BASE_ID:
+		bcridx = domainid;
+		break;
+	case CGU_SB_CLK1024FS_BASE_ID:
+		bcridx = CGU_SB_NR_BCR - 1;
+		break;
+	default:
+		bcridx = CGU_INVALID_ID;
+		break;
+	}
+	return bcridx;
+}
+/***********************************************************************
+*     Finds domain index and fractional divider index for the requested
+*	   clock.
+**********************************************************************/
+void cgu_ClkId2DomainId(CGU_CLOCK_ID_T clkid, CGU_DOMAIN_ID_T* pDomainId,
+                        u32* pSubdomainId)
+{
+	u32 esrIndex, esrReg;
+	u32 fracdiv_base = CGU_INVALID_ID;
+
+	/*    1. Get the domain ID */
+
+	if (clkid <= CGU_SYS_LAST) {
+		*pDomainId = CGU_SB_SYS_BASE_ID;
+		fracdiv_base = CGU_SB_BASE0_FDIV_LOW_ID;
+
+	} else if (clkid <= CGU_AHB0APB0_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB0_BASE_ID;
+		fracdiv_base = CGU_SB_BASE1_FDIV_LOW_ID;
+
+	} else 	if (clkid <= CGU_AHB0APB1_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB1_BASE_ID;
+		fracdiv_base = CGU_SB_BASE2_FDIV_LOW_ID;
+
+	} else 	if (clkid <= CGU_AHB0APB2_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB2_BASE_ID;
+		fracdiv_base = CGU_SB_BASE3_FDIV_LOW_ID;
+
+	} else 	if (clkid <= CGU_AHB0APB3_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB3_BASE_ID;
+		fracdiv_base = CGU_SB_BASE4_FDIV_LOW_ID;
+
+	} else 	if (clkid == CGU_PCM_LAST) {
+		*pDomainId = CGU_SB_IPINT_BASE_ID;
+		fracdiv_base = CGU_SB_BASE5_FDIV_LOW_ID;
+
+	} else 	if (clkid == CGU_UART_LAST) {
+		*pDomainId = CGU_SB_UARTCLK_BASE_ID;
+		fracdiv_base = CGU_SB_BASE6_FDIV_LOW_ID;
+
+	} else 	if (clkid <= CGU_CLK1024FS_LAST) {
+		*pDomainId = CGU_SB_CLK1024FS_BASE_ID;
+		fracdiv_base = CGU_SB_BASE7_FDIV_LOW_ID;
+
+	} else 	if (clkid == CGU_I2SRX_BCK0_LAST) {
+		*pDomainId = CGU_SB_I2SRX_BCK0_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+
+	} else 	if (clkid == CGU_I2SRX_BCK1_LAST) {
+		*pDomainId = CGU_SB_I2SRX_BCK1_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+
+	} else 	if (clkid <= CGU_SPI_LAST) {
+		*pDomainId = CGU_SB_SPI_CLK_BASE_ID;
+		fracdiv_base = CGU_SB_BASE10_FDIV_LOW_ID;
+
+	} else {
+		*pDomainId = CGU_SB_SYSCLK_O_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+	}
+
+	*pSubdomainId = CGU_INVALID_ID;
+
+	/* read the clocks ESR to get the fractional divider */
+	esrIndex = cgu_clkid2esrid(clkid);
+
+	if (CGU_INVALID_ID != esrIndex) {
+		/* read the clocks ESR to get the fractional divider */
+		esrReg = CGU_SB->clk_esr[esrIndex];
+
+		/* A clock may not be connected to any sub-domain and it might be
+		connected directly to domain. This is also a valid combination. So,
+		errror should not be returned */
+		if (esrReg & CGU_SB_ESR_ENABLE) {
+			*pSubdomainId = CGU_SB_ESR_SEL_GET(esrReg) + fracdiv_base;
+		}
+	}
+
+}
+
+/***********************************************************************
+* Configure the selected fractional divider
+*********************************************************************/
+/* frac divider config function */
+u32 cgu_fdiv_config(u32 fdId, CGU_FDIV_SETUP_T fdivCfg, u32 enable)
+{
+	u32 conf, maddw, msubw, maxw, fdWidth;
+	int madd, msub;
+
+	/* calculating program values to see if they fit in fractional divider*/
+	madd = fdivCfg.m - fdivCfg.n;
+	msub = -fdivCfg.n;
+
+	/* Find required bit width of madd & msub:*/
+	maddw = cgu_fdiv_num_bits((u32)madd);
+	msubw = cgu_fdiv_num_bits((u32)fdivCfg.n);
+	maxw = (maddw > msubw) ? maddw : msubw;
+	fdWidth = CGU_SB_BASE0_FDIV0_W;
+
+	if (fdId == CGU_SB_BASE7_FDIV_LOW_ID) {
+		/* for Frac divider 17 the bit width is 13 */
+		fdWidth = CGU_SB_BASE7_FDIV0_W;
+	}
+
+	/* Calculate Configure parameter:*/
+	conf = ((((1 << fdWidth) - 1) &
+		(msub << (fdWidth - maxw))) <<
+		(fdWidth + CGU_SB_FDC_MADD_POS)) |
+		(madd << (fdWidth - maxw + CGU_SB_FDC_MADD_POS));
+
+	/* check whther 50% duty cycle is needed for this divider*/
+	if (fdivCfg.stretch)
+		conf |= CGU_SB_FDC_STRETCH;
+	/* check whehter to enable the divider immediately */
+	if (enable)
+		conf |= CGU_SB_FDC_RUN;
+
+	/* finally configure the divider*/
+	CGU_SB->base_fdc[fdId] = conf;
+
+	return conf;
+}
+
+/***********************************************************************
+* CGU driver public functions
+***********************************************************************/
+
+
+
+/***********************************************************************
+* Get frequency of requested base domain clock.
+**********************************************************************/
+u32 cgu_get_base_freq(CGU_DOMAIN_ID_T baseid)
+{
+	/* get base frequency for the domain */
+	return g_clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[baseid])];
+}
+
+/***********************************************************************
+* Set frequency of requested base domain.
+**********************************************************************/
+void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel)
+{
+	u32 baseSCR;
+
+	/* Switch configuration register*/
+	baseSCR = CGU_SB->base_scr[baseid] & ~CGU_SB_SCR_FS_MASK;
+	/* If fs1 is currently enabled set refId to fs2 and enable fs2*/
+	if (CGU_SB->base_ssr[baseid] & CGU_SB_SCR_EN1) {
+		/* check if the selcted frequency is same as requested. If not switch.*/
+		if (CGU_SB->base_fs1[baseid] != fin_sel) {
+			CGU_SB->base_fs2[baseid] = fin_sel;
+
+			/* Don't touch stop bit in SCR register*/
+			CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN2;
+		}
+	} else {
+		/* check if the selcted frequency is same as requested. If not switch.*/
+		if (CGU_SB->base_fs2[baseid] != fin_sel) {
+			CGU_SB->base_fs1[baseid] = fin_sel;
+
+			/* Don't touch stop bit in SCR register*/
+			CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN1;
+		}
+	}
+}
+
+/***********************************************************************
+* Configure the selected HPLL
+* CGU_FIN_SELECT_HPPLL0 : Is used as Audio PLL
+* CGU_FIN_SELECT_HPPLL1 : Is used as System PLL
+**********************************************************************/
+void cgu_hpll_config(CGU_HPLL_ID_T pllid, CGU_HPLL_SETUP_T* pllsetup)
+{
+	CGU_HP_CFG_REGS* hppll;
+	u32 switched_domains = 0;
+	CGU_DOMAIN_ID_T domainId;
+
+	/**********************************************************
+	* switch domains connected to HPLL to FFAST automatically
+	***********************************************************/
+	for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++) {
+		if (CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]) ==
+			(CGU_FIN_SELECT_HPPLL0 + pllid)) {
+			/* switch reference clock in to FFAST */
+			cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+			/* store the domain id to switch back to HPLL */
+			switched_domains |= _BIT(domainId);
+		}
+	}
+
+	/* get PLL regs */
+	hppll = &CGU_CFG->hp[pllid];
+
+	/* disable clock, disable skew enable, power down pll,
+	* (dis/en)able post divider, (dis/en)able pre-divider,
+	* disable free running mode, disable bandsel,
+	* enable up limmiter, disable bypass
+	*/
+	hppll->mode = CGU_HPLL_MODE_PD;
+
+	/* check if pllsetup is valid if not just switch off pll */
+	if (pllsetup != NULL) {
+
+		/* Select fin */
+		hppll->fin_select = pllsetup->fin_select;
+
+		/* M divider */
+		hppll->mdec = pllsetup->mdec & CGU_HPLL_MDEC_MASK;
+
+		/* N divider */
+		hppll->ndec = pllsetup->ndec & CGU_HPLL_NDEC_MSK;
+
+		/* P divider */
+		hppll->pdec = pllsetup->pdec & CGU_HPLL_PDEC_MSK;
+
+		/* Set bandwidth */
+		hppll->selr = pllsetup->selr;
+		hppll->seli = pllsetup->seli;
+		hppll->selp = pllsetup->selp;
+
+		/* Power up pll */
+		hppll->mode = (pllsetup->mode & ~CGU_HPLL_MODE_PD) | CGU_HPLL_MODE_CLKEN;
+
+		/* store the estimated freq in driver data for future clk calcs */
+		g_clkin_freq[CGU_FIN_SELECT_HPPLL0 + pllid] = pllsetup->freq;
+
+		/* wait for PLL to lock */
+		while ((hppll->status & CGU_HPLL_STATUS_LOCK) == 0);
+
+		/**********************************************************
+		* switch domains back to HPLL
+		***********************************************************/
+		for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++) {
+			if (switched_domains & _BIT(domainId)) {
+				/* switch reference clock in to HPLL */
+				cgu_set_base_freq(domainId, CGU_FIN_SELECT_HPPLL0 + pllid);
+			}
+		}
+	}
+
+}
+
+/***********************************************************************
+* Set external enable feature for the requested clock
+**********************************************************************/
+void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable)
+{
+	switch (clkid)
+	{
+	case CGU_SB_OTP_PCLK_ID:
+	case CGU_SB_PCM_APB_PCLK_ID:
+	case CGU_SB_EVENT_ROUTER_PCLK_ID:
+	case CGU_SB_ADC_PCLK_ID:
+	case CGU_SB_IOCONF_PCLK_ID:
+	case CGU_SB_CGU_PCLK_ID:
+	case CGU_SB_SYSCREG_PCLK_ID:
+	case CGU_SB_DMA_CLK_GATED_ID:
+	case CGU_SB_SPI_PCLK_GATED_ID:
+	case CGU_SB_SPI_CLK_GATED_ID:
+	case CGU_SB_PCM_CLK_IP_ID:
+	case CGU_SB_PWM_PCLK_REGS_ID:
+		if (enable)
+			CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_EXTEN_EN;
+		else
+			CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+		break;
+		/* force disable for the following clocks */
+	case CGU_SB_I2C0_PCLK_ID:
+	case CGU_SB_I2C1_PCLK_ID:
+	case CGU_SB_WDOG_PCLK_ID:
+	case CGU_SB_UART_APB_CLK_ID:
+	case CGU_SB_LCD_PCLK_ID:
+		CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+		break;
+	default:
+		break;
+	}
+}
+
+/***********************************************************************
+*
+* Function: cgu_get_clk_freq
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+u32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid)
+{
+	u32 freq = 0;
+	CGU_DOMAIN_ID_T domainId;
+	u32 subDomainId;
+	int n, m;
+	u32 fdcVal;
+
+	/* get domain and frac div info for the clock */
+	cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+
+	/* get base frequency for the domain */
+	freq = g_clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId])];
+
+	/* direct connection  has no fraction divider*/
+	if (subDomainId == CGU_INVALID_ID)
+		return freq;
+
+	/* read frac div control register value */
+	fdcVal = CGU_SB->base_fdc[subDomainId];
+
+	if (fdcVal & CGU_SB_FDC_RUN)  { /* Is the fracdiv enabled ?*/
+		/* Yes, so reverse calculation of madd and msub */
+		int msub, madd;
+
+		if (subDomainId != CGU_SB_BASE7_FDIV_LOW_ID) {
+			msub = CGU_SB_FDC_MSUB_GET(fdcVal);
+			madd = CGU_SB_FDC_MADD_GET(fdcVal);
+		} else {
+			msub = CGU_SB_FDC17_MSUB_GET(fdcVal);
+			madd = CGU_SB_FDC17_MADD_GET(fdcVal);
+		}
+
+		/* remove trailing zeros */
+		while (!(msub & 1)  && !(madd & 1)) {
+			madd = madd >> 1;
+			msub = msub >> 1;
+		}
+		/* compute m and n values */
+		n = - msub;
+		m = madd + n;
+		/* check m and n are non-zero values */
+		if ((n == 0) || (m == 0)) {
+			return 0;
+		}
+		/* calculate the frequency based on m and n values */
+		freq = (freq * n) / m ;
+	}
+	/* else There is no fractional divider in the clocks path */
+
+	//printk(KERN_INFO "CGU: Get clock id:%d freq:%d\n", clkid, freq);
+
+	return  freq;
+}
+
+/***********************************************************************
+* Get frequency of requested clock.
+**********************************************************************/
+void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg)
+{
+	CGU_DOMAIN_ID_T domainId;
+	u32 subDomainId, base_freq, bcrId;
+
+	/* get domain and frac div info for the clock */
+	cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+
+	/* direct connection  has no fraction divider*/
+	if (subDomainId != CGU_INVALID_ID) {
+		/* store base freq */
+		base_freq = CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]);
+		/* switch domain to FFAST */
+		cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+		/* check if the domain has a BCR*/
+		bcrId = cgu_DomainId2bcrid(domainId);
+		/* disable all BCRs */
+		if (bcrId != CGU_INVALID_ID) {
+			CGU_SB->base_bcr[bcrId] = 0;
+		}
+		/* change fractional divider */
+		cgu_fdiv_config(subDomainId, fdiv_cfg, 1);
+		/* enable BCRs */
+		if (bcrId != CGU_INVALID_ID) {
+			CGU_SB->base_bcr[bcrId] = CGU_SB_BCR_FD_RUN;
+		}
+		/* switch domain to original base frequency */
+		cgu_set_base_freq(domainId, base_freq);
+	}
+}
+
+/***********************************************************************
+* Get frequency of requested PLL clock.
+**********************************************************************/
+u32 cgu_get_pll_freq(CGU_HPLL_ID_T pll_id, u32 infreq)
+{
+	u32 mdec;     /* 17 bits */
+	u32 ndec;     /* 10 bits */
+	u32 pdec;     /*  7 bits */
+	u32 mode;
+	u32 M = 0;
+	u32 N = 0;
+	u32 P = 0;
+	u32 ofreq = 0;
+
+
+	mdec = CGU_CFG->hp[pll_id].mdec;  /* dec val feedback divider */
+	ndec = CGU_CFG->hp[pll_id].ndec;  /* dec val pre-divider */
+	pdec = CGU_CFG->hp[pll_id].pdec;  /* dec val post-divider */
+	mode = CGU_CFG->hp[pll_id].mode;
+
+	/* calculate clock setting */
+	M = pl550_m( mdec);
+	N = pl550_n( ndec);
+	P = pl550_p( pdec);
+
+	//printk(KERN_INFO "%s decode pll%d m/n/p values\n  (0x%x,0x%x,0x%x decoded to 0x%x,0x%x,0x%x)\n",
+	//	__FUNCTION__, pll_id, mdec, ndec, pdec, M, N, P);
+
+	switch (mode) {
+
+	case 0x01: /* 1d */
+		if ((M==0)||(N==0)||(P==0)) {
+			return 0;
+		}
+
+		ofreq = f_mult_m_div_n(infreq,M,N*P); // (P * N)/M = out
+		break;
+
+	case 0x09: /* 1c */
+		if ((M == 0) || (N == 0)) {
+			printk(KERN_WARNING "%s: decode pll bad m/n values\n",__FUNCTION__);
+			return -1;
+		}
+
+		ofreq = f_mult_m_div_n(infreq,2*M,N);// N/(2*M)  =out
+		break;
+
+	case 0x11: /* 1b */
+		if ((M == 0)||(P == 0)) {
+			printk(KERN_WARNING "%s: decode pll bad m/p values\n",__FUNCTION__);
+			return -1;
+		}
+
+		ofreq = f_mult_m_div_n(infreq,M,P); // P/M  =out
+		break;
+
+	case 0x19: /* 1a */
+		if (M==0) {
+			printk(KERN_WARNING "%s: decode pll bad m value\n",__FUNCTION__);
+			return -1;
+		}
+
+		ofreq = 2 * infreq * M;		//  1/(2*M) =out
+		break;
+
+
+
+	default:
+		if(mode & 4) /* if this bit is set then the PLL is powered down */
+			return 0;
+		else {
+			printk(KERN_WARNING "%s: decode pll unknown mode %x\n",__FUNCTION__, mode);
+			return -1;
+		}
+	}
+
+	return ofreq;
+}
+
+#if defined (CONFIG_DEBUG_FS)
+/*
+ * The debugfs stuff below is mostly optimized away when
+ * CONFIG_DEBUG_FS is not set.
+ */
+static int lpc313x_cgu_clocks_show(struct seq_file *s, void *v)
+{
+	u32 clk_id = CGU_SYS_FIRST;
+	u32 end_id = (CGU_SYSCLK_O_LAST + 1);
+	char* str[2] = { "OFF", " ON"}; 
+
+	while (clk_id < end_id) {
+		seq_printf (s, "clock[%02d] %s(PSR)/%s(PCR) : %d\r\n", clk_id, 
+			str[(CGU_SB->clk_psr[clk_id] & 0x1)], 
+			str[(CGU_SB->clk_pcr[clk_id] & 0x1)], 
+			cgu_get_clk_freq(clk_id));
+		clk_id++;
+	}
+
+	return 0;
+}
+
+static int lpc313x_cgu_clocks_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lpc313x_cgu_clocks_show, inode->i_private);
+}
+
+static const struct file_operations lpc313x_cgu_clocks_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lpc313x_cgu_clocks_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void lpc313x_cgu_init_debugfs(void)
+{
+	struct dentry		*node;
+
+	node = debugfs_create_file("cgu_clks", S_IRUSR, NULL, NULL,
+			&lpc313x_cgu_clocks_fops);
+	if (IS_ERR(node))
+		printk("cgu_init: failed to initialize debugfs for CGU\n");
+
+	return;
+}
+#else
+static void lpc313x_cgu_init_debugfs(void) {}
+#endif
+/***********************************************************************
+* Initialize CGU data structure with PLL frequency passed by the boot 
+* loader.
+**********************************************************************/
+int __init cgu_init(char *str)
+{
+	int i, j;
+	u32 flags;
+	/* disable all non-essential clocks, enabel main clocks and wakeup
+	 * enables.
+	 */
+	for(i = 0; i < CGU_SB_NR_CLK; i++) {
+
+		if (i < 32) {
+			flags = CGU_WKE_CLKS_0_31;
+			j = 0;
+		} else	if (i < 64) {
+			flags = CGU_WKE_CLKS_32_63;
+			j = 32;
+		} else if (i < 96) {
+			flags = CGU_WKE_CLKS_64_92;
+			j = 64;
+		}
+
+		if (flags & _BIT((i - j))) {
+			CGU_SB->clk_pcr[i] |= CGU_SB_PCR_WAKE_EN |
+					CGU_SB_PCR_RUN | CGU_SB_PCR_AUTO;
+		} else {
+			CGU_SB->clk_pcr[i] &= ~(CGU_SB_PCR_WAKE_EN | CGU_SB_PCR_RUN);
+		}
+	}
+	g_clkin_freq[0] = FFAST_CLOCK;
+	g_clkin_freq[1] = 0;
+	g_clkin_freq[2] = 0;
+	g_clkin_freq[3] = 0;
+	g_clkin_freq[4] = 0;
+	g_clkin_freq[5] = cgu_get_pll_freq(CGU_HPLL0_ID, FFAST_CLOCK);
+	g_clkin_freq[6] = cgu_get_pll_freq(CGU_HPLL1_ID, FFAST_CLOCK);
+ 	printk(/*KERN_INFO*/ "cgu_init pll set at %d\n", g_clkin_freq[6]);
+	
+	lpc313x_cgu_init_debugfs();
+
+	return 0;
+}
+
+
+EXPORT_SYMBOL(cgu_get_base_freq);
+EXPORT_SYMBOL(cgu_set_base_freq);
+EXPORT_SYMBOL(cgu_get_clk_freq);
+EXPORT_SYMBOL(cgu_get_pll_freq);
+EXPORT_SYMBOL(cgu_set_subdomain_freq);
+EXPORT_SYMBOL(cgu_hpll_config);
+//EXPORT_SYMBOL(cgu_clk_set_exten);
+
+static unsigned long local_return_parent_rate(struct clk *clk)
+{
+	/*
+	 * If a clock has a rate of 0, then it inherits it's parent
+	 * clock rate
+	 */
+	while (clk->rate == 0)
+		clk = clk->parent;
+
+	return clk->rate;
+}
+
+static int local_onoff_enable(struct clk *clk, int enable)
+{
+	u32 tmp;
+
+	tmp = __raw_readl(clk->enable_reg);
+
+	if (enable == 0)
+		tmp &= ~clk->enable_mask;
+	else
+		tmp |= clk->enable_mask;
+
+	__raw_writel(tmp, clk->enable_reg);
+
+	return 0;
+}
+
+static int local_oscmain_enable(struct clk *clk, int enable)
+{
+	return 0;
+}
+
+static unsigned long get_rate(struct clk *clk)
+{
+	return cgu_get_clk_freq(clk->id);
+}
+
+static struct clk sys_base = {
+	.enable		= local_oscmain_enable,
+	.rate		= FFAST_CLOCK,
+};
+
+static struct clk clk_i2c0 = {
+	.parent		= &sys_base,
+	.enable		= local_onoff_enable,
+	.enable_reg	= &CGU_SB->clk_pcr[CGU_SB_I2C0_PCLK_ID],
+	.enable_mask	= CGU_SB_PCR_RUN,
+	.get_rate	= get_rate,
+	.id		= CGU_SB_I2C0_PCLK_ID,
+};
+
+static struct clk clk_i2c1 = {
+	.parent		= &sys_base,
+	.enable		= local_onoff_enable,
+	.enable_reg	= &CGU_SB->clk_pcr[CGU_SB_I2C1_PCLK_ID],
+	.enable_mask	= CGU_SB_PCR_RUN,
+	.get_rate	= get_rate,
+	.id		= CGU_SB_I2C1_PCLK_ID,
+};
+
+
+static DEFINE_MUTEX(clkm_lock);
+
+static inline void clk_lock(void)
+{
+	mutex_lock(&clkm_lock);
+}
+
+static inline void clk_unlock(void)
+{
+	mutex_unlock(&clkm_lock);
+}
+
+static void local_clk_disable(struct clk *clk)
+{
+	WARN_ON(clk->usecount == 0);
+
+	/* Don't attempt to disable clock if it has no users */
+	if (clk->usecount > 0) {
+		clk->usecount--;
+
+		/* Only disable clock when it has no more users */
+		if ((clk->usecount == 0) && (clk->enable))
+			clk->enable(clk, 0);
+
+		/* Check parent clocks, they may need to be disabled too */
+		if (clk->parent)
+			local_clk_disable(clk->parent);
+	}
+}
+
+static int local_clk_enable(struct clk *clk)
+{
+	int ret = 0;
+
+	/* Enable parent clocks first and update use counts */
+	if (clk->parent)
+		ret = local_clk_enable(clk->parent);
+
+	if (!ret) {
+		/* Only enable clock if it's currently disabled */
+		if ((clk->usecount == 0) && (clk->enable))
+			ret = clk->enable(clk, 1);
+
+		if (!ret)
+			clk->usecount++;
+		else if (clk->parent)
+			local_clk_disable(clk->parent);
+	}
+
+	return ret;
+}
+
+/*
+ * clk_enable - inform the system when the clock source should be running.
+ */
+int clk_enable(struct clk *clk)
+{
+	int ret;
+
+	clk_lock();
+	ret = local_clk_enable(clk);
+	clk_unlock();
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+/*
+ * clk_disable - inform the system when the clock source is no longer required
+ */
+void clk_disable(struct clk *clk)
+{
+	clk_lock();
+	local_clk_disable(clk);
+	clk_unlock();
+}
+EXPORT_SYMBOL(clk_disable);
+
+/*
+ * clk_get_rate - obtain the current clock rate (in Hz) for a clock source
+ */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long rate;
+
+	clk_lock();
+	rate = clk->get_rate(clk);
+	clk_unlock();
+
+	return rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+#define _REGISTER_CLOCK(d, n, c) \
+	{ \
+		.dev_id = (d), \
+		.con_id = (n), \
+		.clk = &(c), \
+	},
+
+static struct clk_lookup lookups[] = {
+	_REGISTER_CLOCK("pnx-i2c.0", NULL, clk_i2c0)
+	_REGISTER_CLOCK("pnx-i2c.1", NULL, clk_i2c1)
+};
+
+static int __init clk_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
+		clkdev_add(&lookups[i]);
+
+	return 0;
+}
+core_initcall(clk_init);
+
diff --git a/arch/arm/mach-lpc31xx/dma.c b/arch/arm/mach-lpc31xx/dma.c
new file mode 100644
index 0000000..85a1603
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/dma.c
@@ -0,0 +1,551 @@
+/*  arch/arm/mach-lpc313x/dma.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  DMA driver for machines with LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <mach/clock.h>
+#include <mach/dma.h>
+
+
+static spinlock_t driver_lock; /* to guard state variables */
+
+static inline void lpc313x_dma_lock(void)
+{
+	spin_lock(&driver_lock);
+}
+
+static inline void lpc313x_dma_unlock(void)
+{
+	spin_unlock(&driver_lock);
+}
+
+static struct dma_channel {
+	char *name;
+	dma_cb_t callback_handler;
+	void *data;
+} dma_channels[DMA_MAX_CHANNELS];
+
+static unsigned int     dma_irq_mask = 0xFFFFFFFF;
+static int sg_higher_channel[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static int softirqmask[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static int softirqen = 0;
+
+static int dma_channels_requested = 0;
+
+static inline void dma_increment_usage(void)
+{
+	if (!dma_channels_requested++) {
+		cgu_clk_en_dis(CGU_SB_DMA_CLK_GATED_ID, 1);
+		cgu_clk_en_dis(CGU_SB_DMA_PCLK_ID, 1);
+	}
+}
+static inline void dma_decrement_usage(void)
+{
+	if (!--dma_channels_requested) {
+		cgu_clk_en_dis(CGU_SB_DMA_CLK_GATED_ID, 0);
+		cgu_clk_en_dis(CGU_SB_DMA_PCLK_ID, 0);
+	}
+}
+
+static inline int dma_valid_config(const dma_setup_t *dma_setup)
+{
+	if (!dma_setup)
+		return -EINVAL;
+
+	if (DMA_CFG_GET_RD_SLV_NR(dma_setup->cfg) > DMA_SLV_SDMMC   ||
+	    DMA_CFG_GET_WR_SLV_NR(dma_setup->cfg) > DMA_SLV_SDMMC    ||
+	    DMA_CFG_GET_CMP_CH_NR(dma_setup->cfg) >= DMA_MAX_CHANNELS)
+		return -EINVAL;
+
+	return 0;
+}
+
+int dma_prog_channel (unsigned int chn, dma_setup_t *dma_setup)
+{
+	if ((chn >= DMA_MAX_CHANNELS) || !dma_channels[chn].name ||
+		dma_valid_config(dma_setup) )
+		return -EINVAL;
+	
+	DMACH_SRC_ADDR(chn) = dma_setup->src_address;
+	DMACH_DST_ADDR(chn) = dma_setup->dest_address;
+	DMACH_LEN(chn) = dma_setup->trans_length;
+	DMACH_CFG(chn) = dma_setup->cfg;
+
+	return 0;
+}
+
+int dma_request_channel (char *name, dma_cb_t cb, void *data)
+{
+	unsigned int mask;
+	unsigned int chn;
+	unsigned long flags;
+	dma_setup_t  dma_setup;
+
+	if (!name)
+		return -EINVAL;
+
+	lpc313x_dma_lock();
+
+	memset(&dma_setup, 0, sizeof(dma_setup));
+
+	for (chn = 0, mask = 1; chn < DMA_MAX_CHANNELS; chn++) 
+	{
+		if (!dma_channels[chn].name) 
+		{
+			dma_increment_usage();
+			dma_channels[chn].name = name;
+			if (cb) {
+				dma_channels[chn].callback_handler = cb;
+				dma_channels[chn].data = data;
+			}
+			dma_prog_channel (chn, &dma_setup);
+			local_irq_save(flags);
+		        dma_irq_mask &= ~mask;  /* enable the IRQ: dafault behavior */
+			DMACH_IRQ_MASK = dma_irq_mask;
+			local_irq_restore(flags);
+			lpc313x_dma_unlock();
+			return chn;
+		}
+		mask = mask << 2;
+	}
+	lpc313x_dma_unlock();
+	return -EBUSY;
+}
+
+
+int dma_request_specific_channel (int chn, char *name, void (*cb)(int, dma_irq_type_t, void *), void *data)
+{
+	unsigned long flags;
+	dma_setup_t  dma_setup;
+
+	if (chn >= DMA_MAX_CHANNELS || !name)
+		return -EINVAL;
+
+	if (dma_channels[chn].name) 
+		return -EBUSY;
+
+	lpc313x_dma_lock();
+
+	memset(&dma_setup, 0, sizeof(dma_setup));
+
+	dma_increment_usage();
+	dma_channels[chn].name = name;
+	if (cb) {
+		dma_channels[chn].callback_handler = cb;
+		dma_channels[chn].data = data;
+	}
+	dma_prog_channel (chn, &dma_setup);
+	local_irq_save(flags);
+	dma_irq_mask &= ~(1 << (2 * chn));  /* enable the IRQ: dafault behavior */
+	DMACH_IRQ_MASK = dma_irq_mask;
+	local_irq_restore(flags);
+	lpc313x_dma_unlock();
+	return chn;
+}
+
+
+int dma_set_irq_mask(unsigned int chn, int half_int, int fin_int)
+{
+	unsigned long flags;
+
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	lpc313x_dma_lock();
+	local_irq_save(flags);
+
+	if (fin_int)
+		dma_irq_mask |= (1 << (chn * 2));
+	else
+		dma_irq_mask &= ~(1 << (chn * 2));
+
+	if  (half_int)
+		dma_irq_mask |= (1 << (chn * 2 + 1));
+	else
+		dma_irq_mask &= ~(1 << (chn * 2 + 1));
+
+	DMACH_IRQ_MASK = dma_irq_mask;
+
+	local_irq_restore(flags);
+	lpc313x_dma_unlock();
+
+	return 0;
+}
+
+int dma_start_channel (unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	DMACH_EN(chn) = 1;
+	return 0;
+}
+
+int dma_stop_channel (unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	DMACH_EN(chn) = 0;
+	return 0;
+}
+
+int dma_stop_channel_sg (unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	/* Disable the companion channel only */
+	DMACH_EN(chn - 1) = 0;
+	return 0;
+}
+
+int dma_release_channel (unsigned int chn)
+{
+	unsigned int mask = (0x3 << (chn * 2));
+	unsigned long flags;
+
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	lpc313x_dma_lock();
+	
+	local_irq_save(flags);
+
+	/* Otherwise an unexpected interrupt can occur when the channel is reallocated for another purpose */
+	DMACH_IRQ_STATUS = mask;
+	dma_irq_mask |= mask;
+	DMACH_IRQ_MASK = dma_irq_mask;
+	/* reset counter */
+	DMACH_TCNT(chn) = 0;
+	local_irq_restore(flags);
+
+	dma_channels[chn].name = NULL;
+	dma_channels[chn].callback_handler = NULL;
+	dma_channels[chn].data = NULL;
+
+	lpc313x_dma_unlock();
+	dma_decrement_usage();
+	
+	return 0;
+}
+
+static irqreturn_t dma_irq_handler (int irq, void *dev_id)
+{
+	unsigned int mask;
+	unsigned int chn;
+	unsigned int dma_irq_status;
+
+	dma_irq_status = DMACH_IRQ_STATUS;
+	dma_irq_status &= ~dma_irq_mask;
+
+	for (chn = 0, mask = 1; chn < DMA_MAX_CHANNELS; chn++) {
+		if (dma_irq_status & mask) {
+			DMACH_IRQ_STATUS = mask;
+			if (dma_channels[chn].callback_handler)
+				(dma_channels[chn].callback_handler) 
+					(chn, DMA_IRQ_FINISHED, dma_channels[chn].data);
+		}
+		mask = mask << 1;
+		if (dma_irq_status & mask) {
+			DMACH_IRQ_STATUS = mask;
+			if (dma_channels[chn].callback_handler)
+				(dma_channels[chn].callback_handler) 
+					(chn, DMA_IRQ_HALFWAY, dma_channels[chn].data);
+		}
+		mask = mask << 1;
+	}
+
+	if (dma_irq_status & DMA_IRQS_SOFT) { /* Soft int */ 
+		DMACH_IRQ_STATUS = DMA_IRQS_SOFT;
+		for (chn = 0; chn < DMA_MAX_CHANNELS; chn++) {
+			if (sg_higher_channel[chn] && softirqmask[chn] &&
+				dma_channels[sg_higher_channel[chn]].callback_handler)
+			(dma_channels[sg_higher_channel[chn]].callback_handler)
+				(sg_higher_channel[chn], DMA_IRQ_SOFTINT,
+				dma_channels[sg_higher_channel[chn]].data);
+		}
+	}
+
+	if (dma_irq_status & DMA_IRQS_ABORT) { /* DMA abort */
+		printk(KERN_WARNING "DMA abort signalled\n");
+		DMACH_IRQ_STATUS = DMA_IRQS_ABORT;
+		for (chn = 0; chn < DMA_MAX_CHANNELS; chn++)
+			if (dma_channels[chn].callback_handler)
+				(dma_channels[chn].callback_handler) 
+					(chn, DMA_IRQ_DMAABORT, dma_channels[chn].data);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int dma_read_counter (unsigned int chn, unsigned int * pcnt)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+	*pcnt = DMACH_TCNT(chn);
+	return 0;
+}
+
+int dma_write_counter (unsigned int chn, u32 cnt)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+	DMACH_TCNT(chn) = cnt;
+	return 0;
+}
+
+
+int dma_current_state (unsigned int   chn,
+                        unsigned int * psrc,
+                        unsigned int * pdst,
+                        unsigned int * plen,
+                        unsigned int * pcfg,
+                        unsigned int * pena,
+                        unsigned int * pcnt)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	*psrc = DMACH_SRC_ADDR(chn);
+	*pdst = DMACH_DST_ADDR(chn);
+	*plen  = DMACH_LEN(chn);
+	*pcfg = DMACH_CFG(chn);
+	*pena = DMACH_EN(chn);
+	*pcnt  = DMACH_TCNT(chn);
+	return 0;
+}
+
+int dma_request_sg_channel (char *name, dma_cb_t cb, void *data, int usesoftirq)
+{
+	unsigned int chn;
+	unsigned long flags;
+	dma_setup_t  dma_setup;
+
+	if (!name)
+		return -EINVAL;
+
+	if (softirqen & usesoftirq)
+		return -EBUSY;
+
+	lpc313x_dma_lock();
+
+	for (chn = 0; chn < DMA_MAX_CHANNELS - 1; chn++) 
+		if (!dma_channels[chn].name && !dma_channels[chn + 1].name) {
+			sg_higher_channel[chn] = chn + 1;
+			break;
+		}
+
+	if (!sg_higher_channel[chn]) {
+		lpc313x_dma_unlock();
+		return -EBUSY;
+	}
+
+	memset(&dma_setup, 0, sizeof(dma_setup));
+
+	dma_increment_usage();
+	dma_channels[sg_higher_channel[chn]].name = name;
+	dma_channels[sg_higher_channel[chn] - 1].name = name;
+
+	if (cb) {
+		dma_channels[sg_higher_channel[chn]].callback_handler = cb;
+		dma_channels[sg_higher_channel[chn]].data = data;
+	}
+	dma_prog_channel (sg_higher_channel[chn], &dma_setup);
+
+	if (usesoftirq) {
+		local_irq_save(flags);
+		softirqen = 1;
+		softirqmask[chn] = 1;
+		dma_irq_mask &= ~DMA_IRQS_SOFT;  /* enable the soft IRQ */
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
+	}
+
+	lpc313x_dma_unlock();
+
+	return sg_higher_channel[chn];
+}
+
+int dma_request_specific_sg_channel (int chn, char *name, dma_cb_t cb, void *data, int usesoftirq)
+{
+	unsigned long flags;
+	dma_setup_t  dma_setup;
+
+	if (!name)
+		return -EINVAL;
+
+	if (softirqen & usesoftirq)
+		return -EBUSY;
+
+	if (sg_higher_channel[chn] || dma_channels[chn].name || dma_channels[chn - 1].name)
+		return -EBUSY;
+
+	lpc313x_dma_lock();
+	
+	sg_higher_channel[chn] = chn;
+
+	memset(&dma_setup, 0, sizeof(dma_setup));
+
+	dma_increment_usage();
+	dma_channels[sg_higher_channel[chn]].name = name;
+	dma_channels[sg_higher_channel[chn] - 1].name = name;
+
+	if (cb) {
+		dma_channels[sg_higher_channel[chn]].callback_handler = cb;
+		dma_channels[sg_higher_channel[chn]].data = data;
+	}
+	dma_prog_channel (sg_higher_channel[chn], &dma_setup);
+
+	if (usesoftirq) {
+		local_irq_save(flags);
+		softirqen = 1;
+		softirqmask[chn] = 1;
+		dma_irq_mask &= ~DMA_IRQS_SOFT;  /* enable the soft IRQ */
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
+	}
+
+	return sg_higher_channel[chn];
+}
+
+int dma_prog_sg_channel(int chn, u32 dma_sg_list)
+{
+	u32 dma_config;
+
+	if (chn >= DMA_MAX_CHANNELS)
+		return -EINVAL;
+
+	dma_config = DMA_CFG_CMP_CH_EN | DMA_CFG_CMP_CH_NR(chn - 1);
+
+	lpc313x_dma_lock();
+	DMACH_SRC_ADDR(chn) = dma_sg_list;
+	DMACH_DST_ADDR(chn) = DMACH_ALT_PHYS(chn - 1);
+	DMACH_LEN(chn) = 0x4;
+	DMACH_CFG(chn) = dma_config;
+	lpc313x_dma_unlock();
+
+	return 0;
+}
+
+int dma_channel_enabled(unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	return (DMACH_EN(chn) & 1);
+}
+
+static int __init lpc313x_dma_init (void)
+{
+	int ret = 0;
+
+	memset(dma_channels, 0, sizeof(struct dma_channel) * DMA_MAX_CHANNELS);
+	spin_lock_init(&driver_lock);
+
+	dma_irq_mask = 0xFFFFFFFF;
+	DMACH_IRQ_MASK = dma_irq_mask;
+	ret = request_irq (IRQ_DMA, dma_irq_handler, 0, "DMAC", NULL);
+	if (ret)
+		printk (KERN_ERR "request_irq() returned error %d\n", ret);
+
+	return ret;
+}
+
+int dma_release_sg_channel (unsigned int chn)
+{
+	unsigned long flags;
+
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	lpc313x_dma_lock();
+
+	if (softirqmask[chn] != 0) {
+		local_irq_save(flags);
+		softirqen = 0;
+		softirqmask[chn] = 0;
+		dma_irq_mask |= DMA_IRQS_SOFT;
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
+	}
+	
+	dma_channels[chn].name = NULL;
+	dma_channels[chn].callback_handler = NULL;
+	dma_channels[chn].data = NULL;
+	
+	chn--;
+	dma_channels[chn].name = NULL;
+	dma_channels[chn].callback_handler = NULL;
+	dma_channels[chn].data = NULL;
+	
+	sg_higher_channel[chn] = 0;
+
+	lpc313x_dma_unlock();
+	dma_decrement_usage();
+	return 0;
+}
+int dma_prepare_sg_list(int n, dma_sg_ll_t * sg)
+{
+    /* fixed me: not yet implement */
+    return 0;
+}
+
+device_initcall(lpc313x_dma_init);
+
+
+EXPORT_SYMBOL(dma_prog_channel);
+EXPORT_SYMBOL(dma_request_channel);
+EXPORT_SYMBOL(dma_request_specific_channel);
+EXPORT_SYMBOL(dma_start_channel);
+EXPORT_SYMBOL(dma_stop_channel);
+EXPORT_SYMBOL(dma_release_channel);
+EXPORT_SYMBOL(dma_set_irq_mask);
+EXPORT_SYMBOL(dma_read_counter);
+EXPORT_SYMBOL(dma_write_counter);
+EXPORT_SYMBOL(dma_current_state);
+EXPORT_SYMBOL(dma_request_sg_channel);
+EXPORT_SYMBOL(dma_request_specific_sg_channel);
+EXPORT_SYMBOL(dma_prog_sg_channel);
+EXPORT_SYMBOL(dma_release_sg_channel);
+EXPORT_SYMBOL(dma_prepare_sg_list);
+EXPORT_SYMBOL(dma_channel_enabled);
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
new file mode 100644
index 0000000..6729930
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -0,0 +1,271 @@
+/*  arch/arm/mach-lpc313x/generic.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  Common code for machines with LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/console.h>
+#include <linux/serial_8250.h>
+
+#include <asm/errno.h>
+#include <mach/hardware.h>
+
+#include <mach/gpio.h>
+#include <asm/mach/map.h>
+
+/* local functions */
+
+static void lpc313x_uart_pm(struct uart_port * port, unsigned int state,
+			      unsigned int oldstate)
+{
+	switch (state) {
+	case 0:
+		/* Free the pins so that UART IP will take control of it */
+		if (oldstate != -1) {
+			gpio_free(GPIO_UART_RXD);
+			gpio_free(GPIO_UART_TXD);
+		}
+		/*
+		 * Enable the peripheral clock for this serial port.
+		 * This is called on uart_open() or a resume event.
+		 */
+		/* Enable UART base clock */
+		cgu_endis_base_freq(CGU_SB_UARTCLK_BASE_ID, 1);
+
+		/* Enable UART IP clock */
+		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+		break;
+	case 1:
+		/* we can wake the system in this state. So leave clocks on */
+		printk(KERN_INFO "lpc313x_uart_pm: UART can wake\n");
+		break;
+	case 3:
+		/*
+		 * Disable the peripheral clock for this serial port.
+		 * This is called on uart_close() or a suspend event.
+		 */
+		/* Disable UART IP clock */
+		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 0);
+		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 0);
+
+		/* Disable UART base clock */
+		cgu_endis_base_freq(CGU_SB_UARTCLK_BASE_ID, 0);
+
+		/* Free the pins and let GPIO handle it */
+		gpio_request(GPIO_UART_RXD, "uart_rx");
+		gpio_request(GPIO_UART_TXD, "uart_tx");
+
+		gpio_direction_input(GPIO_UART_RXD);
+		gpio_direction_output(GPIO_UART_TXD, 0);
+		break;
+	default:
+		printk(KERN_ERR "lpc313x_uart_pm: unknown pm %d\n", state);
+	}
+
+}
+
+static struct plat_serial8250_port platform_serial_ports[] = {
+	{
+		.membase = (void *)io_p2v(UART_PHYS),
+		.mapbase = (unsigned long)UART_PHYS,
+		.irq = IRQ_UART,
+		.uartclk = XTAL_CLOCK,
+		.regshift = 2,
+		.iotype = UPIO_MEM,
+		.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST,
+		.pm = lpc313x_uart_pm,
+	},
+	{
+		.flags		= 0
+	},
+};
+
+static struct platform_device serial_device = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data = &platform_serial_ports,
+	},
+};
+
+
+static struct platform_device *devices[] __initdata = {
+	&serial_device,
+};
+
+static struct map_desc lpc313x_io_desc[] __initdata = {
+	{
+		.virtual	= io_p2v(IO_INTC_PHYS),
+		.pfn		= __phys_to_pfn(IO_INTC_PHYS),
+		.length		= IO_INTC_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_APB01_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB01_PHYS),
+		.length		= IO_APB01_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_APB2_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB2_PHYS),
+		.length		= IO_APB2_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_APB3_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB3_PHYS),
+		.length		= IO_APB3_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_APB4_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB4_PHYS),
+		.length		= IO_APB4_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_DMA_REG_PHYS),
+		.pfn		= __phys_to_pfn(IO_DMA_REG_PHYS),
+		.length		= IO_DMA_REG_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_MPMC_CFG_PHYS),
+		.pfn		= __phys_to_pfn(IO_MPMC_CFG_PHYS),
+		.length		= IO_MPMC_CFG_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
+		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
+		.length		= IO_NAND_BUF_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_ISRAM0_PHYS),
+		.pfn		= __phys_to_pfn(IO_ISRAM0_PHYS),
+		.length		= IO_ISRAM0_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+void __init lpc313x_map_io(void)
+{
+	iotable_init(lpc313x_io_desc, ARRAY_SIZE(lpc313x_io_desc));
+}
+extern int __init cgu_init(char *str);
+
+int __init lpc313x_init(void)
+{
+	/* cgu init */
+	cgu_init("");
+	/* Switch on the UART clocks */
+	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_IOCONF_PCLK_ID, 1);
+
+	/* Put adc block in low power state.
+	 * Once ADC driver is added this should move to driver.
+	 */
+	SYS_ADC_PD = 1;
+	/* Disable ring oscillators used by Random number generators */
+	SYS_RNG_OSC_CFG = 0;
+
+	/* Mux I2S signals based on selected channel */
+#if defined (CONFIG_SND_I2S_TX0_MASTER)
+	/* I2S TX0 WS, DATA */
+	GPIO_DRV_IP(IOCONF_EBI_I2STX_0, 0x60);
+
+	/* I2S TX0 BCK */
+	GPIO_DRV_IP(IOCONF_EBI_MCI, 0x80);
+#endif
+
+#if defined (CONFIG_SND_I2S_TX1_MASTER)
+	/* I2S TX1 BCK, WS, DATA */
+	GPIO_DRV_IP(IOCONF_I2STX_1, 0x7);
+#endif
+
+#if defined (CONFIG_SND_I2S_RX0_MASTER) | defined (CONFIG_SND_I2S_RX0_SLAVE)
+	/* I2S RX0 BCK, WS, DATA */
+	GPIO_DRV_IP(IOCONF_I2SRX_0, 0x7);
+#endif
+#if defined (CONFIG_SND_I2S_RX1_MASTER) | defined (CONFIG_SND_I2S_RX1_SLAVE)
+	/* I2S RX1 BCK, WS, DATA */
+	GPIO_DRV_IP(IOCONF_I2SRX_1, 0x7);
+#endif
+	/* AUDIO CODEC CLOCK (256FS) */
+	GPIO_DRV_IP(IOCONF_I2STX_1, 0x8);
+
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+
+#if defined(CONFIG_SERIAL_8250_CONSOLE)
+static int __init lpc313x_init_console(void)
+{
+	static __initdata char serr[] =
+		KERN_ERR "Serial port #%u setup failed\n";
+	struct uart_port up;
+	int mul, div;
+
+	/* Switch on the UART clocks */
+	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+
+ 	/*
+	 * Set up serial port #0. Do not use autodetection; the result is
+	 * not what we want.
+ 	 */
+	memset(&up, 0, sizeof(up));
+
+	up.membase = (char *) io_p2v(UART_PHYS);
+	up.mapbase = (unsigned long)UART_PHYS,
+	up.irq = IRQ_UART;
+	up.uartclk = XTAL_CLOCK;
+	/* check what FDR bootloader is using */
+	mul = (UART_FDR_REG >> 4) & 0xF;
+	div = UART_FDR_REG & 0xF;
+	if (div != 0)  {
+		up.uartclk = (XTAL_CLOCK * mul) / (mul + div); 
+	} 
+	up.regshift = 2;
+	up.iotype = UPIO_MEM;
+	up.type	= PORT_NXP16750;
+	up.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST;
+	up.line	= 0;
+	platform_serial_ports[0].uartclk = up.uartclk;
+	if (early_serial_setup(&up))
+		printk(serr, up.line);
+
+	return 0;
+}
+console_initcall(lpc313x_init_console);
+
+#endif /*CONFIG_SERIAL_8250_CONSOLE*/
+
+
+
+
diff --git a/arch/arm/mach-lpc31xx/gpio.c b/arch/arm/mach-lpc31xx/gpio.c
new file mode 100644
index 0000000..fd09c8b
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/gpio.c
@@ -0,0 +1,135 @@
+/*  linux/arch/arm/mach-lpc313x/gpio.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * GPIO driver for LPC313x & LPC315x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#include <asm/errno.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+
+void lpx313x_gpio_func_mode(int gpio)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_RESET(port) = pin; 
+	GPIO_M0_SET(port) = pin;
+
+	raw_local_irq_restore(flags);
+
+}
+
+EXPORT_SYMBOL(lpx313x_gpio_func_mode);
+
+
+
+
+int lpc313x_gpio_direction_output(unsigned gpio, int value)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_SET(port) = pin; 
+
+	if(value) {
+		GPIO_M0_SET(port) = pin;
+	} else {
+		GPIO_M0_RESET(port) = pin;
+	}
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(lpc313x_gpio_direction_output);
+
+
+#ifndef CONFIG_GPIOLIB
+int gpio_is_valid(unsigned gpio)
+{
+	int ret = 1;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin_no = (gpio & GPIO_PIN_MASK);
+
+
+	if ( (gpio & ~(GPIO_PORT_MASK | GPIO_PIN_MASK)) &&
+	     ((port >> 5) > 12)) {
+		return 0;
+	} 
+	switch (port) {
+		case IOCONF_EBI_I2STX_0:
+			if (pin_no > 9)
+				ret = 0;
+			break;
+		case IOCONF_PWM:
+		case IOCONF_CGU:
+			if (pin_no > 0)
+				ret = 0;
+			break;
+		case IOCONF_I2SRX_0:
+		case IOCONF_I2SRX_1:
+			if (pin_no > 2)
+				ret = 0;
+			break;
+		case IOCONF_I2STX_1:
+			if (pin_no > 3)
+				ret = 0;
+			break;
+		case IOCONF_EBI:
+			if (pin_no > 15)
+				ret = 0;
+			break;
+		case IOCONF_GPIO:
+			if (pin_no > 14)
+				ret = 0;
+			break;
+		case IOCONF_UART:
+		case IOCONF_I2C1:
+			if (pin_no > 1)
+				ret = 0;
+			break;
+		case IOCONF_SPI:
+			if (pin_no > 4)
+				ret = 0;
+			break;
+		case IOCONF_NAND_CTRL:
+			if (pin_no > 3)
+				ret = 0;
+			break;
+	}
+	return ret;
+}
+
+EXPORT_SYMBOL(gpio_is_valid);
+#endif
+
diff --git a/arch/arm/mach-lpc31xx/gpiolib.c b/arch/arm/mach-lpc31xx/gpiolib.c
new file mode 100644
index 0000000..0f37fb3
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/gpiolib.c
@@ -0,0 +1,224 @@
+/* linux/arch/arm/mach-lpc313x/gpiolib.c
+ *
+ * Copyright (c) 2011 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * LPC313X GPIOlib support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/sysdev.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <mach/gpio.h>
+
+
+/**
+ * struct lpc313x_gpio_chip - wrapper for specific implementation of gpio
+ * @chip: The chip structure to be exported via gpiolib.
+ * @base: The base pointer to the gpio configuration registers.
+ * @config: special function and pull-resistor control information.
+ * @pm_save: Save information for suspend/resume support.
+ *
+ * This wrapper provides the necessary information for the Samsung
+ * specific gpios being registered with gpiolib.
+ */
+struct lpc313x_gpio_chip {
+	struct gpio_chip	chip;
+	struct lpc313x_gpio_cfg	*config;
+	struct lpc313x_gpio_pm	*pm;
+	int			base;
+#ifdef CONFIG_PM
+	u32			pm_save[4];
+#endif
+};
+
+static inline struct lpc313x_gpio_chip *to_lpc313x_gpio(struct gpio_chip *gpc)
+{
+	return container_of(gpc, struct lpc313x_gpio_chip, chip);
+}
+
+struct lpc313x_gpio_chip lpc313x_gpios[] = {
+	[0] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_EBI_MCI,
+			.owner			= THIS_MODULE,
+			.label			= "EBI_MCI",
+			.ngpio			= 32,
+		},
+	},
+	[1] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_EBI_I2STX_0,
+			.owner			= THIS_MODULE,
+			.label			= "EBI_I2STX_0",
+			.ngpio			= 10,
+		},
+	},
+	[2] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_CGU,
+			.owner			= THIS_MODULE,
+			.label			= "CGU",
+			.ngpio			= 1,
+		},
+	},
+	[3] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_I2SRX_0,
+			.owner			= THIS_MODULE,
+			.label			= "I2SRX_0",
+			.ngpio			= 3,
+		},
+	},
+	[4] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_I2SRX_1,
+			.owner			= THIS_MODULE,
+			.label			= "I2SRX_0",
+			.ngpio			= 3,
+		},
+	},
+	[5] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_I2STX_1,
+			.owner			= THIS_MODULE,
+			.label			= "I2STX_1",
+			.ngpio			= 4,
+		},
+	},
+	[6] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_EBI,
+			.owner			= THIS_MODULE,
+			.label			= "EBI",
+			.ngpio			= 16,
+		},
+	},
+	[7] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_GPIO,
+			.owner			= THIS_MODULE,
+			.label			= "GPIO",
+			.ngpio			= 15,
+		},
+	},
+	[8] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_I2C1,
+			.owner			= THIS_MODULE,
+			.label			= "I2C1",
+			.ngpio			= 2,
+		},
+	},
+	[9] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_SPI,
+			.owner			= THIS_MODULE,
+			.label			= "SPI",
+			.ngpio			= 5,
+		},
+	},
+	[10] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_NAND_CTRL,
+			.owner			= THIS_MODULE,
+			.label			= "NAND_CTRL",
+			.ngpio			= 4,
+		},
+	},
+	[11] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_PWM,
+			.owner			= THIS_MODULE,
+			.label			= "PWM",
+			.ngpio			= 1,
+		},
+	},
+	[12] = {
+		.base	= GPIO_PHYS,
+		.chip	= {
+			.base			= IOCONF_UART,
+			.owner			= THIS_MODULE,
+			.label			= "UART",
+			.ngpio			= 2,
+		},
+	},
+};
+
+
+static inline int lpc3131_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	return lpc313x_gpio_direction_input(chip->base + offset);
+}
+
+static inline int lpc3131_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)
+{
+	return lpc313x_gpio_direction_output(chip->base + offset, value);
+}
+
+static inline int lpc3131_gpio_get_value(struct gpio_chip *chip, unsigned offset)
+{
+	return lpc313x_gpio_get_value(chip->base + offset);
+}
+
+static inline void lpc3131_gpio_set_value(struct gpio_chip *chip, unsigned offset, int value)
+{
+	lpc313x_gpio_set_value(chip->base + offset, value);
+}
+
+__init void lpc313x_gpiolib_add(struct lpc313x_gpio_chip *chip)
+{
+	struct gpio_chip *gc = &chip->chip;
+	int ret;
+
+	BUG_ON(!chip->base);
+	BUG_ON(!gc->label);
+	BUG_ON(!gc->ngpio);
+
+	if (!gc->direction_input)
+		gc->direction_input = lpc3131_gpio_direction_input;
+	if (!gc->direction_output)
+		gc->direction_output = lpc3131_gpio_direction_output;
+	if (!gc->set)
+		gc->set = lpc3131_gpio_set_value;
+	if (!gc->get)
+		gc->get = lpc3131_gpio_get_value;
+
+	/* gpiochip_add() prints own failure message on error. */
+	ret = gpiochip_add(gc);
+}
+
+static __init int lpc313x_gpiolib_init(void)
+{
+	struct lpc313x_gpio_chip *chip = lpc313x_gpios;
+	int gpn;
+
+	for (gpn = 0; gpn < ARRAY_SIZE(lpc313x_gpios); gpn++, chip++)
+		lpc313x_gpiolib_add(chip);
+
+	return 0;
+}
+
+core_initcall(lpc313x_gpiolib_init);
diff --git a/arch/arm/mach-lpc31xx/i2c.c b/arch/arm/mach-lpc31xx/i2c.c
new file mode 100644
index 0000000..1515c3e
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/i2c.c
@@ -0,0 +1,156 @@
+/*  linux/arch/arm/mach-lpc313x/i2c.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * I2C initialization for LPC313x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/i2c-pnx.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <mach/hardware.h>
+#include <mach/i2c.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+
+#define LPC313x_I2C0_SLV_ADDR            __REG (I2C0_PHYS + 0x014)
+#define LPC313x_I2C1_SLV_ADDR            __REG (I2C1_PHYS + 0x014)
+
+static int set_clock_run(struct platform_device *pdev)
+{
+	if (pdev->id == 0)
+		cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 1);
+	else
+		cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 1);
+
+	udelay(2);
+	return 0;
+}
+
+static int set_clock_stop(struct platform_device *pdev)
+{
+	if (pdev->id == 0)
+		cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 0);
+	else
+		cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 0);
+
+	return 0;
+}
+
+static int i2c_lpc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int retval = 0;
+#ifdef CONFIG_PM
+	retval = set_clock_stop(pdev);
+#endif
+	return retval;
+}
+
+static int i2c_lpc_resume(struct platform_device *pdev)
+{
+	int retval = 0;
+#ifdef CONFIG_PM
+	retval = set_clock_run(pdev);
+#endif
+	return retval;
+}
+
+static u32 calculate_input_freq(struct platform_device *pdev)
+{
+	return (FFAST_CLOCK/1000000);
+}
+
+
+static struct i2c_pnx_data lpc_pnx_data0 = {
+	.name = I2C_CHIP_NAME "0",
+	.base = I2C0_PHYS,
+	.irq = IRQ_I2C0,
+};
+
+static struct i2c_pnx_data lpc_pnx_data1 = {
+	.name = I2C_CHIP_NAME "1",
+	.base = I2C1_PHYS,
+	.irq = IRQ_I2C1,
+};
+
+static struct i2c_pnx_algo_data i2c0_algo_data;
+static struct i2c_pnx_algo_data i2c1_algo_data;
+
+static struct i2c_pnx_algo_data i2c0_algo_data = {
+	.adapter = {
+		.name = I2C_CHIP_NAME "0",
+		.algo_data = &i2c0_algo_data,
+	},
+	.i2c_pnx = &lpc_pnx_data0,
+};
+
+static struct i2c_pnx_algo_data i2c1_algo_data = {
+	.adapter = {
+		.name = I2C_CHIP_NAME "1",
+		.algo_data = &i2c1_algo_data,
+	},
+	.i2c_pnx = &lpc_pnx_data1,
+};
+
+static struct platform_device i2c0_device = {
+	.name = "pnx-i2c",
+	.id = 0,
+	.dev = {
+		.platform_data = &lpc_pnx_data0,
+	},
+};
+
+static struct platform_device i2c1_device = {
+	.name = "pnx-i2c",
+	.id = 1,
+	.dev = {
+		.platform_data = &lpc_pnx_data1,
+	},
+};
+
+static struct platform_device *devices[] __initdata = {
+	&i2c0_device,
+	&i2c1_device,
+};
+
+void __init lpc313x_register_i2c_devices(void)
+{
+	cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 1);
+	cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 1);
+
+	/* Enable I2C1 signals */
+	GPIO_DRV_IP(IOCONF_I2C1, 0x3);
+
+#if defined (CONFIG_MACH_VAL3153) || defined (CONFIG_MACH_EA313X)
+	/* on EA and VAL boards UDA1380 is connected to I2C1
+	 * whose slave address is same as LPC313x's default slave
+	 * adress causing bus contention errors. So change the
+	 * deafult slave address register value of LPC313x here.
+	 */
+	LPC313x_I2C0_SLV_ADDR = 0x06E;
+	LPC313x_I2C1_SLV_ADDR = 0x06E;
+#endif
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
diff --git a/arch/arm/mach-lpc31xx/include/mach/board.h b/arch/arm/mach-lpc31xx/include/mach/board.h
new file mode 100644
index 0000000..5fe9ac2
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/board.h
@@ -0,0 +1,151 @@
+/*  arch/arm/mach-lpc313x/generic.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  Defines prototypes for generic init functions LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __MACH_BOARD_H
+#define __MACH_BOARD_H
+
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/mmc/host.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mmc/host.h>
+
+
+extern void __init lpc313x_map_io(void);
+extern void __init lpc313x_init_irq(void);
+extern int __init lpc313x_init(void);
+extern int __init lpc313x_register_i2c_devices(void);
+extern void lpc313x_vbus_power(int enable);
+extern int lpc313x_entering_suspend_mem(void);
+
+
+struct sys_timer;
+extern struct sys_timer lpc313x_timer;
+
+/*
+ * Timing information structure for the NAND interface. Although there are
+ * multiple chip selects for the NAND controller, there is only 1 set of
+ * timing data shared among all chip selects. All the parts should be of
+ * the same type or very similar timings. These values are used to adjust
+ * the NAND timing to the current system clock speed.
+ *
+ * These values are NanoSecond timings. See the LPC31xx Users Guide for
+ * information on what these timings are and set the value for each timing
+ * with the matching value from the NAND device data sheet.
+ */
+struct lpc313x_nand_timing
+{
+	u32 ns_trsd;
+	u32 ns_tals;
+	u32 ns_talh;
+	u32 ns_tcls;
+	u32 ns_tclh;
+	u32 ns_tdrd;
+	u32 ns_tebidel;
+	u32 ns_tch;
+	u32 ns_tcs;
+	u32 ns_treh;
+	u32 ns_trp;
+	u32 ns_trw;
+	u32 ns_twp;
+};
+
+/*
+ * This structure is required for each chip select with an attached device
+ * and partitioning scheme. One of these structures is required for each
+ * device attached to a chip select of the NAND controller.
+ */
+struct lpc313x_nand_dev_info
+{
+	char *name; /* Informational name only */
+	int nr_partitions; /* Number of partitions on this device */
+	struct mtd_partition *partitions; /* Pointer to partition table */
+};
+
+/*
+ * High level NAND configuration structure
+ */
+struct lpc313x_nand_cfg {
+	int nr_devices;
+	struct lpc313x_nand_dev_info *devices;
+	struct lpc313x_nand_timing *timing;
+	int support_16bit;
+};
+
+/*
+ * Specifies behaviour of each supported chip select
+ */
+typedef void (*spi_cs_sel)(int, int);
+struct lpc313x_spics_cfg {
+	/* spi_spo is the serial clock polarity between transfers, 1 = high level,
+	   0 = low */
+	u8 spi_spo;
+	/* spi_sph is the control for clock edge capture, 0 = capture data on 1rst
+	   clock edge, 1 = second edge capture */
+	u8 spi_sph;
+	spi_cs_sel spi_cs_set; /* Sets state of SPI chip select */
+};
+
+/*
+ * Defines the number of chip selects and the cs data
+ */
+struct lpc313x_spi_cfg {
+	u32 num_cs; /* Number of CS supported on this board */
+	/* Array of cs setup data (num_cs entries) */
+	struct lpc313x_spics_cfg *spics_cfg;
+};
+
+#if defined (CONFIG_MACH_VAL3153) 
+#define MAX_MCI_SLOTS		2
+#else
+#define MAX_MCI_SLOTS		1
+#endif
+
+/*
+ * the board-type specific routines
+ */
+struct lpc313x_mci_board {
+	u32 num_slots;
+	u32 detect_delay_ms; /* delay in mS before detecting cards after interrupt */
+	int (*init)(u32 slot_id, irq_handler_t , void *);
+	int (*get_ro)(u32 slot_id);
+	int (*get_cd)(u32 slot_id);
+	int (*get_ocr)(u32 slot_id);
+	int (*get_bus_wd)(u32 slot_id);
+	/*
+	 * Enable power to selected slot and set voltage to desired level.
+	 * Voltage levels are specified using MMC_VDD_xxx defines defined
+	 * in linux/mmc/host.h file.
+	 */
+	void (*setpower)(u32 slot_id, u32 volt);
+	void (*exit)(u32 slot_id);
+	void (*select_slot)(u32 slot_id);
+};
+
+struct lpc313x_mci_irq_data {
+	u32 irq;
+	irq_handler_t irq_hdlr;
+	void* data;
+};
+
+#endif /*__MACH_BOARD_H*/
+
diff --git a/arch/arm/mach-lpc31xx/include/mach/clkdev.h b/arch/arm/mach-lpc31xx/include/mach/clkdev.h
new file mode 100644
index 0000000..04b37a8
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/clock.h b/arch/arm/mach-lpc31xx/include/mach/clock.h
new file mode 100644
index 0000000..d7058b6
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/clock.h
@@ -0,0 +1,656 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/clock.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  CGU defines and register structures for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __LPC32XX_CLOCK_H
+#define __LPC32XX_CLOCK_H
+
+ /***********************************************************************
+ * CGU register definitions
+ **********************************************************************/
+#define CGU_SB_NR_BASE     12
+#define CGU_SB_NR_CLK      92
+#define CGU_SB_NR_BCR      5
+#define CGU_SB_NR_FRACDIV  24
+#define CGU_SB_NR_DYN_FDIV 7
+#define CGU_SB_NR_ESR      89
+#define CGU_SB_BASE0_FDIV_CNT           7
+#define CGU_SB_BASE0_FDIV_LOW_ID        0
+#define CGU_SB_BASE0_FDIV_HIGH_ID       6
+#define CGU_SB_BASE0_FDIV0_W            8
+
+#define CGU_SB_BASE1_FDIV_CNT           2
+#define CGU_SB_BASE1_FDIV_LOW_ID        7
+#define CGU_SB_BASE1_FDIV_HIGH_ID       8
+
+#define CGU_SB_BASE2_FDIV_CNT           2
+#define CGU_SB_BASE2_FDIV_LOW_ID        9
+#define CGU_SB_BASE2_FDIV_HIGH_ID       10
+
+#define CGU_SB_BASE3_FDIV_CNT           3
+#define CGU_SB_BASE3_FDIV_LOW_ID        11
+#define CGU_SB_BASE3_FDIV_HIGH_ID       13
+
+#define CGU_SB_BASE4_FDIV_CNT           1
+#define CGU_SB_BASE4_FDIV_LOW_ID        14
+#define CGU_SB_BASE4_FDIV_HIGH_ID       14
+
+#define CGU_SB_BASE5_FDIV_CNT           1
+#define CGU_SB_BASE5_FDIV_LOW_ID        15
+#define CGU_SB_BASE5_FDIV_HIGH_ID       15
+
+#define CGU_SB_BASE6_FDIV_CNT           1
+#define CGU_SB_BASE6_FDIV_LOW_ID        16
+#define CGU_SB_BASE6_FDIV_HIGH_ID       16
+
+#define CGU_SB_BASE7_FDIV_CNT           6
+#define CGU_SB_BASE7_FDIV_LOW_ID        17
+#define CGU_SB_BASE7_FDIV_HIGH_ID       22
+#define CGU_SB_BASE7_FDIV0_W            13
+
+#define CGU_SB_BASE10_FDIV_CNT          1
+#define CGU_SB_BASE10_FDIV_LOW_ID       23
+#define CGU_SB_BASE10_FDIV_HIGH_ID      23
+
+
+typedef volatile struct
+{
+  /* Switches controls */
+  volatile u32 base_scr[12]; /* Switch control */
+  volatile u32 base_fs1[12]; /* Frequency select side 1 */
+  volatile u32 base_fs2[12]; /* Frequency select side 2 */
+  volatile u32 base_ssr[12]; /* Switch status */
+  /* Clock enable controls (positive and inverted clock pairs share control register)*/
+  volatile u32 clk_pcr[92]; /* power control */
+  volatile u32 clk_psr[92]; /* power status */
+  /* enable select from fractional dividers (positive and inverted clock pairs share esr)*/
+  volatile u32 clk_esr[89]; /* enable select */
+  /* Base controls, currently only fd_run (base wide fractional divider enable) bit.*/
+  volatile u32 base_bcr[5]; /* Base control */
+  /* Fractional divider controls & configuration*/
+  volatile u32 base_fdc[24]; /* Fractional divider config & ctrl */
+  volatile u32 base_dyn_fdc[7]; /* Fractional divider config & ctrl for dynamic fracdivs */
+  volatile u32 base_dyn_sel[7]; /* Fractional divider register for selecting an external signal to trigger high-speed operation*/
+} CGU_SB_REGS_T;
+
+/* ----------------
+* HP PLL Registers
+* ----------------
+*/
+typedef volatile struct
+{
+  volatile u32 fin_select;
+  volatile u32 mdec;
+  volatile u32 ndec;
+  volatile u32 pdec;
+  volatile u32 mode;
+  volatile u32 status;
+  volatile u32 ack;
+  volatile u32 req;
+  volatile u32 inselr;
+  volatile u32 inseli;
+  volatile u32 inselp;
+  volatile u32 selr;
+  volatile u32 seli;
+  volatile u32 selp;
+} CGU_HP_CFG_REGS;
+
+typedef volatile struct
+{
+  volatile u32 powermode;
+  volatile u32 wd_bark;
+  volatile u32 ffast_on;
+  volatile u32 ffast_bypass;
+  volatile u32 resetn_soft[56];
+  CGU_HP_CFG_REGS hp[2];
+} CGU_CONFIG_REGS;
+
+#define CGU_SB    ((CGU_SB_REGS_T*) io_p2v(CGU_SB_PHYS))
+#define CGU_CFG   ((CGU_CONFIG_REGS*) io_p2v(CGU_CFG_PHYS))
+
+
+/* Switch Control Register */
+#define CGU_SB_SCR_EN1              _BIT(0)
+#define CGU_SB_SCR_EN2              _BIT(1)
+#define CGU_SB_SCR_RST              _BIT(2)
+#define CGU_SB_SCR_STOP             _BIT(3)
+#define CGU_SB_SCR_FS_MASK          0x3
+
+/* Switch Status Register */
+#define CGU_SB_SSR_FS_GET(x)        ( ((x) >> 2) & 0x7)
+/* Power Control Register */
+#define CGU_SB_PCR_RUN              _BIT(0)
+#define CGU_SB_PCR_AUTO             _BIT(1)
+#define CGU_SB_PCR_WAKE_EN          _BIT(2)
+#define CGU_SB_PCR_EXTEN_EN         _BIT(3)
+#define CGU_SB_PCR_ENOUT_EN         _BIT(4)
+/* Power Status Register */
+#define CGU_SB_PSR_ACTIVE           _BIT(0)
+#define CGU_SB_PSR_WAKEUP           _BIT(1)
+/* Enable Select Register */
+#define CGU_SB_ESR_ENABLE           _BIT(0)
+#define CGU_SB_ESR_SELECT(x)        _SBF(1, (x))
+#define CGU_SB_ESR_SEL_GET(x)       (((x) >> 1) & 0x7)
+
+/* Base control Register */
+#define CGU_SB_BCR_FD_RUN           _BIT(0)
+/* Fractional Divider Configuration Register */
+#define CGU_SB_FDC_RUN              _BIT(0)
+#define CGU_SB_FDC_RESET            _BIT(1)
+#define CGU_SB_FDC_STRETCH          _BIT(2)
+#define CGU_SB_FDC_MADD(x)          _SBF( 3, ((x) & 0xFF))
+#define CGU_SB_FDC_MSUB(x)          _SBF(11, ((x) & 0xFF))
+#define CGU_SB_FDC17_MADD(x)        _SBF( 3, ((x) & 0x1FFF))
+#define CGU_SB_FDC17_MSUB(x)        _SBF(16, ((x) & 0x1FFF))
+#define CGU_SB_FDC_MADD_GET(x)      (((x) >> 3) & 0xFF)
+#define CGU_SB_FDC_MSUB_GET(x)      ((((x) >> 11) & 0xFF) | 0xFFFFFF00)
+#define CGU_SB_FDC17_MADD_GET(x)    (((x) >> 3) & 0x1FFF)
+#define CGU_SB_FDC17_MSUB_GET(x)    ((((x) >> 16) & 0x1FFF) | 0xFFFFE000)
+#define CGU_SB_FDC_MADD_POS         3
+
+/* Dynamic Fractional Divider Configuration Register */
+#define CGU_SB_DYN_FDC_RUN          _BIT(0)
+#define CGU_SB_DYN_FDC_ALLOW        _BIT(1)
+#define CGU_SB_DYN_FDC_STRETCH      _BIT(2)
+
+/**********************************************************************
+* Register description of POWERMODE
+**********************************************************************/
+#define CGU_POWERMODE_MASK     0x3
+#define CGU_POWERMODE_NORMAL   0x1
+#define CGU_POWERMODE_WAKEUP   0x3
+
+/**********************************************************************
+* Register description of WD_BARK
+**********************************************************************/
+#define CGU_WD_BARK            0x1
+
+/**********************************************************************
+* Register description of FFAST_ON
+**********************************************************************/
+#define CGU_FFAST_ON           0x1
+
+/**********************************************************************
+* Register description of FFAST_BYPASS
+**********************************************************************/
+#define CGU_FFAST_BYPASS       0x1
+
+/**********************************************************************
+* Register description of soft reset registers
+**********************************************************************/
+#define CGU_CONFIG_SOFT_RESET  0x1
+
+/**********************************************************************
+* Register description of HP_FIN_SELECT
+**********************************************************************/
+#define CGU_HPLL_FIN_SEL_MASK       0xf
+#define CGU_FIN_SELECT_FFAST        0x0
+#define CGU_FIN_SELECT_XT_DAI_BCK0  0x1
+#define CGU_FIN_SELECT_XT_DAI_WS0   0x2
+#define CGU_FIN_SELECT_XT_DAI_BCK1  0x3
+#define CGU_FIN_SELECT_XT_DAI_WS1   0x4
+#define CGU_FIN_SELECT_HPPLL0       0x5
+#define CGU_FIN_SELECT_HPPLL1       0x6
+#define CGU_FIN_SELECT_MAX          7
+
+/**********************************************************************
+* Register description of HP_MDEC
+**********************************************************************/
+#define CGU_HPLL_MDEC_MASK          0x1ffff
+/**********************************************************************
+* Register description of HP_NDEC
+**********************************************************************/
+#define CGU_HPLL_NDEC_MSK           0x3ff
+/**********************************************************************
+* Register description of HP_PDEC
+**********************************************************************/
+#define CGU_HPLL_PDEC_MSK           0x7f
+/**********************************************************************
+* Register description of HP_MODE
+**********************************************************************/
+#define CGU_HPLL_MODE_POR_VAL       0x6
+#define CGU_HPLL_MODE_CLKEN         _BIT(0)
+#define CGU_HPLL_MODE_SKEWEN        _BIT(1)
+#define CGU_HPLL_MODE_PD            _BIT(2)
+#define CGU_HPLL_MODE_DIRECTO       _BIT(3)
+#define CGU_HPLL_MODE_DIRECTI       _BIT(4)
+#define CGU_HPLL_MODE_FRM           _BIT(5)
+#define CGU_HPLL_MODE_BANDSEL       _BIT(6)
+#define CGU_HPLL_MODE_LIMUP_OFF     _BIT(7)
+#define CGU_HPLL_MODE_BYPASS        _BIT(8)
+
+/**********************************************************************
+* Register description of HP1_STATUS
+**********************************************************************/
+#define CGU_HPLL_STATUS_FR          _BIT(1)
+#define CGU_HPLL_STATUS_LOCK        _BIT(0)
+
+/**********************************************************************
+* Register description of HP_ACK & HP_REQ
+**********************************************************************/
+#define CGU_HPLL_ACK_P              _BIT(2)
+#define CGU_HPLL_ACK_N              _BIT(1)
+#define CGU_HPLL_ACK_M              _BIT(0)
+
+/**********************************************************************
+* Register description of HP1_INSELR
+**********************************************************************/
+#define CGU_HPLL_INSELR_MASK        0xf
+/**********************************************************************
+* Register description of HP1_INSELI
+**********************************************************************/
+#define CGU_HPLL_INSELI_MASK        0x3f
+/**********************************************************************
+* Register description of HP1_INSELP
+**********************************************************************/
+#define CGU_HPLL_INSELP_MASK        0x1f
+/**********************************************************************
+* Register description of HP1_SELR
+**********************************************************************/
+#define CGU_HPLL_SELR_MASK          0xf
+/**********************************************************************
+* Register description of HP1_SELI
+**********************************************************************/
+#define CGU_HPLL_SELI_MASK          0x3f
+/**********************************************************************
+* Register description of HP1_SELP
+**********************************************************************/
+#define CGU_HPLL_SELP_MASK          0x1f
+
+/***********************************************************************
+* Clock domain base id's
+***********************************************************************/
+typedef enum
+{
+  CGU_SB_SYS_BASE_ID = 0,
+  CGU_SB_BASE_FIRST = CGU_SB_SYS_BASE_ID,
+  CGU_SB_AHB0_APB0_BASE_ID,
+  CGU_SB_AHB0_APB1_BASE_ID,
+  CGU_SB_AHB0_APB2_BASE_ID,
+  CGU_SB_AHB0_APB3_BASE_ID,
+  CGU_SB_IPINT_BASE_ID,
+  CGU_SB_UARTCLK_BASE_ID,
+  CGU_SB_CLK1024FS_BASE_ID,
+  CGU_SB_I2SRX_BCK0_BASE_ID,
+  CGU_SB_I2SRX_BCK1_BASE_ID,
+  CGU_SB_SPI_CLK_BASE_ID,
+  CGU_SB_SYSCLK_O_BASE_ID,
+  CGU_SB_BASE_LAST = CGU_SB_SYSCLK_O_BASE_ID
+} CGU_DOMAIN_ID_T;
+
+/***********************************************************************
+// Clock id's (= clkid in address calculation)
+***********************************************************************/
+typedef enum
+{
+  /* domain 0 = SYS_BASE */
+  CGU_SB_APB0_CLK_ID = 0,
+  CGU_SYS_FIRST = CGU_SB_APB0_CLK_ID,
+  CGU_SB_APB1_CLK_ID,
+  CGU_SB_APB2_CLK_ID,
+  CGU_SB_APB3_CLK_ID,
+  CGU_SB_APB4_CLK_ID,
+  CGU_SB_AHB2INTC_CLK_ID,
+  CGU_SB_AHB0_CLK_ID,
+  CGU_SB_EBI_CLK_ID,
+  CGU_SB_DMA_PCLK_ID,
+  CGU_SB_DMA_CLK_GATED_ID,
+  CGU_SB_NANDFLASH_S0_CLK_ID,
+  CGU_SB_NANDFLASH_ECC_CLK_ID,
+  CGU_SB_NANDFLASH_AES_CLK_ID, /* valid on LPC3153 & LPC3154 only */
+  CGU_SB_NANDFLASH_NAND_CLK_ID,
+  CGU_SB_NANDFLASH_PCLK_ID,
+  CGU_SB_CLOCK_OUT_ID,
+  CGU_SB_ARM926_CORE_CLK_ID,
+  CGU_SB_ARM926_BUSIF_CLK_ID,
+  CGU_SB_ARM926_RETIME_CLK_ID,
+  CGU_SB_SD_MMC_HCLK_ID,
+  CGU_SB_SD_MMC_CCLK_IN_ID,
+  CGU_SB_USB_OTG_AHB_CLK_ID,
+  CGU_SB_ISRAM0_CLK_ID,
+  CGU_SB_RED_CTL_RSCLK_ID,
+  CGU_SB_ISRAM1_CLK_ID,
+  CGU_SB_ISROM_CLK_ID,
+  CGU_SB_MPMC_CFG_CLK_ID,
+  CGU_SB_MPMC_CFG_CLK2_ID,
+  CGU_SB_MPMC_CFG_CLK3_ID,
+  CGU_SB_INTC_CLK_ID,
+  CGU_SYS_LAST = CGU_SB_INTC_CLK_ID,
+
+  /* domain 1 = AHB0APB0_BASE */
+  CGU_SB_AHB2APB0_ASYNC_PCLK_ID,
+  CGU_AHB0APB0_FIRST = CGU_SB_AHB2APB0_ASYNC_PCLK_ID,
+  CGU_SB_EVENT_ROUTER_PCLK_ID,
+  CGU_SB_ADC_PCLK_ID,
+  CGU_SB_ADC_CLK_ID,
+  CGU_SB_WDOG_PCLK_ID,
+  CGU_SB_IOCONF_PCLK_ID,
+  CGU_SB_CGU_PCLK_ID,
+  CGU_SB_SYSCREG_PCLK_ID,
+  CGU_SB_OTP_PCLK_ID, /* valid on LPC315x series only */
+  CGU_SB_RNG_PCLK_ID,
+  CGU_AHB0APB0_LAST = CGU_SB_RNG_PCLK_ID,
+
+
+  /* domain 2 = AHB0APB1_BASE */
+  CGU_SB_AHB2APB1_ASYNC_PCLK_ID,
+  CGU_AHB0APB1_FIRST = CGU_SB_AHB2APB1_ASYNC_PCLK_ID,
+  CGU_SB_TIMER0_PCLK_ID,
+  CGU_SB_TIMER1_PCLK_ID,
+  CGU_SB_TIMER2_PCLK_ID,
+  CGU_SB_TIMER3_PCLK_ID,
+  CGU_SB_PWM_PCLK_ID,
+  CGU_SB_PWM_PCLK_REGS_ID,
+  CGU_SB_PWM_CLK_ID,
+  CGU_SB_I2C0_PCLK_ID,
+  CGU_SB_I2C1_PCLK_ID,
+  CGU_AHB0APB1_LAST = CGU_SB_I2C1_PCLK_ID,
+
+  /* domain 3 = AHB0APB2_BASE */
+  CGU_SB_AHB2APB2_ASYNC_PCLK_ID,
+  CGU_AHB0APB2_FIRST = CGU_SB_AHB2APB2_ASYNC_PCLK_ID,
+  CGU_SB_PCM_PCLK_ID,
+  CGU_SB_PCM_APB_PCLK_ID,
+  CGU_SB_UART_APB_CLK_ID,
+  CGU_SB_LCD_PCLK_ID,
+  CGU_SB_LCD_CLK_ID,
+  CGU_SB_SPI_PCLK_ID,
+  CGU_SB_SPI_PCLK_GATED_ID,
+  CGU_AHB0APB2_LAST = CGU_SB_SPI_PCLK_GATED_ID,
+
+  /* domain 4 = AHB0APB3_BASE */
+  CGU_SB_AHB2APB3_ASYNC_PCLK_ID,
+  CGU_AHB0APB3_FIRST = CGU_SB_AHB2APB3_ASYNC_PCLK_ID,
+  CGU_SB_I2S_CFG_PCLK_ID,
+  CGU_SB_EDGE_DET_PCLK_ID,
+  CGU_SB_I2STX_FIFO_0_PCLK_ID,
+  CGU_SB_I2STX_IF_0_PCLK_ID,
+  CGU_SB_I2STX_FIFO_1_PCLK_ID,
+  CGU_SB_I2STX_IF_1_PCLK_ID,
+  CGU_SB_I2SRX_FIFO_0_PCLK_ID,
+  CGU_SB_I2SRX_IF_0_PCLK_ID,
+  CGU_SB_I2SRX_FIFO_1_PCLK_ID,
+  CGU_SB_I2SRX_IF_1_PCLK_ID,
+  CGU_SB_RSVD69_ID,
+  CGU_SB_AHB2APB3_RSVD_ID,
+  CGU_AHB0APB3_LAST = CGU_SB_AHB2APB3_RSVD_ID,
+
+  /* domain 5 = PCM_BASE */
+  CGU_SB_PCM_CLK_IP_ID,
+  CGU_PCM_FIRST = CGU_SB_PCM_CLK_IP_ID,
+  CGU_PCM_LAST = CGU_SB_PCM_CLK_IP_ID,
+
+  /* domain 6 = UART_BASE */
+  CGU_SB_UART_U_CLK_ID,
+  CGU_UART_FIRST = CGU_SB_UART_U_CLK_ID,
+  CGU_UART_LAST = CGU_SB_UART_U_CLK_ID,
+
+  /* domain 7 = CLK1024FS_BASE */
+  CGU_SB_I2S_EDGE_DETECT_CLK_ID,
+  CGU_CLK1024FS_FIRST = CGU_SB_I2S_EDGE_DETECT_CLK_ID,
+  CGU_SB_I2STX_BCK0_N_ID,
+  CGU_SB_I2STX_WS0_ID,
+  CGU_SB_I2STX_CLK0_ID,
+  CGU_SB_I2STX_BCK1_N_ID,
+  CGU_SB_I2STX_WS1_ID,
+  CGU_SB_CLK_256FS_ID,
+  CGU_SB_I2SRX_BCK0_N_ID,
+  CGU_SB_I2SRX_WS0_ID,
+  CGU_SB_I2SRX_BCK1_N_ID,
+  CGU_SB_I2SRX_WS1_ID,
+  CGU_SB_RSVD84_ID,
+  CGU_SB_RSVD85_ID,
+  CGU_SB_RSVD86_ID,
+  CGU_CLK1024FS_LAST = CGU_SB_RSVD86_ID,
+
+  /* domain 8 = BCK0_BASE */
+  CGU_SB_I2SRX_BCK0_ID,
+  CGU_I2SRX_BCK0_FIRST = CGU_SB_I2SRX_BCK0_ID,
+  CGU_I2SRX_BCK0_LAST = CGU_SB_I2SRX_BCK0_ID,
+
+  /* domain 9 = BCK1_BASE */
+  CGU_SB_I2SRX_BCK1_ID,
+  CGU_I2SRX_BCK1_FIRST = CGU_SB_I2SRX_BCK1_ID,
+  CGU_I2SRX_BCK1_LAST = CGU_SB_I2SRX_BCK1_ID,
+
+  /* domain 10 = SPI_BASE */
+  CGU_SB_SPI_CLK_ID,
+  CGU_SPI_FIRST = CGU_SB_SPI_CLK_ID,
+  CGU_SB_SPI_CLK_GATED_ID,
+  CGU_SPI_LAST = CGU_SB_SPI_CLK_GATED_ID,
+
+  /* domain 11 = SYSCLKO_BASE */
+  CGU_SB_SYSCLK_O_ID,
+  CGU_SYSCLK_O_FIRST = CGU_SB_SYSCLK_O_ID,
+  CGU_SYSCLK_O_LAST = CGU_SB_SYSCLK_O_ID,
+
+  CGU_SB_INVALID_CLK_ID = -1
+} CGU_CLOCK_ID_T;
+
+
+/***********************************************************************
+* CGU driver defines - MACROS & constants
+**********************************************************************/
+#define CGU_INVALID_ID  0xFFFF
+
+/* Clocks which which need wake_en set. These are system clocks not
+ * managed by individual drivers. All other clocks should be disabled
+ * at startup.
+ */
+#define CGU_WKE_CLKS_0_31   ( _BIT(CGU_SB_APB0_CLK_ID) | _BIT(CGU_SB_APB1_CLK_ID) | \
+                              _BIT(CGU_SB_APB2_CLK_ID) | _BIT(CGU_SB_APB3_CLK_ID) | _BIT(CGU_SB_APB4_CLK_ID) | \
+                              _BIT(CGU_SB_AHB2INTC_CLK_ID) | _BIT(CGU_SB_AHB0_CLK_ID) | \
+                              _BIT(CGU_SB_EBI_CLK_ID) | _BIT(CGU_SB_DMA_PCLK_ID) | _BIT(CGU_SB_DMA_CLK_GATED_ID) | \
+                              _BIT(CGU_SB_ARM926_CORE_CLK_ID) | _BIT(CGU_SB_ARM926_BUSIF_CLK_ID) | \
+                              _BIT(CGU_SB_ARM926_RETIME_CLK_ID) | _BIT(CGU_SB_ISRAM0_CLK_ID) | \
+                              _BIT(CGU_SB_ISRAM1_CLK_ID) | _BIT(CGU_SB_ISROM_CLK_ID) | \
+                              _BIT(CGU_SB_MPMC_CFG_CLK_ID) | _BIT(CGU_SB_MPMC_CFG_CLK2_ID) | _BIT(CGU_SB_MPMC_CFG_CLK3_ID) | \
+                              _BIT(CGU_SB_INTC_CLK_ID) | _BIT(CGU_SB_AHB2APB0_ASYNC_PCLK_ID) | \
+                              _BIT(CGU_SB_EVENT_ROUTER_PCLK_ID) /*| _BIT(CGU_SB_CLOCK_OUT_ID)*/)
+
+#define CGU_WKE_CLKS_32_63 ( _BIT(CGU_SB_IOCONF_PCLK_ID - 32) | _BIT(CGU_SB_CGU_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_SYSCREG_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_TIMER0_PCLK_ID - 32) )
+
+
+#define CGU_WKE_CLKS_64_92 ( 0 )
+
+
+/***********************************************************************
+* CGU driver enumerations
+**********************************************************************/
+/* Possible HPLL ids */
+typedef enum {CGU_HPLL0_ID, CGU_HPLL1_ID} CGU_HPLL_ID_T;
+
+/* CGU soft reset module ID enumerations */
+typedef enum
+{
+  APB0_RST_SOFT = 0,
+  AHB2APB0_PNRES_SOFT,
+  APB1_RST_SOFT,
+  AHB2APB1_PNRES_SOFT,
+  APB2_RESETN_SOFT,
+  AHB2APB2_PNRES_SOFT,
+  APB3_RESETN_SOFT,
+  AHB2APB3_PNRES_SOFT,
+  APB4_RESETN_SOFT,
+  AHB2INTC_RESETN_SOFT,
+  AHB0_RESETN_SOFT,
+  EBI_RESETN_SOFT,
+  PCM_PNRES_SOFT,
+  PCM_RESET_N_SOFT,
+  PCM_RESET_ASYNC_N_SOFT,
+  TIMER0_PNRES_SOFT,
+  TIMER1_PNRES_SOFT,
+  TIMER2_PNRES_SOFT,
+  TIMER3_PNRES_SOFT,
+  ADC_PRESETN_SOFT,
+  ADC_RESETN_ADC10BITS_SOFT,
+  PWM_RESET_AN_SOFT,
+  UART_SYS_RST_AN_SOFT,
+  I2C0_PNRES_SOFT,
+  I2C1_PNRES_SOFT,
+  I2S_CFG_RST_N_SOFT,
+  I2S_NSOF_RST_N_SOFT,
+  EDGE_DET_RST_N_SOFT,
+  I2STX_FIFO_0_RST_N_SOFT,
+  I2STX_IF_0_RST_N_SOFT,
+  I2STX_FIFO_1_RST_N_SOFT,
+  I2STX_IF_1_RST_N_SOFT,
+  I2SRX_FIFO_0_RST_N_SOFT,
+  I2SRX_IF_0_RST_N_SOFT,
+  I2SRX_FIFO_1_RST_N_SOFT,
+  I2SRX_IF_1_RST_N_SOFT,
+  RSRVD_0_SOFT,
+  RSRVD_1_SOFT,
+  RSRVD_2_SOFT,
+  RSRVD_3_SOFT,
+  RSRVD_4_SOFT,
+  LCD_PNRES_SOFT,
+  SPI_PNRES_APB_SOFT,
+  SPI_PNRES_IP_SOFT,
+  DMA_PNRES_SOFT,
+  NANDFLASH_CTRL_ECC_RESET_N_SOFT,
+  NANDFLASH_CTRL_AES_RESET_N_SOFT,
+  NANDFLASH_CTRL_NAND_RESET_N_SOFT,
+  RNG_RESETN_SOFT,
+  SD_MMC_PNRES_SOFT,
+  SD_MMC_NRES_CCLK_IN_SOFT,
+  USB_OTG_AHB_RST_N_SOFT,
+  RED_CTL_RESET_N_SOFT,
+  AHB_MPMC_HRESETN_SOFT,
+  AHB_MPMC_REFRESH_RESETN_SOFT,
+  INTC_RESETN_SOFT
+} CGU_MOD_ID_T;
+
+/***********************************************************************
+* CGU driver structures
+**********************************************************************/
+/* CGU HPLL config settings structure type */
+typedef struct
+{
+  u32 fin_select;
+  u32 ndec;
+  u32 mdec;
+  u32 pdec;
+  u32 selr;
+  u32 seli;
+  u32 selp;
+  u32 mode;
+  u32 freq; /* in MHz for driver internal data */
+} CGU_HPLL_SETUP_T;
+
+/* CGU fractional divider settings structure type */
+typedef struct
+{
+  u8 stretch; /* Fractional divider stretch enable. */
+  u8 n;       /* Fractional divider nominal nominator */
+  u16 m;      /* Fractional divider nominal denominator */
+} CGU_FDIV_SETUP_T;
+
+/***********************************************************************
+* CGU driver functions
+**********************************************************************/
+/* Return the current base frequecy of the requested domain*/
+u32 cgu_get_base_freq(CGU_DOMAIN_ID_T baseid);
+
+/* Change the base frequency for the requested domain */
+void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel);
+
+/* Return the current frequecy of the requested clock*/
+u32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid);
+
+/* Change the sub-domain frequency for the requested clock */
+void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg);
+
+/* Configure the selected HPLL */
+void cgu_hpll_config(CGU_HPLL_ID_T id, CGU_HPLL_SETUP_T* pllsetup);
+
+/* enable / disable external enabling of the requested clock in CGU */
+void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable);
+
+/* frac divider config function */
+u32 cgu_fdiv_config(u32 fdId, CGU_FDIV_SETUP_T fdivCfg, u32 enable);
+
+/***********************************************************************
+* CGU driver inline (ANSI C99 based) functions
+**********************************************************************/
+/* enable / disable the requested clock in CGU */
+static inline void cgu_clk_en_dis(CGU_CLOCK_ID_T clkid, u32 enable)
+{
+  if (enable)
+  {
+    CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_RUN;
+  }
+  else
+  {
+    CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_RUN;
+  }
+
+}
+/* Issue a software reset to the requested module */
+static inline void cgu_soft_reset_module(CGU_MOD_ID_T modId)
+{
+  volatile u32 i;
+
+  /* clear and set the register */
+  CGU_CFG->resetn_soft[modId] = 0;
+  /* introduce some delay */
+  for (i = 0;i < 1000;i++);
+
+  CGU_CFG->resetn_soft[modId] = CGU_CONFIG_SOFT_RESET;
+}
+
+
+/***********************************************************************
+* Enable/Disable frequency input to the selected base
+**********************************************************************/
+static inline void cgu_endis_base_freq(CGU_DOMAIN_ID_T baseid, int en)
+{
+	/* Let us not disturb anything except STOP */
+	if (!en){
+		CGU_SB->base_scr[baseid] |= CGU_SB_SCR_STOP;
+	} else {
+		CGU_SB->base_scr[baseid] &= ~CGU_SB_SCR_STOP;
+	}
+}
+
+struct clk {
+	struct list_head node;
+	struct clk *parent;
+	u32 rate;
+	u32 usecount;
+
+	int (*set_rate) (struct clk *, unsigned long);
+	unsigned long (*round_rate) (struct clk *, unsigned long);
+	unsigned long (*get_rate) (struct clk *clk);
+	int (*enable) (struct clk *, int);
+
+	/* Register address and bit mask for simple clocks */
+	void __iomem *enable_reg;
+	u32 enable_mask;
+
+	CGU_CLOCK_ID_T id;
+};
+
+#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/constants.h b/arch/arm/mach-lpc31xx/include/mach/constants.h
new file mode 100644
index 0000000..81233a6
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/constants.h
@@ -0,0 +1,107 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/constants.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Manifest constants for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+/* ----- Globals */
+#define _BIT(n)	  ((1) << (n))
+/* shift bit field */
+#define _SBF(f,v) ((v) << (f))
+
+
+/***********************************************************************
+ * Physical bases
+ **********************************************************************/
+#define EVTR_PHYS         (0x13000000)
+#define ADC_PHYS          (0x13002000)
+#define WDT_PHYS          (0x13002400)
+#define SYS_PHYS          (0x13002800)
+#define GPIO_PHYS         (0x13003000)
+#define CGU_SB_PHYS       (0x13004000)
+#define CGU_CFG_PHYS      (0x13004c00)
+#define TIMER0_PHYS       (0x13008000)
+#define TIMER1_PHYS       (0x13008400)
+#define TIMER2_PHYS       (0x13008800)
+#define TIMER3_PHYS       (0x13008c00)
+#define I2C0_PHYS         (0x1300a000)
+#define I2C1_PHYS         (0x1300a400)
+#define UART_PHYS         (0x15001000)
+#define SPI_PHYS          (0x15002000)
+#define I2S_PHYS          (0x16000000)
+#define DMA_PHYS          (0x17000000)
+#define MPMC_PHYS         (0x17008000)
+#define SDMMC_PHYS        (0x18000000)
+#define USBOTG_PHYS       (0x19000000)
+#define INTC_PHYS         (0x60000000)
+#define NANDC_PHYS        (0x17000800)
+/***********************************************************************
+ * Memory definitions
+ **********************************************************************/
+#define EXT_SDRAM_PHYS    (0x30000000)
+#define EXT_SRAM0_PHYS    (0x20000000)
+#define EXT_SRAM1_PHYS    (0x20020000)
+#define ISRAM0_PHYS       (0x11028000)
+#define ISRAM0_LENGTH     (0x00018000)
+#define ISRAM1_PHYS       (0x11040000)
+#define ISRAM1_LENGTH     (0x00018000)
+
+/***********************************************************************
+ * XTAL clock definitions
+ **********************************************************************/
+#define XTAL_CLOCK        (12000000)
+#define FFAST_CLOCK       XTAL_CLOCK
+
+/* SoC CPU IO addressing */
+/* APB0 & APB1 address range*/
+#define IO_APB01_PHYS     (0x13000000)
+#define IO_APB01_SIZE     (0x0000B000)
+/* APB2 address range*/
+#define IO_APB2_PHYS      (0x15000000)
+#define IO_APB2_SIZE      (0x00003000)
+/* APB3 address range*/
+#define IO_APB3_PHYS      (0x16000000)
+#define IO_APB3_SIZE      (0x00001000)
+/* APB4 address range*/
+#define IO_APB4_PHYS      (0x17000000)
+#define IO_APB4_SIZE      (0x00001000)
+/* DMA registers address range*/
+#define IO_DMA_REG_PHYS  (DMA_PHYS)
+#define IO_DMA_REG_SIZE  (0x0000800)
+/* MPMC config registers address range*/
+#define IO_MPMC_CFG_PHYS  (0x17008000)
+#define IO_MPMC_CFG_SIZE  (0x00001000)
+/* SD/MMC address range*/
+#define IO_SDMMC_PHYS     (SDMMC_PHYS)
+#define IO_SDMMC_SIZE     (0x00001000)
+/* USB OTG address range*/
+#define IO_USB_PHYS       (USBOTG_PHYS)
+#define IO_USB_SIZE       (0x00001000)
+/* Interrupt controller address range*/
+#define IO_INTC_PHYS      (0x60000000)
+#define IO_INTC_SIZE      (0x00001000)
+/* NAND address range*/
+#define IO_NAND_PHYS	  (NANDC_PHYS)
+#define IO_NAND_SIZE	  (0x00000800)
+/* NAND buffer address range*/
+#define IO_NAND_BUF_PHYS  (0x70000000)
+#define IO_NAND_BUF_SIZE  (0x00001000)
+/* ISRAM address range*/
+#define IO_ISRAM0_PHYS     (0x11028000)
+#define IO_ISRAM0_SIZE     (0x00018000)
diff --git a/arch/arm/mach-lpc31xx/include/mach/debug-macro.S b/arch/arm/mach-lpc31xx/include/mach/debug-macro.S
new file mode 100644
index 0000000..46193e7
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/debug-macro.S
@@ -0,0 +1,26 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 2008 NXP semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include "hardware.h"
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst     \rx, #1                 @ MMU enabled?
+		mov     \rx, #0x15000000	    @ physical base
+		movne   \rx, \rx, lsr #4	    @ virtual base
+		orrne   \rx, \rx, #0xf0000000   @ virtual base
+		orr     \rx, \rx, #0x00001000   @ offset from base
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
+
diff --git a/arch/arm/mach-lpc31xx/include/mach/dma.h b/arch/arm/mach-lpc31xx/include/mach/dma.h
new file mode 100644
index 0000000..57c6034
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/dma.h
@@ -0,0 +1,383 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/dma.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * DMA register defines & structures for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#include <mach/constants.h>
+
+/***********************************************************************
+ * DMA register definitions
+ **********************************************************************/
+#define DMACH_SRC_ADDR(ch)    __REG (DMA_PHYS + ((ch) << 5) + 0x00)
+#define DMACH_DST_ADDR(ch)    __REG (DMA_PHYS + ((ch) << 5) + 0x04)
+#define DMACH_LEN(ch)         __REG (DMA_PHYS + ((ch) << 5) + 0x08)
+#define DMACH_CFG(ch)         __REG (DMA_PHYS + ((ch) << 5) + 0x0C)
+#define DMACH_EN(ch)          __REG (DMA_PHYS + ((ch) << 5) + 0x10)
+#define DMACH_TCNT(ch)        __REG (DMA_PHYS + ((ch) << 5) + 0x1C)
+#define DMACH_ALT_EN          __REG (DMA_PHYS + 0x400)
+#define DMACH_IRQ_STATUS      __REG (DMA_PHYS + 0x404)
+#define DMACH_IRQ_MASK        __REG (DMA_PHYS + 0x408)
+#define DMACH_ALT_PHYS(ch)    (DMA_PHYS + 0x200 + ((ch) << 4))
+#define DMACH_SOFT_INT_PHYS   (DMA_PHYS + 0x40C )
+
+/***********************************************************************
+* Channel CONFIGURATION register defines
+***********************************************************************/
+#define DMA_CFG_CIRC_BUF        _BIT(18)
+#define DMA_CFG_CMP_CH_EN       _BIT(17)
+#define DMA_CFG_CMP_CH_NR(n)    _SBF(13, ((n) & 0x7))
+#define DMA_CFG_INV_ENDIAN      _BIT(12)
+#define DMA_CFG_CIRC_BUF        _BIT(18)
+#define DMA_CFG_TX_WORD         _SBF(10, 0x00)
+#define DMA_CFG_TX_HWORD        _SBF(10, 0x01)
+#define DMA_CFG_TX_BYTE         _SBF(10, 0x02)
+#define DMA_CFG_TX_BURST        _SBF(10, 0x03)
+#define DMA_CFG_RD_SLV_NR(n)    _SBF(5, ((n) & 0x1F))
+#define DMA_CFG_WR_SLV_NR(n)    _SBF(0, ((n) & 0x1F))
+
+#define DMA_CFG_GET_CMP_CH_NR(n)    (((n) >> 13) & 0x7)
+#define DMA_CFG_GET_RD_SLV_NR(n)    (((n) >> 5) & 0x1F)
+#define DMA_CFG_GET_WR_SLV_NR(n)    ((n) & 0x1F)
+
+/* bit defines for interrupt status and mask register */
+#define DMA_IRQS_SOFT         _BIT(30)
+#define DMA_IRQS_ABORT        _BIT(31)
+
+/* DMA hardware constants */
+#define DMA_MAX_CHANNELS   12
+#define DMA_MAX_TRANSFERS  2047
+
+/*bit defines for configuration register */
+#define DMA_COMPANION_ENABLE _BIT()
+/* DMA slave number defines */
+#define DMA_SLV_PCM_TX     1
+#define DMA_SLV_PCM_RX     2
+#define DMA_SLV_UART_RX    3
+#define DMA_SLV_UART_TX    4
+#define DMA_SLV_I2C0       5
+#define DMA_SLV_I2C1       6
+#define DMA_SLV_I2STX0_L   7
+#define DMA_SLV_I2STX0_R   8
+#define DMA_SLV_I2STX1_L   9
+#define DMA_SLV_I2STX1_R   10
+#define DMA_SLV_I2SRX0_L   11
+#define DMA_SLV_I2SRX0_R   12
+#define DMA_SLV_I2SRX1_L   13
+#define DMA_SLV_I2SRX1_R   16
+#define DMA_SLV_LCD        17
+#define DMA_SLV_SPI_TX     18
+#define DMA_SLV_SPI_RX     19
+#define DMA_SLV_SDMMC      20
+#define DMA_CLV_INVALID    0xFF
+
+/* DMA transfer types */
+#define DMA_TRANSFER_WORD       0
+#define DMA_TRANSFER_HALF_WORD  1
+#define DMA_TRANSFER_BYTE       2
+#define DMA_TRANSFER_BURST      3
+
+/*
+ * Type of interrupt
+ */
+typedef enum 
+{
+	DMA_IRQ_FINISHED = 0,
+	DMA_IRQ_HALFWAY,
+	DMA_IRQ_SOFTINT,
+	DMA_IRQ_DMAABORT
+} dma_irq_type_t;
+ /* 
+ * DMA IRQ channel callback function
+ * parameters:
+ * 1st parameter - channel number for which an IRQ occured
+ * 2nd parameter - what type of interrupt has happened for a channel
+ * 3rd parameter - additional data (callback-specific context)
+ * 4th parameter - registers structure as passed to interrupt handler
+ */
+typedef void (*dma_cb_t)(int, dma_irq_type_t, void *);
+
+typedef union __dma_config_t{
+	struct {
+		unsigned int write_slave_nr:5;
+		unsigned int read_slave_nr:5;
+		unsigned int transfer_size:2;
+		unsigned int invert_endian:1;
+		unsigned int companion_channel:3;
+		unsigned int rsrvd0:1;
+		unsigned int companion_enable:1;
+		unsigned int circular_buffer:1;
+		unsigned int rsrvd1:12;
+	} s;
+	u32 value;
+} dma_config_t;
+
+/*
+ * DMA setup structure
+ */
+typedef struct dma_setup
+{
+	/* source address for transfer*/
+	u32 src_address;
+	/* source address for transfer*/
+	u32 dest_address;
+	/* toatl transfer length*/
+	u32 trans_length;
+	/* channel configuration */
+	//dma_config_t cfg;
+	u32 cfg;
+} dma_setup_t;
+
+/*
+ * SDMA scatter-gather list structure 
+ */
+typedef struct dma_sg_ll
+{
+	dma_setup_t setup;
+	u32 next_entry;
+} dma_sg_ll_t;
+
+
+/*
+ * API definition
+ */
+
+
+/*
+ * Program SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - channel number, obtained from dma_request_channel()
+ * 2nd parameter - ptr to the structure containing setup info for the channel
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_prog_channel (unsigned int, dma_setup_t   *);
+
+/*
+ * Request SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - free-form string identifier of channel. Must be non-NULL
+ * 2nd parameter - callback function to be invoked when an interrupt
+ *                 occurs for this channel
+ * 3rd parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function when it's invoked
+ *
+ * Returns: channel number on success, otherwise (negative) failure 
+ */
+int dma_request_channel (char *, dma_cb_t cb, void *);
+
+/*
+ * Request specific SDMA channel
+ *
+ * Function parameters:
+ * 1th parameter - specific channel number
+ * 2nd parameter - free-form string identifier of channel. Must be non-NULL
+ * 3rd parameter - callback function to be invoked when an interrupt
+ *                 occurs for this channel
+ * 4th parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function when it's invoked
+ *
+ *
+ * Returns: channel number on success, otherwise (negative) failure 
+ */
+int dma_request_specific_channel (int, char *, dma_cb_t cb, void *);
+
+
+/*
+ * Mask/unmask interrupts for the specified channel
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - 0 to unmask halfway-done interrupt, 1 to mask it
+ * 3rd parameter - 0 to unmask on-finish interrupt, 1 to mask it
+ *
+ * Returns: 0 on success, otherwise failure
+ */
+int dma_set_irq_mask(unsigned int, int, int);
+
+/*
+ * Start SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_start_channel (unsigned int);
+
+/*
+ * Stop SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_stop_channel (unsigned int);
+
+/*
+ * Release SDMA channel
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_release_channel (unsigned int);
+
+/*
+ * Read channel counter
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - ptr to the counter variable to be filled
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_read_counter (unsigned int, unsigned int *);
+
+/*
+ * Write channel counter
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - value to be written
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_write_counter (unsigned int, u32);
+
+/*
+ * Read current channel state
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - ptr to the source address variable to be filled
+ * 3rd parameter - ptr to the destination address variable to be filled
+ * 4th parameter - ptr to the transfer length variable to be filled
+ * 5th parameter - ptr to the configuration variable to be filled
+ * 6th parameter - ptr to the enable flag variable to be filled
+ * 7th parameter - ptr to the address counter variable to be filled
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_current_state    (unsigned int, unsigned int *, unsigned int *, unsigned int *, unsigned int  *, unsigned int  *, unsigned int  *);
+
+/*
+ * Request SDMA SG channel
+ * Reserves two consequent channels
+ *
+ * Function parameters:
+ * 1st parameter - free-form string identifier of channel.
+ * 2nd parameter - callback function to be invoked when an interrupt
+ *                 occurs for this channel
+ * 3rd parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function when it's invoked
+ * 4th parameter - flag to enable soft IRQ for this channel. Only 1 channel
+ *                 may be enabled with soft-irq.
+ *
+ * Callback parameters:
+ * 1st parameter - channel number for which an IRQ occured
+ * 2nd parameter - what type of interrupt has happened for a channel
+ * 3rd parameter - additional data (callback-specific context)
+ * 4th parameter - registers structure as passed to interrupt handler
+ *
+ * Returns: bigger channel number on success, otherwise negative error code
+ */
+int dma_request_sg_channel (char *, dma_cb_t cb, void *, int);
+
+/*
+ * Request specific SDMA SG channel (actually pair of channels)
+ * Reserves two consequent channels with the bigger number as requested
+ *
+ * Function parameters:
+ * 1st parameter - SDMA channel number
+ * 2nd parameter - free-form string identifier of channel.
+ * 3rd parameter - callback function to be invoked when an interrupt
+ *                 occurs for this channel
+ * 4th parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function when it's invoked
+ * 5th parameter - flag to enable soft IRQ for this channel. Only 1 channel
+ *                 may be enabled with soft-irq.
+ *
+ * Callback parameters:
+ * 1st parameter - channel number for which an IRQ occured
+ * 2nd parameter - what type of interrupt has happened for a channel
+ * 3rd parameter - additional data (callback-specific context)
+ * 4th parameter - registers structure as passed to interrupt handler
+ *
+ * Returns: bigger channel number on success, otherwise negative error code
+ */
+int dma_request_specific_sg_channel (int, char *, dma_cb_t cb, void *, int);
+
+/*
+ * Prepare SG list for programming into the SDMA controller
+ * This function is intended to set right companion channel for each
+ * entry in the list except the last one and to set the last entry of 
+ * the scatter-gather list according to one of the methods to define 
+ * the last entry described.
+ *
+ * Function parameters:
+ * 1st parameter - channel number returned by dma_request_sg_channel()
+ * 2nd parameter - ptr to the first scatter gather list entry
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_prepare_sg_list(int, dma_sg_ll_t *);
+
+/*
+ * Program SDMA SG channel
+ * This function is very similar to dma_prog_channel, but in this case
+ * the user has to supply only the linked-list address
+ *
+ * Function parameters:
+ * 1st parameter - channel number returned by dma_request_sg_channel() 
+ * 2nd parameter - physical ptr to the first entry in the linked list
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_prog_sg_channel(int, u32 );
+
+/*
+ * Release SDMA SG channel
+ *
+ * Function parameters:
+ * 1st parameter - channel number returned by dma_request_sg_channel()
+ *
+ * Returns: 0 on success, otherwise failure 
+ */
+int dma_release_sg_channel (unsigned int);
+
+/*
+ * Indicates if DMA channel is enabled
+ *
+ * Function parameters:
+ * 1st parameter - MA channel number
+ *
+ * Returns: 0 is disabled, otherwise !0
+ */
+int dma_channel_enabled(unsigned int);
+
+#endif				/* _ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-lpc31xx/include/mach/entry-macro.S b/arch/arm/mach-lpc31xx/include/mach/entry-macro.S
new file mode 100644
index 0000000..cabe6fa
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/entry-macro.S
@@ -0,0 +1,35 @@
+/*
+ * linux/arch/arm/mach-lpc313x/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for LPC313x-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro	get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro	arch_ret_to_user, tmp1, tmp2
+		.endm
+
+#define IRQ_VEC_OFF     0x100      /* Offset to IRQ number  */
+#define IRQ_STAT_OFF    0x200      /* Offset to IRQ status  */
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =io_p2v(INTC_PHYS)
+		@ Load offset & priority of the highest priority
+		@ interrupt pending.
+		ldr	\irqnr, [\base, #IRQ_VEC_OFF]
+		mov	\irqnr, \irqnr, lsr #3
+		/* Assuming INTC_IRQ_VEC_BASE is set 0 during init. 
+		   If not then add masking instruction below. uncomment the following.
+		and	\irqnr, \irqnr, #0x1F
+		*/
+		movs	\irqstat, \irqnr
+		.endm
diff --git a/arch/arm/mach-lpc31xx/include/mach/event_router.h b/arch/arm/mach-lpc31xx/include/mach/event_router.h
new file mode 100644
index 0000000..b26eff9
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/event_router.h
@@ -0,0 +1,201 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/event_router.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Event router defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#ifndef __ASM_ARCH_EVT_IRQS_H
+#define __ASM_ARCH_EVT_IRQS_H
+
+
+/* event PIN or internal signal */
+typedef enum _EVT_TYPE_
+{
+  EVT_ipint_int = 0,
+  EVT_mLCD_DB_0,
+  EVT_mLCD_DB_1,
+  EVT_mLCD_DB_2,
+  EVT_mLCD_DB_3,
+  EVT_mLCD_DB_4,
+  EVT_mLCD_DB_5,
+  EVT_mLCD_DB_6,
+  EVT_mLCD_DB_7,
+  EVT_mLCD_DB_8,
+  EVT_mLCD_DB_9,
+  EVT_mLCD_DB_10,
+  EVT_mLCD_DB_11,
+  EVT_mLCD_DB_12,
+  EVT_mLCD_DB_13,
+  EVT_mLCD_DB_14,
+  EVT_mLCD_DB_15,
+  EVT_mLCD_RS,
+  EVT_mLCD_CSB,
+  EVT_mLCD_E_RD,
+  EVT_mLCD_RW_WR,
+  EVT_mNAND_RYBN0,
+  EVT_mNAND_RYBN1,
+  EVT_mNAND_RYBN2,
+  EVT_mNAND_RYBN3,
+  EVT_EBI_D_0,
+  EVT_EBI_D_1,
+  EVT_EBI_D_2,
+  EVT_EBI_D_3,
+  EVT_EBI_D_4,
+  EVT_EBI_D_5,
+  EVT_EBI_D_6,
+  EVT_EBI_D_7,
+  EVT_EBI_D_8,
+  EVT_EBI_D_9,
+  EVT_EBI_D_10,
+  EVT_EBI_D_11,
+  EVT_EBI_D_12,
+  EVT_EBI_D_13,
+  EVT_EBI_D_14,
+  EVT_EBI_D_15,
+  EVT_EBI_NWE,
+  EVT_EBI_A_0_ALE,
+  EVT_EBI_A_1_CLE,
+  EVT_EBI_DQM_0_NOE,
+  EVT_EBI_NCAS_BLOUT_0,
+  EVT_EBI_NRAS_BLOUT_1,
+  EVT_GPIO1,
+  EVT_GPIO0,
+  EVT_GPIO2,
+  EVT_GPIO3,
+  EVT_GPIO4,
+  EVT_mGPIO5,
+  EVT_mGPIO6,
+  EVT_mGPIO7,
+  EVT_mGPIO8,
+  EVT_mGPIO9,
+  EVT_mGPIO10,
+  EVT_GPIO11,
+  EVT_GPIO12,
+  EVT_GPIO13,
+  EVT_GPIO14,
+  EVT_GPIO15,
+  EVT_GPIO16,
+  EVT_GPIO17,
+  EVT_GPIO18,
+  EVT_NAND_NCS_0,
+  EVT_NAND_NCS_1,
+  EVT_NAND_NCS_2,
+  EVT_NAND_NCS_3,
+  EVT_SPI_MISO,
+  EVT_SPI_MOSI,
+  EVT_SPI_CS_IN,
+  EVT_SPI_SCK,
+  EVT_SPI_CS_OUT0,
+  EVT_UART_RXD,
+  EVT_UART_TXD,
+  EVT_mUART_CTS_N,
+  EVT_mUART_RTS_N,
+  EVT_mI2STX_CLK0,
+  EVT_mI2STX_BCK0,
+  EVT_mI2STX_DATA0,
+  EVT_mI2STX_WS0,
+  EVT_I2SRX_BCK0,
+  EVT_I2SRX_DATA0,
+  EVT_I2SRX_WS0,
+  EVT_I2SRX_DATA1,
+  EVT_I2SRX_BCK1,
+  EVT_I2SRX_WS1,
+  EVT_I2STX_DATA1,
+  EVT_I2STX_BCK1,
+  EVT_I2STX_WS1,
+  EVT_CLK_256FS_O,
+  EVT_I2C_SDA1,
+  EVT_I2C_SCL1,
+  EVT_PWM_DATA,
+  EVT_AD_NINT_I,
+  EVT_PLAY_DET_I,
+  EVT_timer0_intct1,
+  EVT_timer1_intct1,
+  EVT_timer2_intct1,
+  EVT_timer3_intct1,
+  EVT_adc_int,
+  EVT_wdog_m0,
+  EVT_uart_rxd,
+  EVT_i2c0_scl_n,
+  EVT_i2c1_scl_n,
+  EVT_arm926_nfiq,
+  EVT_arm926_nirq,
+  EVT_MCI_DAT_0,
+  EVT_MCI_DAT_1,
+  EVT_MCI_DAT_2,
+  EVT_MCI_DAT_3,
+  EVT_MCI_DAT_4,
+  EVT_MCI_DAT_5,
+  EVT_MCI_DAT_6,
+  EVT_MCI_DAT_7,
+  EVT_MCI_CMD,
+  EVT_MCI_CLK,
+  EVT_USB_VBUS,
+  EVT_usb_otg_ahb_needclk,
+  EVT_usb_atx_pll_lock,
+  EVT_usb_otg_vbus_pwr_en,
+  EVT_USB_ID,
+  EVT_isram0_mrc_finished,
+  EVT_isram1_mrc_finished,
+  EVT_LAST
+} EVENT_T;
+
+/* External interrupt type enumerations */
+typedef enum
+{
+  EVT_ACTIVE_LOW,
+  EVT_ACTIVE_HIGH,
+  EVT_FALLING_EDGE,
+  EVT_RISING_EDGE,
+  EVT_BOTH_EDGE
+} EVENT_TYPE_T;
+
+/* Macros to compute the bank based on EVENT_T */
+#define EVT_GET_BANK(evt)   (((evt) >> 5) & 0x3)
+
+/* structure to map board IRQ to event pin */
+typedef struct {
+	u32 irq;
+	EVENT_T event_pin;
+	EVENT_TYPE_T type;
+} IRQ_EVENT_MAP_T;
+
+#define EVT_MAX_VALID_BANKS   4
+#define EVT_MAX_VALID_INT_OUT 5
+
+/* Activation polarity register defines */
+#define EVT_APR_HIGH    1
+#define EVT_APR_LOW     0
+#define EVT_APR_BANK0_DEF 0x00000001
+#define EVT_APR_BANK1_DEF 0x00000000
+#define EVT_APR_BANK2_DEF 0x00000000
+#define EVT_APR_BANK3_DEF 0x0FFFFFFC
+
+/* Activation type register defines */
+#define EVT_ATR_EDGE    1
+#define EVT_ATR_LEVEL   0
+#define EVT_ATR_BANK0_DEF 0x00000001
+#define EVT_ATR_BANK1_DEF 0x00000000
+#define EVT_ATR_BANK2_DEF 0x00000000
+#define EVT_ATR_BANK3_DEF 0x077FFFFC
+
+
+#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/gpio.h b/arch/arm/mach-lpc31xx/include/mach/gpio.h
new file mode 100644
index 0000000..cc52ad5
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/gpio.h
@@ -0,0 +1,252 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/gpio.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * GPIO defines & routines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef _LPC313X_GPIO_H
+#define _LPC313X_GPIO_H
+
+#include <linux/irqflags.h>
+#include <mach/hardware.h>
+
+#define ARCH_NR_GPIOS 1024
+
+#define GPIO_PORT_MASK  0x0FE0
+#define GPIO_PIN_MASK   0x001F
+
+
+#define GPIO_MGPIO9           (IOCONF_EBI_MCI | 0)  
+#define GPIO_MGPIO6           (IOCONF_EBI_MCI | 1)  
+#define GPIO_MLCD_DB_7        (IOCONF_EBI_MCI | 2)  
+#define GPIO_MLCD_DB_4        (IOCONF_EBI_MCI | 3)  
+#define GPIO_MLCD_DB_2        (IOCONF_EBI_MCI | 4)  
+#define GPIO_MNAND_RYBN0      (IOCONF_EBI_MCI | 5)  
+#define GPIO_MI2STX_CLK0      (IOCONF_EBI_MCI | 6)  
+#define GPIO_MI2STX_BCK0      (IOCONF_EBI_MCI | 7)  
+#define GPIO_EBI_A_1_CLE      (IOCONF_EBI_MCI | 8)  
+#define GPIO_EBI_NCAS_BLOUT   (IOCONF_EBI_MCI | 9)  
+#define GPIO_MLCD_DB_0        (IOCONF_EBI_MCI | 10) 
+#define GPIO_EBI_DQM_0_NOE    (IOCONF_EBI_MCI | 11) 
+#define GPIO_MLCD_CSB         (IOCONF_EBI_MCI | 12) 
+#define GPIO_MLCD_DB_1        (IOCONF_EBI_MCI | 13) 
+#define GPIO_MLCD_E_RD        (IOCONF_EBI_MCI | 14) 
+#define GPIO_MLCD_RS          (IOCONF_EBI_MCI | 15) 
+#define GPIO_MLCD_RW_WR       (IOCONF_EBI_MCI | 16) 
+#define GPIO_MLCD_DB_3        (IOCONF_EBI_MCI | 17) 
+#define GPIO_MLCD_DB_5        (IOCONF_EBI_MCI | 18) 
+#define GPIO_MLCD_DB_6        (IOCONF_EBI_MCI | 19) 
+#define GPIO_MLCD_DB_8        (IOCONF_EBI_MCI | 20) 
+#define GPIO_MLCD_DB_9        (IOCONF_EBI_MCI | 21) 
+#define GPIO_MLCD_DB_10       (IOCONF_EBI_MCI | 22) 
+#define GPIO_MLCD_DB_11       (IOCONF_EBI_MCI | 23) 
+#define GPIO_MLCD_DB_12       (IOCONF_EBI_MCI | 24) 
+#define GPIO_MLCD_DB_13       (IOCONF_EBI_MCI | 25) 
+#define GPIO_MLCD_DB_14       (IOCONF_EBI_MCI | 26) 
+#define GPIO_MLCD_DB_15       (IOCONF_EBI_MCI | 27) 
+#define GPIO_MGPIO5           (IOCONF_EBI_MCI | 28) 
+#define GPIO_MGPIO7           (IOCONF_EBI_MCI | 29) 
+#define GPIO_MGPIO8           (IOCONF_EBI_MCI | 30) 
+#define GPIO_MGPIO10          (IOCONF_EBI_MCI | 31) 
+                
+#define GPIO_MNAND_RYBN1      (IOCONF_EBI_I2STX_0 | 0) 
+#define GPIO_MNAND_RYBN2      (IOCONF_EBI_I2STX_0 | 1) 
+#define GPIO_MNAND_RYBN3      (IOCONF_EBI_I2STX_0 | 2) 
+#define GPIO_MUART_CTS_N      (IOCONF_EBI_I2STX_0 | 3) 
+#define GPIO_MUART_RTS_N      (IOCONF_EBI_I2STX_0 | 4) 
+#define GPIO_MI2STX_DATA0     (IOCONF_EBI_I2STX_0 | 5) 
+#define GPIO_MI2STX_WS0       (IOCONF_EBI_I2STX_0 | 6) 
+#define GPIO_EBI_NRAS_BLOUT   (IOCONF_EBI_I2STX_0 | 7) 
+#define GPIO_EBI_A_0_ALE      (IOCONF_EBI_I2STX_0 | 8) 
+#define GPIO_EBI_NWE          (IOCONF_EBI_I2STX_0 | 9) 
+                 
+#define GPIO_CGU_SYSCLK_O     (IOCONF_CGU | 0) 
+
+#define GPIO_I2SRX_BCK0       (IOCONF_I2SRX_0 | 0) 
+#define GPIO_I2SRX_DATA0      (IOCONF_I2SRX_0 | 1) 
+#define GPIO_I2SRX_WS0        (IOCONF_I2SRX_0 | 2) 
+                  
+#define GPIO_I2SRX_DATA1      (IOCONF_I2SRX_1 | 0) 
+#define GPIO_I2SRX_BCK1       (IOCONF_I2SRX_1 | 1) 
+#define GPIO_I2SRX_WS1        (IOCONF_I2SRX_1 | 2) 
+                  
+#define GPIO_I2STX_DATA1      (IOCONF_I2STX_1 | 0) 
+#define GPIO_I2STX_BCK1       (IOCONF_I2STX_1 | 1) 
+#define GPIO_I2STX_WS1        (IOCONF_I2STX_1 | 2) 
+#define GPIO_I2STX_256FS_O    (IOCONF_I2STX_1 | 3) 
+ 
+#define GPIO_EBI_D_9          (IOCONF_EBI | 0)  
+#define GPIO_EBI_D_10         (IOCONF_EBI | 1)  
+#define GPIO_EBI_D_11         (IOCONF_EBI | 2)  
+#define GPIO_EBI_D_12         (IOCONF_EBI | 3)  
+#define GPIO_EBI_D_13         (IOCONF_EBI | 4)  
+#define GPIO_EBI_D_14         (IOCONF_EBI | 5)  
+#define GPIO_EBI_D_4          (IOCONF_EBI | 6)  
+#define GPIO_EBI_D_0          (IOCONF_EBI | 7)  
+#define GPIO_EBI_D_1          (IOCONF_EBI | 8)  
+#define GPIO_EBI_D_2          (IOCONF_EBI | 9)  
+#define GPIO_EBI_D_3          (IOCONF_EBI | 10) 
+#define GPIO_EBI_D_5          (IOCONF_EBI | 11) 
+#define GPIO_EBI_D_6          (IOCONF_EBI | 12) 
+#define GPIO_EBI_D_7          (IOCONF_EBI | 13) 
+#define GPIO_EBI_D_8          (IOCONF_EBI | 14) 
+#define GPIO_EBI_D_15         (IOCONF_EBI | 15) 
+                  
+
+#define GPIO_GPIO1            (IOCONF_GPIO | 0)  
+#define GPIO_GPIO0            (IOCONF_GPIO | 1)  
+#define GPIO_GPIO2            (IOCONF_GPIO | 2)  
+#define GPIO_GPIO3            (IOCONF_GPIO | 3)  
+#define GPIO_GPIO4            (IOCONF_GPIO | 4)  
+#define GPIO_GPIO11           (IOCONF_GPIO | 5)  
+#define GPIO_GPIO12           (IOCONF_GPIO | 6)  
+#define GPIO_GPIO13           (IOCONF_GPIO | 7)  
+#define GPIO_GPIO14           (IOCONF_GPIO | 8)  
+#define GPIO_GPIO15           (IOCONF_GPIO | 9)  
+#define GPIO_GPIO16           (IOCONF_GPIO | 10) 
+#define GPIO_GPIO17           (IOCONF_GPIO | 11) 
+#define GPIO_GPIO18           (IOCONF_GPIO | 12) 
+#define GPIO_GPIO19           (IOCONF_GPIO | 13) 
+#define GPIO_GPIO20           (IOCONF_GPIO | 14) 
+                
+#define GPIO_I2C_SDA1         (IOCONF_I2C1 | 0) 
+#define GPIO_I2C_SCL1         (IOCONF_I2C1 | 1) 
+                          
+#define GPIO_SPI_MISO         (IOCONF_SPI | 0) 
+#define GPIO_SPI_MOSI         (IOCONF_SPI | 1) 
+#define GPIO_SPI_CS_IN        (IOCONF_SPI | 2) 
+#define GPIO_SPI_SCK          (IOCONF_SPI | 3) 
+#define GPIO_SPI_CS_OUT0      (IOCONF_SPI | 4) 
+                 
+#define GPIO_NAND_NCS_3       (IOCONF_NAND_CTRL | 0)
+#define GPIO_NAND_NCS_0       (IOCONF_NAND_CTRL | 1)
+#define GPIO_NAND_NCS_1       (IOCONF_NAND_CTRL | 2)
+#define GPIO_NAND_NCS_2       (IOCONF_NAND_CTRL | 3)
+                 
+#define GPIO_PWM_DATA         (IOCONF_PWM | 0)
+                  
+#define GPIO_UART_RXD         (IOCONF_UART | 0)
+#define GPIO_UART_TXD         (IOCONF_UART | 1)
+                
+extern int lpc313x_gpio_direction_output(unsigned gpio, int value);
+
+static inline int lpc313x_gpio_direction_input(unsigned gpio)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_RESET(port) = pin; 
+	GPIO_M0_RESET(port) = pin;
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+static inline int lpc313x_gpio_ip_driven(unsigned gpio)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_RESET(port) = pin; 
+	GPIO_M0_SET(port) = pin;
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+
+static inline int lpc313x_gpio_get_value(unsigned gpio)
+{
+	return (GPIO_STATE(gpio & GPIO_PORT_MASK) & (1 << (gpio & GPIO_PIN_MASK)));
+}
+
+static inline void lpc313x_gpio_set_value(unsigned gpio, int value)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_SET(port) = pin; 
+
+	if(value) {
+		GPIO_M0_SET(port) = pin;
+	} else {
+		GPIO_M0_RESET(port) = pin;
+	}
+
+	raw_local_irq_restore(flags);
+}
+
+
+#ifdef CONFIG_GPIOLIB
+
+#include <asm-generic/gpio.h>
+
+#else
+               
+/*-------------------------------------------------------------------------*/
+
+/* Wrappers for "new style" GPIO calls. These calls LPC313x specific versions
+ * to allow future extension of GPIO logic.
+*/
+static inline  int gpio_direction_input(unsigned gpio)
+{
+	return lpc313x_gpio_direction_input(gpio);
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	lpc313x_gpio_set_value(gpio, value);
+	return 0;
+}
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return lpc313x_gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	lpc313x_gpio_set_value(gpio, value);
+}
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+/**
+ * FIXME: It is assumed that freeing a gpio pin
+ * will set it to the default mode. eh?
+ **/
+static inline void gpio_free( unsigned gpio)
+{
+	lpc313x_gpio_ip_driven(gpio);
+}
+int gpio_is_valid(unsigned pin);
+#endif
+
+
+#endif /*_LPC313X_GPIO_H*/
diff --git a/arch/arm/mach-lpc31xx/include/mach/hardware.h b/arch/arm/mach-lpc31xx/include/mach/hardware.h
new file mode 100644
index 0000000..ba9e22b
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/hardware.h
@@ -0,0 +1,79 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/hardware.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Hardware register defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#include "constants.h"
+
+
+/* macros to convert phys to virtual & virtual to phys memory location*/
+#define io_p2v(x) (0xf0000000 | (((x) & 0xff000000) >> 4) | ((x) & 0x000fffff))
+#define io_v2p(x) (             (((x) & 0x0ff00000) << 4) | ((x) & 0x000fffff))
+
+#define MASK_AND_SET(v,m,s)	(v) = ((v)&~(m))|(s)
+
+#ifdef __ASSEMBLY__
+
+# define __REG(x)	io_p2v(x)
+# define __PREG(x)	io_v2p(x)
+
+#else
+
+# if 0
+#  define __REG(x)	(*((volatile u32 *)io_p2v(x)))
+# else
+/*
+ * This __REG() version gives the same results as the one above,  except
+ * that we are fooling gcc somehow so it generates far better and smaller
+ * assembly code for access to contigous registers.  
+ */
+#include <asm/types.h>
+typedef struct { volatile u32 offset[4096]; } __regbase;
+# define __REGP(x)	((__regbase *)((x)&~4095))->offset[((x)&4095)>>2]
+# define __REG(x)	__REGP(io_p2v(x))
+typedef struct { volatile u16 offset[4096]; } __regbase16;
+# define __REGP16(x)	((__regbase16 *)((x)&~4095))->offset[((x)&4095)>>1]
+# define __REG16(x)	__REGP16(io_p2v(x))
+typedef struct { volatile u8 offset[4096]; } __regbase8;
+# define __REGP8(x)	((__regbase8 *)((x)&~4095))->offset[(x)&4095]
+# define __REG8(x)	__REGP8(io_p2v(x))
+#endif /* 0 */
+
+# define __REG2(x,y)	\
+	( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+				  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+
+# define __PREG(x)	(io_v2p((u32)&(x)))
+
+/* include CGU header */
+#include "clock.h"
+
+#endif /*__ASSEMBLY__ */
+
+
+#include "registers.h"
+
+#endif
+
diff --git a/arch/arm/mach-lpc31xx/include/mach/i2c.h b/arch/arm/mach-lpc31xx/include/mach/i2c.h
new file mode 100644
index 0000000..24aaaa6
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/i2c.h
@@ -0,0 +1,76 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/i2c.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * LPC313x-specific tweaks for NXP I2C block
+ *
+ * Based on mach-pnx4008/include/mach/i2c.h by Vitaly Wool <vwool@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_I2C_H__
+#define __ASM_ARCH_I2C_H__
+
+enum {
+	mstatus_tdi = 0x00000001,
+	mstatus_afi = 0x00000002,
+	mstatus_nai = 0x00000004,
+	mstatus_drmi = 0x00000008,
+	mstatus_active = 0x00000020,
+	mstatus_scl = 0x00000040,
+	mstatus_sda = 0x00000080,
+	mstatus_rff = 0x00000100,
+	mstatus_rfe = 0x00000200,
+	mstatus_tff = 0x00000400,
+	mstatus_tfe = 0x00000800,
+};
+
+enum {
+	mcntrl_tdie = 0x00000001,
+	mcntrl_afie = 0x00000002,
+	mcntrl_naie = 0x00000004,
+	mcntrl_drmie = 0x00000008,
+	mcntrl_rffie = 0x00000020,
+	mcntrl_daie = 0x00000040,
+	mcntrl_tffie = 0x00000080,
+	mcntrl_reset = 0x00000100,
+};
+
+enum {
+	rw_bit = 1 << 0,
+	start_bit = 1 << 8,
+	stop_bit = 1 << 9,
+};
+
+#define I2C_REG_RX(a)	((a)->ioaddr)		/* Rx FIFO reg (RO) */
+#define I2C_REG_TX(a)	((a)->ioaddr)		/* Tx FIFO reg (WO) */
+#define I2C_REG_STS(a)	((a)->ioaddr + 0x04)	/* Status reg (RO) */
+#define I2C_REG_CTL(a)	((a)->ioaddr + 0x08)	/* Ctl reg */
+#define I2C_REG_CKH(a)	((a)->ioaddr + 0x0C)	/* Clock divider high */
+#define I2C_REG_CKL(a)	((a)->ioaddr + 0x10)	/* Clock divider low */
+#define I2C_REG_ADR(a)	((a)->ioaddr + 0x14)	/* I2C address */
+#define I2C_REG_RFL(a)	((a)->ioaddr + 0x18)	/* Rx FIFO level (RO) */
+#define I2C_REG_TFL(a)	((a)->ioaddr + 0x1c)	/* Tx FIFO level (RO) */
+#define I2C_REG_RXB(a)	((a)->ioaddr + 0x20)	/* Num of bytes Rx-ed (RO) */
+#define I2C_REG_TXB(a)	((a)->ioaddr + 0x24)	/* Num of bytes Tx-ed (RO) */
+#define I2C_REG_TXS(a)	((a)->ioaddr + 0x28)	/* Tx slave FIFO (RO) */
+#define I2C_REG_STFL(a)	((a)->ioaddr + 0x2c)	/* Tx slave FIFO level (RO) */
+
+#define I2C_CHIP_NAME		"LPC313x-I2C"
+
+#endif				/* __ASM_ARCH_I2C_H___ */
diff --git a/arch/arm/mach-lpc31xx/include/mach/io.h b/arch/arm/mach-lpc31xx/include/mach/io.h
new file mode 100644
index 0000000..33dc8d2
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/io.h
@@ -0,0 +1,33 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/io.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * IO space defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <mach/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		((void __iomem *)(a))
+#define __mem_pci(a)	(a)
+
+#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/irqs.h b/arch/arm/mach-lpc31xx/include/mach/irqs.h
new file mode 100644
index 0000000..76cfd32
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/irqs.h
@@ -0,0 +1,198 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/irqs.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  IRQ defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+
+
+# define IRQ_EVT_ROUTER0  1        /*interrupts from Event router 0*/
+# define IRQ_EVT_ROUTER1  2        /*interrupts from Event router 1*/
+# define IRQ_EVT_ROUTER2  3        /*interrupts from Event router 2*/
+# define IRQ_EVT_ROUTER3  4        /*interrupts from Event router 3*/
+# define IRQ_TIMER0       5        /*Timer 0 IRQ */
+# define IRQ_TIMER1       6        /*Timer 1 IRQ */
+# define IRQ_TIMER2       7        /*Timer 2 IRQ */
+# define IRQ_TIMER3       8        /*Timer 3 IRQ */
+# define IRQ_ADC          9        /*10bit ADC irq*/
+# define IRQ_UART         10       /*UART irq */
+# define IRQ_I2C0         11       /*I2C 0 IRQ */
+# define IRQ_I2C1         12       /*I2C 1 IRQ */
+# define IRQ_I2S0_OUT     13       /*I2S 0 out IRQ */
+# define IRQ_I2S1_OUT     14       /*I2S 1 out IRQ */
+# define IRQ_I2S0_IN      15       /*I2S 0 IN IRQ */
+# define IRQ_I2S1_IN      16       /*I2S 1 IN IRQ */
+# define IRQ_LCD          18       /*LCD irq */
+# define IRQ_SPI_SMS      19       /*SPI SMS IRQ */
+# define IRQ_SPI_TX       20       /*SPI Transmit IRQ */
+# define IRQ_SPI_RX       21       /*SPI Receive IRQ */
+# define IRQ_SPI_OVR      22       /*SPI overrun IRQ */
+# define IRQ_SPI          23       /*SPI interrupt IRQ */
+# define IRQ_DMA          24       /*DMA irq */
+# define IRQ_NAND_FLASH   25       /*NAND flash irq */
+# define IRQ_MCI          26       /*MCI irq */
+# define IRQ_USB          27       /*USB irq */
+# define IRQ_ISRAM0       28       /*ISRAM0 irq */
+# define IRQ_ISRAM1       29       /*ISRAM1 irq */
+
+
+# define NR_IRQ_CPU	  30	/* IRQs directly recognized by CPU */
+
+#define IRQ_EVT_START   NR_IRQ_CPU
+
+/* System specific IRQs */
+#include "event_router.h"
+
+/* Other chip IRQs routed through event router.
+ * These IRQs should be treated as board IRQs but they are
+ * common for all boards.
+ */
+#define IRQ_WDT        30  /* Watchdog interrupt */
+#define IRQ_VBUS_EN    31  /* VBUS power enable */
+#define IRQ_VBUS_OVRC  32  /* Detect VBUS over current - Host mode */
+#define IRQ_USB_ID     33  /* Detect ID pin change - OTG */
+
+#define _INTERNAL_IRQ_EVENT_MAP	\
+	{IRQ_WDT, EVT_wdog_m0, EVT_RISING_EDGE}, \
+	{IRQ_VBUS_EN, EVT_usb_otg_vbus_pwr_en, EVT_FALLING_EDGE}, \
+	{IRQ_VBUS_OVRC, EVT_USB_VBUS, EVT_FALLING_EDGE}, \
+	{IRQ_USB_ID, EVT_USB_ID, EVT_ACTIVE_LOW}, \
+
+#if defined(CONFIG_LPC3152_AD)
+/* For chips with analog die there are some more AD events routed
+ * through event router.
+ */
+#define IRQ_RTC	        34
+#define IRQ_PLAY        35
+#define NR_IRQ_CHIP_EVT	6
+
+#define AD_IRQ_EVENT_MAP	\
+	{IRQ_RTC, EVT_AD_NINT_I, EVT_ACTIVE_LOW}, \
+	{IRQ_PLAY, EVT_PLAY_DET_I, EVT_ACTIVE_HIGH}, \
+
+#define CHIP_IRQ_EVENT_MAP   _INTERNAL_IRQ_EVENT_MAP \
+	AD_IRQ_EVENT_MAP 
+
+#else
+#define CHIP_IRQ_EVENT_MAP   _INTERNAL_IRQ_EVENT_MAP
+#define NR_IRQ_CHIP_EVT	     4
+#endif
+
+/* now compute the board start IRQ number */
+#define IRQ_BOARD_START   (NR_IRQ_CPU + NR_IRQ_CHIP_EVT)
+
+/* Route all internal chip events to IRQ_EVT_ROUTER0 */
+#define IRQ_EVTR0_START        IRQ_EVT_START
+#define IRQ_EVTR0_END          (IRQ_BOARD_START - 1)
+
+
+#if defined (CONFIG_MACH_VAL3153) 
+
+# define IRQ_CS8900_ETH_INT  IRQ_BOARD_START	/* Ethernet chip */
+# define IRQ_SDMMC_CD0       (IRQ_BOARD_START + 1)	/* SD card detect */
+# define IRQ_SDMMC_CD1       (IRQ_BOARD_START + 2)	/* SD card detect */
+# define NR_IRQ_BOARD        3
+
+/* now define board irq to event pin map */
+#define BOARD_IRQ_EVENT_MAP	{ \
+	CHIP_IRQ_EVENT_MAP \
+	{IRQ_CS8900_ETH_INT, EVT_GPIO16, EVT_ACTIVE_HIGH}, \
+	{IRQ_SDMMC_CD0, EVT_GPIO12, EVT_ACTIVE_HIGH}, \
+	{IRQ_SDMMC_CD1, EVT_GPIO13, EVT_ACTIVE_HIGH}, \
+	}
+/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
+   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding 
+   group triggers.
+*/
+#define IRQ_EVTR1_START        IRQ_CS8900_ETH_INT
+#define IRQ_EVTR1_END          IRQ_CS8900_ETH_INT
+#define IRQ_EVTR2_START        IRQ_SDMMC_CD0
+#define IRQ_EVTR2_END          IRQ_SDMMC_CD0
+#define IRQ_EVTR3_START        IRQ_SDMMC_CD1
+#define IRQ_EVTR3_END          IRQ_SDMMC_CD1
+
+
+#elif defined (CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
+# define IRQ_DM9000_ETH_INT   IRQ_BOARD_START	/* Ethernet chip */
+# define IRQ_SDMMC_CD         (IRQ_BOARD_START + 1)	/* SD card detect */
+# define IRQ_EA_VBUS_OVRC     (IRQ_BOARD_START + 2)	/* Over current indicator */
+# define IRQ_PENDOWN	      (IRQ_BOARD_START + 3)	/* Pendown from touch screen */
+# define NR_IRQ_BOARD         4
+
+/* now define board irq to event pin map */
+#define BOARD_IRQ_EVENT_MAP	{ \
+	CHIP_IRQ_EVENT_MAP \
+	{IRQ_DM9000_ETH_INT, EVT_mNAND_RYBN3, EVT_ACTIVE_HIGH}, \
+	{IRQ_SDMMC_CD, EVT_mI2STX_BCK0, EVT_ACTIVE_LOW}, \
+	{IRQ_EA_VBUS_OVRC, EVT_I2SRX_WS0, EVT_ACTIVE_LOW}, \
+	{IRQ_PENDOWN, EVT_GPIO4, EVT_ACTIVE_HIGH}, \
+	}
+/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
+   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding 
+   group triggers.
+*/
+#define IRQ_EVTR1_START        IRQ_DM9000_ETH_INT
+#define IRQ_EVTR1_END          IRQ_DM9000_ETH_INT
+#define IRQ_EVTR2_START        IRQ_SDMMC_CD
+#define IRQ_EVTR2_END          IRQ_SDMMC_CD
+#define IRQ_EVTR3_START        IRQ_EA_VBUS_OVRC
+#define IRQ_EVTR3_END          IRQ_PENDOWN
+
+#elif defined (CONFIG_MACH_VAL3154)
+# define IRQ_SDMMC_CD	 IRQ_BOARD_START 	/* SD card detect */
+# define NR_IRQ_BOARD	 1
+
+/* now define board irq to event pin map */
+#define BOARD_IRQ_EVENT_MAP	{ \
+	CHIP_IRQ_EVENT_MAP \
+	{IRQ_SDMMC_CD, EVT_mI2STX_BCK0, EVT_ACTIVE_LOW}, \
+	}
+/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
+   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding 
+   group triggers.
+*/
+#define IRQ_EVTR1_START        IRQ_SDMMC_CD
+#define IRQ_EVTR1_END          IRQ_SDMMC_CD
+#define IRQ_EVTR2_START        0
+#define IRQ_EVTR2_END          0
+#define IRQ_EVTR3_START        0
+#define IRQ_EVTR3_END          0
+
+#else
+# define NR_IRQ_BOARD          0
+#define IRQ_EVTR0_START        0
+#define IRQ_EVTR0_END          0
+#define IRQ_EVTR1_START        0
+#define IRQ_EVTR1_END          0
+#define IRQ_EVTR2_START        0
+#define IRQ_EVTR2_END          0
+#define IRQ_EVTR3_START        0
+#define IRQ_EVTR3_END          0
+
+#endif
+
+
+#define NR_IRQS		(NR_IRQ_CPU + NR_IRQ_CHIP_EVT + NR_IRQ_BOARD)
+
+#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h b/arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h
new file mode 100644
index 0000000..9c5b68a
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h
@@ -0,0 +1,25 @@
+/*
+ * arch/arm/mach-lpc313x/include/mach/lpc315x_ad.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#ifndef __MACH_LPC315X_AD_H
+#define __MACH_LPC315X_AD_H
+
+/* Get I2C client structure function */
+extern struct i2c_client *lpc315x_ad_get_i2c_client_struct(void);
+
+#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/memory.h b/arch/arm/mach-lpc31xx/include/mach/memory.h
new file mode 100644
index 0000000..049b534
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/memory.h
@@ -0,0 +1,29 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/memory.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  Memory defines for machines with LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET	UL(0x30000000)
+
+
+#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/registers.h b/arch/arm/mach-lpc31xx/include/mach/registers.h
new file mode 100644
index 0000000..45af7fc
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/registers.h
@@ -0,0 +1,658 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/registers.h
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Register defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_REGISTERS_H
+#define __ASM_ARCH_REGISTERS_H
+
+
+/***********************************************************************
+ * Interrupt controller register definitions
+ **********************************************************************/
+#define INTC_IRQ_PRI_MASK     __REG(INTC_PHYS + 0x000)
+#define INTC_FIQ_PRI_MASK     __REG(INTC_PHYS + 0x004)
+#define INTC_IRQ_VEC_BASE     __REG(INTC_PHYS + 0x100)
+#define INTC_FIQ_VEC_BASE     __REG(INTC_PHYS + 0x104)
+#define INTC_REQ_REG(irq)     __REG(INTC_PHYS + 0x400 + ((irq) << 2))
+
+#define INTC_REQ_PEND         _BIT(31)
+#define INTC_REQ_SET_SWINT    _BIT(30)
+#define INTC_REQ_CLR_SWINT    _BIT(29)
+#define INTC_REQ_WE_PRIO_LVL  _BIT(28)
+#define INTC_REQ_WE_TARGET    _BIT(27)
+#define INTC_REQ_WE_ENABLE    _BIT(26)
+#define INTC_REQ_WE_ACT_LOW   _BIT(25)
+#define INTC_REQ_ACT_LOW      _BIT(17)
+#define INTC_REQ_ENABLE       _BIT(16)
+#define INTC_REQ_TARGET(n)    _SBF(8, ((n) & 0x3F))
+#define INTC_REQ_PRIO_LVL(n)  ((n) & 0xFF)
+#define INTC_REQ_TARGET_IRQ   (INTC_REQ_WE_TARGET)
+#define INTC_REQ_TARGET_FIQ   (INTC_REQ_WE_TARGET | _BIT(8))
+
+/***********************************************************************
+ * Event router register definitions
+ **********************************************************************/
+#define EVRT_INT_PEND(bank)  __REG (EVTR_PHYS + 0xC00 + ((bank) << 2))
+#define EVRT_INT_CLR(bank)   __REG (EVTR_PHYS + 0xC20 + ((bank) << 2))
+#define EVRT_INT_SET(bank)   __REG (EVTR_PHYS + 0xC40 + ((bank) << 2))
+#define EVRT_MASK(bank)      __REG (EVTR_PHYS + 0xC60 + ((bank) << 2))
+#define EVRT_MASK_CLR(bank)  __REG (EVTR_PHYS + 0xC80 + ((bank) << 2))
+#define EVRT_MASK_SET(bank)  __REG (EVTR_PHYS + 0xCA0 + ((bank) << 2))
+#define EVRT_APR(bank)       __REG (EVTR_PHYS + 0xCC0 + ((bank) << 2))
+#define EVRT_ATR(bank)       __REG (EVTR_PHYS + 0xCE0 + ((bank) << 2))
+#define EVRT_RSR(bank)       __REG (EVTR_PHYS + 0xD20 + ((bank) << 2))
+#define EVRT_OUT_PEND(vec,bank)     __REG (EVTR_PHYS + 0x1000 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK(vec,bank)     __REG (EVTR_PHYS + 0x1400 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK_CLR(vec,bank) __REG (EVTR_PHYS + 0x1800 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK_SET(vec,bank) __REG (EVTR_PHYS + 0x1C00 + ((vec) << 5) + ((bank) << 2))
+
+/***********************************************************************
+ * WDT register definitions
+ **********************************************************************/
+#define WDT_IR       __REG (WDT_PHYS + 0x00)
+#define WDT_TCR      __REG (WDT_PHYS + 0x04)
+#define WDT_TC       __REG (WDT_PHYS + 0x08)
+#define WDT_PR       __REG (WDT_PHYS + 0x0c)
+#define WDT_MCR      __REG (WDT_PHYS + 0x14)
+#define WDT_MR0      __REG (WDT_PHYS + 0x18)
+#define WDT_MR1      __REG (WDT_PHYS + 0x1c)
+#define WDT_EMR      __REG (WDT_PHYS + 0x3c)
+
+#define WDT_IR_MR1        _BIT(1)
+#define WDT_IR_MR0        _BIT(0)
+#define WDT_TCR_CNT_RESET _BIT(1)
+#define WDT_TCR_CNT_EN    _BIT(0)
+#define WDT_MCR_STOP_MR1  _BIT(5)
+#define WDT_MCR_RESET_MR1 _BIT(4)
+#define WDT_MCR_INT_MR1   _BIT(3)
+#define WDT_MCR_STOP_MR0  _BIT(2)
+#define WDT_MCR_RESET_MR0 _BIT(1)
+#define WDT_MCR_INT_MR0   _BIT(0)
+#define WDT_EMR_CTRL0(n)  _SBF(4,((n) &0x3))
+#define WDT_EMR_CTRL1(n)  _SBF(6,((n) &0x3))
+#define WDT_EMR_M1        _BIT(1)
+#define WDT_EMR_M0        _BIT(0)
+
+/***********************************************************************
+ * Timer register definitions
+ **********************************************************************/
+#define TIMER_LOAD(base)      __REG ((base) + 0x00)
+#define TIMER_VALUE(base)     __REG ((base) + 0x04)
+#define TIMER_CONTROL(base)   __REG ((base) + 0x08)
+#define TIMER_CLEAR(base)     __REG ((base) + 0x0c)
+
+#define TM_CTRL_ENABLE    _BIT(7)
+#define TM_CTRL_MODE      _BIT(6)
+#define TM_CTRL_PERIODIC  _BIT(6)
+#define TM_CTRL_PS1       _SBF(2, 0)
+#define TM_CTRL_PS16      _SBF(2, 1)
+#define TM_CTRL_PS256     _SBF(2, 2)
+#define TM_CTRL_PS_MASK   _SBF(2, 0x3)
+
+/***********************************************************************
+ * UART register definitions
+ **********************************************************************/
+#define UART_DLL_REG      __REG (UART_PHYS + 0x00)
+#define UART_FIFO_REG     __REG (UART_PHYS + 0x00)
+#define UART_IE_REG       __REG (UART_PHYS + 0x04)
+#define UART_DLM_REG      __REG (UART_PHYS + 0x04)
+#define UART_IIR_REG      __REG (UART_PHYS + 0x08)
+#define UART_FCR_REG      __REG (UART_PHYS + 0x08)
+#define UART_LCR_REG      __REG (UART_PHYS + 0x0c)
+#define UART_MCR_REG      __REG (UART_PHYS + 0x10)
+#define UART_LSR_REG      __REG (UART_PHYS + 0x14)
+#define UART_MSR_REG      __REG (UART_PHYS + 0x18)
+#define UART_SCR_REG      __REG (UART_PHYS + 0x1c)
+#define UART_ACR_REG      __REG (UART_PHYS + 0x20)
+#define UART_ICR_REG      __REG (UART_PHYS + 0x24)
+#define UART_FDR_REG      __REG (UART_PHYS + 0x28)
+
+/***********************************************************************
+ * SPI register definitions
+ **********************************************************************/
+#define SPI_CONFIG_REG    __REG (SPI_PHYS + 0x00)
+#define SPI_SLV_ENAB_REG  __REG (SPI_PHYS + 0x04)
+#define SPI_TXF_FLUSH_REG __REG (SPI_PHYS + 0x08)
+#define SPI_FIFO_DATA_REG __REG (SPI_PHYS + 0x0C)
+#define SPI_NHP_POP_REG   __REG (SPI_PHYS + 0x10)
+#define SPI_NHP_MODE_REG  __REG (SPI_PHYS + 0x14)
+#define SPI_DMA_SET_REG   __REG (SPI_PHYS + 0x18)
+#define SPI_STS_REG       __REG (SPI_PHYS + 0x1C)
+#define SPI_HWINFO_REG    __REG (SPI_PHYS + 0x20)
+#define SPI_SLV_SET1_REG(slv) __REG (SPI_PHYS + 0x24 + (8 * slv))
+#define SPI_SLV_SET2_REG(slv) __REG (SPI_PHYS + 0x28 + (8 * slv))
+#define SPI_INT_TRSH_REG  __REG (SPI_PHYS + 0xFD4)
+#define SPI_INT_CLRE_REG  __REG (SPI_PHYS + 0xFD8)
+#define SPI_INT_SETE_REG  __REG (SPI_PHYS + 0xFDC)
+#define SPI_INT_STS_REG   __REG (SPI_PHYS + 0xFE0)
+#define SPI_INT_ENAB_REG  __REG (SPI_PHYS + 0xFE4)
+#define SPI_INT_CLRS_REG  __REG (SPI_PHYS + 0xFE8)
+#define SPI_INT_SETS_REG  __REG (SPI_PHYS + 0xFEC)
+#define SPI_MOD_ID_REG    __REG (SPI_PHYS + 0xFFC)
+
+/* SPI device contants */
+#define SPI_FIFO_DEPTH  64 /* 64 words (16bit) deep */
+#define SPI_NUM_SLAVES  3  /* number of slaves supported */
+#define SPI_MAX_DIV2    254
+#define SPI_MAX_DIVIDER 65024 /* = 254 * (255 + 1) */
+#define SPI_MIN_DIVIDER 2
+
+/* SPI Configuration register definitions (SPI_CONFIG_REG) */
+#define SPI_CFG_INTER_DLY(n)      _SBF(16, ((n) & 0xFFFF))
+#define SPI_CFG_INTER_DLY_GET(n)  (((n) >> 16) & 0xFFFF)
+#define SPI_CFG_UPDATE_EN         _BIT(7)
+#define SPI_CFG_SW_RESET          _BIT(6)
+#define SPI_CFG_SLAVE_DISABLE     _BIT(4)
+#define SPI_CFG_MULTI_SLAVE       _BIT(3)
+#define SPI_CFG_LOOPBACK          _BIT(2)
+#define SPI_CFG_SLAVE_MODE        _BIT(1)
+#define SPI_CFG_ENABLE            _BIT(0)
+
+/* SPI slave_enable register definitions (SPI_SLV_ENAB_REG) */
+#define SPI_SLV_EN(n)             _SBF(((n) << 1), 0x1)
+#define SPI_SLV_SUSPEND(n)        _SBF(((n) << 1), 0x3)
+
+/* SPI tx_fifo_flush register definitions (SPI_TXF_FLUSH_REG) */
+#define SPI_TXFF_FLUSH            _BIT(1)
+
+/* SPI dma_settings register definitions (SPI_DMA_SET_REG) */
+#define SPI_DMA_TX_EN             _BIT(1)
+#define SPI_DMA_RX_EN             _BIT(0)
+
+/* SPI status register definitions (SPI_STS_REG) */
+#define SPI_ST_SMS_BUSY           _BIT(5)
+#define SPI_ST_BUSY               _BIT(4)
+#define SPI_ST_RX_FF              _BIT(3)
+#define SPI_ST_RX_EMPTY           _BIT(2)
+#define SPI_ST_TX_FF              _BIT(1)
+#define SPI_ST_TX_EMPTY           _BIT(0)
+
+/* SPI slv_setting registers definitions (SPI_SLV_SET1_REG) */
+#define SPI_SLV1_INTER_TX_DLY(n)  _SBF(24, ((n) & 0xFF))
+#define SPI_SLV1_NUM_WORDS(n)     _SBF(16, ((n) & 0xFF))
+#define SPI_SLV1_CLK_PS(n)        _SBF(8, ((n) & 0xFF))
+#define SPI_SLV1_CLK_PS_GET(n)    (((n) >> 8) & 0xFF)
+#define SPI_SLV1_CLK_DIV1(n)      ((n) & 0xFF)
+#define SPI_SLV1_CLK_DIV1_GET(n)  ((n) & 0xFF)
+
+/* SPI slv_setting registers definitions (SPI_SLV_SET2_REG) */
+#define SPI_SLV2_PPCS_DLY(n)      _SBF(9, ((n) & 0xFF))
+#define SPI_SLV2_CS_HIGH          _BIT(8)
+#define SPI_SLV2_SSI_MODE         _BIT(7)
+#define SPI_SLV2_SPO              _BIT(6)
+#define SPI_SLV2_SPH              _BIT(5)
+#define SPI_SLV2_WD_SZ(n)         ((n) & 0x1F)
+
+/* SPI int_threshold registers definitions (SPI_INT_TRSH_REG) */
+#define SPI_INT_TSHLD_TX(n)       _SBF(8, ((n) & 0xFF))
+#define SPI_INT_TSHLD_RX(n)       ((n) & 0xFF)
+
+/* SPI intterrupt registers definitions ( SPI_INT_xxx) */
+#define SPI_SMS_INT               _BIT(4)
+#define SPI_TX_INT                _BIT(3)
+#define SPI_RX_INT                _BIT(2)
+#define SPI_TO_INT                _BIT(1)
+#define SPI_OVR_INT               _BIT(0)
+#define SPI_ALL_INTS              (SPI_SMS_INT | SPI_TX_INT | SPI_RX_INT | SPI_TO_INT | SPI_OVR_INT)
+
+/***********************************************************************
+* Audio Subsystem (ADSS) register definitions
+**********************************************************************/
+
+/* I2S Controller Module Register Structure */
+#define I2S_FORMAT_SETTINGS       __REG (I2S_PHYS + 0x00)
+#define I2S_CFG_MUX_SETTINGS      __REG (I2S_PHYS + 0x04)
+#define I2S_CLASSED_CFG           __REG (I2S_PHYS + 0x08)
+#define I2S_CLASSED_STS           __REG (I2S_PHYS + 0x0C)
+#define I2S_N_SOF_COUNTER         __REG (I2S_PHYS + 0x10)
+
+/* I2S channels */
+#define I2S_CH_TX0 1
+#define I2S_CH_TX1 2
+#define I2S_CH_RX0 3
+#define I2S_CH_RX1 4
+
+/* I2S channel specific registers */
+#define I2S_CH_LEFT_16BIT(n)      __REG (I2S_PHYS + ((n) * 0x80) + 0x00)
+#define I2S_CH_RIGHT_16BIT(n)     __REG (I2S_PHYS + ((n) * 0x80) + 0x04)
+#define I2S_CH_LEFT_24BIT(n)      __REG (I2S_PHYS + ((n) * 0x80) + 0x08)
+#define I2S_CH_RIGHT_24BIT(n)     __REG (I2S_PHYS + ((n) * 0x80) + 0x0C)
+#define I2S_CH_INT_STATUS(n)      __REG (I2S_PHYS + ((n) * 0x80) + 0x10)
+#define I2S_CH_INT_MASK(n)        __REG (I2S_PHYS + ((n) * 0x80) + 0x14)
+#define I2S_CH_LEFT32(n)          __REG (I2S_PHYS + ((n) * 0x80) + 0x20)
+#define I2S_CH_RIGHT32(n)         __REG (I2S_PHYS + ((n) * 0x80) + 0x40)
+#define I2S_CH_INTERLEAVED(n)     __REG (I2S_PHYS + ((n) * 0x80) + 0x60)
+
+/* I2S format settings register defines */
+#define I2S_FORMAT_I2S            0x3
+#define I2S_FORMAT_LSB16          0x4
+#define I2S_FORMAT_LSB18          0x5
+#define I2S_FORMAT_LSB20          0x6
+#define I2S_FORMAT_LSB24          0x7
+#define I2S_FORMAT_MASK           0x7
+#define I2S_SET_FORMAT(n, s)      ((s) << (((n) - 1) * 3))
+
+/* I2S Mux configuration setting defines */
+#define I2S_RXO_SELECT_MASTER     _BIT(1)
+#define I2S_RX1_SELECT_MASTER     _BIT(2)
+
+/* I2S interrupt status and mask bits */
+#define I2S_FIFO_RIGHT_UNDERRUN   _BIT(0)
+#define I2S_FIFO_LEFT_UNDERRUN    _BIT(1)
+#define I2S_FIFO_RIGHT_OVERRUN    _BIT(2)
+#define I2S_FIFO_LEFT_OVERRUN     _BIT(3)
+#define I2S_FIFO_LEFT_FULL        _BIT(4)
+#define I2S_FIFO_LEFT_HALF_FULL   _BIT(5) /* RX only */
+#define I2S_FIFO_LEFT_HALF_EMPTY  _BIT(5) /* TX only */
+#define I2S_FIFO_LEFT_NOT_EMPTY   _BIT(6) /* RX only */
+#define I2S_FIFO_LEFT_EMPTY       _BIT(6) /* TX only */
+#define I2S_FIFO_RIGHT_FULL       _BIT(7)
+#define I2S_FIFO_RIGHT_HALF_FULL  _BIT(8) /* RX only */
+#define I2S_FIFO_RIGHT_HALF_EMPTY _BIT(8) /* TX only */
+#define I2S_FIFO_RIGHT_NOT_EMPTY  _BIT(9) /* RX only */
+#define I2S_FIFO_RIGHT_EMPTY      _BIT(9) /* TX only */
+#define I2S_FIFO_ALL_MASK         0x3FF
+
+/***********************************************************************
+ * ADC_REG register definitions
+ **********************************************************************/
+#define ADC_CON_REG            __REG (ADC_PHYS + 0x20)
+
+/***********************************************************************
+ * SYS_REG register definitions
+ **********************************************************************/
+#define SYS_RNG_OSC_CFG        __REG (SYS_PHYS + 0x14)
+#define SYS_ADC_PD             __REG (SYS_PHYS + 0x18)
+#define SYS_SDMMC_DELAYMODES   __REG (SYS_PHYS + 0x2C)
+#define SYS_USB_ATX_PLL_PD_REG __REG (SYS_PHYS + 0x30)
+#define SYS_USB_OTG_CFG        __REG (SYS_PHYS + 0x34)
+#define SYS_USB_OTG_LED_CTL    __REG (SYS_PHYS + 0x38)
+#define SYS_USB_PLL_NDEC       __REG (SYS_PHYS + 0x40)
+#define SYS_USB_PLL_MDEC       __REG (SYS_PHYS + 0x44)
+#define SYS_USB_PLL_PDEC       __REG (SYS_PHYS + 0x48)
+#define SYS_USB_PLL_SELR       __REG (SYS_PHYS + 0x4C)
+#define SYS_USB_PLL_SELI       __REG (SYS_PHYS + 0x50)
+#define SYS_USB_PLL_SELP       __REG (SYS_PHYS + 0x54)
+
+#define SYS_MPMC_DELAY      __REG (SYS_PHYS + 0x68)
+#define SYS_MPMC_WTD_DEL0   __REG (SYS_PHYS + 0x6C)
+#define SYS_MPMC_WTD_DEL1   __REG (SYS_PHYS + 0x70)
+#define SYS_MPMC_TESTMODE0  __REG (SYS_PHYS + 0x78)
+#define SYS_REMAP_ADDR      __REG (SYS_PHYS + 0x84)
+#define SYS_MUX_LCD_EBI     __REG (SYS_PHYS + 0x90)
+#define SYS_MUX_GPIO_MCI    __REG (SYS_PHYS + 0x94)
+#define SYS_MUX_NAND_MCI    __REG (SYS_PHYS + 0x98)
+
+/***********************************************************************
+ * GPIO register definitions
+ **********************************************************************/
+#define GPIO_STATE(port)     __REG (GPIO_PHYS + (port) + 0x00)
+#define GPIO_STATE_M0(port)  __REG (GPIO_PHYS + (port) + 0x10)
+#define GPIO_M0_SET(port)    __REG (GPIO_PHYS + (port) + 0x14)
+#define GPIO_M0_RESET(port)  __REG (GPIO_PHYS + (port) + 0x18)
+#define GPIO_STATE_M1(port)  __REG (GPIO_PHYS + (port) + 0x20)
+#define GPIO_M1_SET(port)    __REG (GPIO_PHYS + (port) + 0x24)
+#define GPIO_M1_RESET(port)  __REG (GPIO_PHYS + (port) + 0x28)
+
+#define GPIO_OUT_LOW(port, pin)  do { GPIO_M1_SET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
+#define GPIO_OUT_HIGH(port, pin) do { GPIO_M1_SET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
+#define GPIO_IN(port, pin)       do { GPIO_M1_RESET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
+#define GPIO_DRV_IP(port, pin)   do { GPIO_M1_RESET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
+
+#define IOCONF_EBI_MCI       (0x000)
+#define IOCONF_EBI_I2STX_0   (0x040)
+#define IOCONF_CGU           (0x080)
+#define IOCONF_I2SRX_0       (0x0c0)
+#define IOCONF_I2SRX_1       (0x100)
+#define IOCONF_I2STX_1       (0x140)
+#define IOCONF_EBI           (0x180)
+#define IOCONF_GPIO          (0x1c0)
+#define IOCONF_I2C1          (0x200)
+#define IOCONF_SPI           (0x240)
+#define IOCONF_NAND_CTRL     (0x280)
+#define IOCONF_PWM           (0x2c0)
+#define IOCONF_UART          (0x300)
+
+
+/***********************************************************************
+ * MPMC memory controller register definitions
+ **********************************************************************/
+#define MPMC_CTRL           __REG (MPMC_PHYS + 0x000)
+#define MPMC_STATUS         __REG (MPMC_PHYS + 0x004)
+#define MPMC_CONFIG         __REG (MPMC_PHYS + 0x008)
+#define MPMC_DYNCTL         __REG (MPMC_PHYS + 0x020)
+#define MPMC_DYNREF         __REG (MPMC_PHYS + 0x024)
+#define MPMC_DYRDCFG        __REG (MPMC_PHYS + 0x028)
+#define MPMC_DYTRP          __REG (MPMC_PHYS + 0x030)
+#define MPMC_DYTRAS         __REG (MPMC_PHYS + 0x034)
+#define MPMC_DYTSREX        __REG (MPMC_PHYS + 0x038)
+#define MPMC_DYTAPR         __REG (MPMC_PHYS + 0x03C)
+#define MPMC_DYTDAL         __REG (MPMC_PHYS + 0x040)
+#define MPMC_DYTWR          __REG (MPMC_PHYS + 0x044)
+#define MPMC_DYTRC          __REG (MPMC_PHYS + 0x048)
+#define MPMC_DYTRFC         __REG (MPMC_PHYS + 0x04C)
+#define MPMC_DYTXSR         __REG (MPMC_PHYS + 0x050)
+#define MPMC_DYTRRD         __REG (MPMC_PHYS + 0x054)
+#define MPMC_DYTMRD         __REG (MPMC_PHYS + 0x058)
+#define MPMC_STEXDWT        __REG (MPMC_PHYS + 0x080)
+#define MPMC_DYCONFIG       __REG (MPMC_PHYS + 0x100)
+#define MPMC_DYRASCAS       __REG (MPMC_PHYS + 0x104)
+#define MPMC_STCONFIG0      __REG (MPMC_PHYS + 0x200)
+#define MPMC_STWTWEN0       __REG (MPMC_PHYS + 0x204)
+#define MPMC_STWTOEN0       __REG (MPMC_PHYS + 0x208)
+#define MPMC_STWTRD0        __REG (MPMC_PHYS + 0x20C)
+#define MPMC_STWTPG0        __REG (MPMC_PHYS + 0x210)
+#define MPMC_STWTWR0        __REG (MPMC_PHYS + 0x214)
+#define MPMC_STWTTURN0      __REG (MPMC_PHYS + 0x218)
+#define MPMC_STCONFIG1      __REG (MPMC_PHYS + 0x220)
+#define MPMC_STWTWEN1       __REG (MPMC_PHYS + 0x224)
+#define MPMC_STWTOEN1       __REG (MPMC_PHYS + 0x228)
+#define MPMC_STWTRD1        __REG (MPMC_PHYS + 0x22C)
+#define MPMC_STWTPG1        __REG (MPMC_PHYS + 0x230)
+#define MPMC_STWTWR1        __REG (MPMC_PHYS + 0x234)
+#define MPMC_STWTTURN1      __REG (MPMC_PHYS + 0x238)
+
+#define NS_TO_MPMCCLK(ns, clk)	(((ns)*((clk + 500)/1000) + 500000)/1000000)
+/* MPMC Controller Bit Field constants*/
+#define MPMC_CTL_LOW_PWR               _BIT(2)
+#define MPMC_CTL_ENABLE                _BIT(0)
+/* MPMC status Bit Field constants*/
+#define MPMC_STATUS_SA                 _BIT(2)
+#define MPMC_STATUS_WR_BUF             _BIT(1)
+#define MPMC_STATUS_BUSY               _BIT(0)
+/* MPMC config Bit Field constants*/
+#define MPMC_CFG_SDCCLK_1_2            _BIT(8)
+#define MPMC_CFG_SDCCLK_1_1            (0)
+/* SDRAM Controller Bit Field constants*/
+#define MPMC_SDRAMC_CTL_DP             _BIT(13)
+#define MPMC_SDRAMC_CTL_NORMAL_CMD     _SBF(7,0)
+#define MPMC_SDRAMC_CTL_MODE_CMD       _SBF(7,1)
+#define MPMC_SDRAMC_CTL_PALL_CMD       _SBF(7,2)
+#define MPMC_SDRAMC_CTL_NOP_CMD        _SBF(7,3)
+#define MPMC_SDRAMC_CTL_MCC            _BIT(5)
+#define MPMC_SDRAMC_CTL_SR             _BIT(2)
+#define MPMC_SDRAMC_CTL_CS             _BIT(1)
+#define MPMC_SDRAMC_CTL_CE             _BIT(0)
+/* SDRAM Config Bit Field constants*/
+#define MPMC_SDRAMC_CFG_SDRAM_MD       _SBF(3,0)
+#define MPMC_SDRAMC_CFG_LOW_PWR_MD     _SBF(3,1)
+#define MPMC_SDRAMC_CFG_SYNC_FLASH     _SBF(3,2)
+#define MPMC_SDRAMC_CFG_BUF_EN         _BIT(19)
+#define MPMC_SDRAMC_CFG_WP             _BIT(20)
+
+
+/* SDRAM Read Config Bit Field constants*/
+#define MPMC_SDRAMC_RDCFG_CLKOUTDELAY_STG       _SBF(0,0)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_STG          _SBF(0,1)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_P1_STG       _SBF(0,2)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_P2_STG       _SBF(0,3)
+/* SDRAM RASCAS Bit Field constants*/
+#define MPMC_SDRAMC_RASCAS_CAS0        _SBF(8,0)
+#define MPMC_SDRAMC_RASCAS_CAS1        _SBF(8,1)
+#define MPMC_SDRAMC_RASCAS_CAS2        _SBF(8,2)
+#define MPMC_SDRAMC_RASCAS_CAS3        _SBF(8,3)
+#define MPMC_SDRAMC_RASCAS_RAS0        _SBF(0,0)
+#define MPMC_SDRAMC_RASCAS_RAS1        _SBF(0,1)
+#define MPMC_SDRAMC_RASCAS_RAS2        _SBF(0,2)
+#define MPMC_SDRAMC_RASCAS_RAS3        _SBF(0,3)
+
+/***********************************************************************
+ * SD/MMC MCI register definitions
+ **********************************************************************/
+#define SDMMC_CTRL            __REG (SDMMC_PHYS + 0x000)
+#define SDMMC_PWREN           __REG (SDMMC_PHYS + 0x004)
+#define SDMMC_CLKDIV          __REG (SDMMC_PHYS + 0x008)
+#define SDMMC_CLKSRC          __REG (SDMMC_PHYS + 0x00c)
+#define SDMMC_CLKENA          __REG (SDMMC_PHYS + 0x010)
+#define SDMMC_TMOUT           __REG (SDMMC_PHYS + 0x014)
+#define SDMMC_CTYPE           __REG (SDMMC_PHYS + 0x018)
+#define SDMMC_BLKSIZ          __REG (SDMMC_PHYS + 0x01c)
+#define SDMMC_BYTCNT          __REG (SDMMC_PHYS + 0x020)
+#define SDMMC_INTMASK         __REG (SDMMC_PHYS + 0x024)
+#define SDMMC_CMDARG          __REG (SDMMC_PHYS + 0x028)
+#define SDMMC_CMD             __REG (SDMMC_PHYS + 0x02c)
+#define SDMMC_RESP0           __REG (SDMMC_PHYS + 0x030)
+#define SDMMC_RESP1           __REG (SDMMC_PHYS + 0x034)
+#define SDMMC_RESP2           __REG (SDMMC_PHYS + 0x038)
+#define SDMMC_RESP3           __REG (SDMMC_PHYS + 0x03c)
+#define SDMMC_MINTSTS         __REG (SDMMC_PHYS + 0x040)
+#define SDMMC_RINTSTS         __REG (SDMMC_PHYS + 0x044)
+#define SDMMC_STATUS          __REG (SDMMC_PHYS + 0x048)
+#define SDMMC_FIFOTH          __REG (SDMMC_PHYS + 0x04c)
+#define SDMMC_TCBCNT          __REG (SDMMC_PHYS + 0x05c)
+#define SDMMC_TBBCNT          __REG (SDMMC_PHYS + 0x060)
+#define SDMMC_DEBNCE          __REG (SDMMC_PHYS + 0x064)
+#define SDMMC_USRID           __REG (SDMMC_PHYS + 0x068)
+#define SDMMC_VERID           __REG (SDMMC_PHYS + 0x06c)
+#define SDMMC_HCON            __REG (SDMMC_PHYS + 0x070)
+#define SDMMC_DATA            __REG (SDMMC_PHYS + 0x100)
+#define SDMMC_DATA_ADR        (SDMMC_PHYS + 0x100)
+
+/* Control register defines */
+#define SDMMC_CTRL_CEATA_INT_EN   _BIT(11)
+#define SDMMC_CTRL_SEND_AS_CCSD   _BIT(10)
+#define SDMMC_CTRL_SEND_CCSD      _BIT(9)
+#define SDMMC_CTRL_ABRT_READ_DATA _BIT(8)
+#define SDMMC_CTRL_SEND_IRQ_RESP  _BIT(7)
+#define SDMMC_CTRL_READ_WAIT      _BIT(6)
+#define SDMMC_CTRL_DMA_ENABLE     _BIT(5)
+#define SDMMC_CTRL_INT_ENABLE     _BIT(4)
+#define SDMMC_CTRL_DMA_RESET      _BIT(2)
+#define SDMMC_CTRL_FIFO_RESET     _BIT(1)
+#define SDMMC_CTRL_RESET          _BIT(0)
+/* Clock Enable register defines */
+#define SDMMC_CLKEN_LOW_PWR      _BIT(16)
+#define SDMMC_CLKEN_ENABLE       _BIT(0)
+/* time-out register defines */
+#define SDMMC_TMOUT_DATA(n)      _SBF(8, (n))
+#define SDMMC_TMOUT_DATA_MSK     0xFFFFFF00
+#define SDMMC_TMOUT_RESP(n)      ((n) & 0xFF)
+#define SDMMC_TMOUT_RESP_MSK     0xFF
+/* card-type register defines */
+#define SDMMC_CTYPE_8BIT         _BIT(16)
+#define SDMMC_CTYPE_4BIT         _BIT(0)
+/* Interrupt status & mask register defines */
+#define SDMMC_INT_SDIO           _BIT(16)
+#define SDMMC_INT_EBE            _BIT(15)
+#define SDMMC_INT_ACD            _BIT(14)
+#define SDMMC_INT_SBE            _BIT(13)
+#define SDMMC_INT_HLE            _BIT(12)
+#define SDMMC_INT_FRUN           _BIT(11)
+#define SDMMC_INT_HTO            _BIT(10)
+#define SDMMC_INT_DTO            _BIT(9)
+#define SDMMC_INT_RTO            _BIT(8)
+#define SDMMC_INT_DCRC           _BIT(7)
+#define SDMMC_INT_RCRC           _BIT(6)
+#define SDMMC_INT_RXDR           _BIT(5)
+#define SDMMC_INT_TXDR           _BIT(4)
+#define SDMMC_INT_DATA_OVER      _BIT(3)
+#define SDMMC_INT_CMD_DONE       _BIT(2)
+#define SDMMC_INT_RESP_ERR       _BIT(1)
+#define SDMMC_INT_CD             _BIT(0)
+#define SDMMC_INT_ERROR          0xbfc2
+/* Command register defines */
+#define SDMMC_CMD_START         _BIT(31)
+#define SDMMC_CMD_CCS_EXP       _BIT(23)
+#define SDMMC_CMD_CEATA_RD      _BIT(22)
+#define SDMMC_CMD_UPD_CLK       _BIT(21)
+#define SDMMC_CMD_INIT          _BIT(15)
+#define SDMMC_CMD_STOP          _BIT(14)
+#define SDMMC_CMD_PRV_DAT_WAIT  _BIT(13)
+#define SDMMC_CMD_SEND_STOP     _BIT(12)
+#define SDMMC_CMD_STRM_MODE     _BIT(11)
+#define SDMMC_CMD_DAT_WR        _BIT(10)
+#define SDMMC_CMD_DAT_EXP       _BIT(9)
+#define SDMMC_CMD_RESP_CRC      _BIT(8)
+#define SDMMC_CMD_RESP_LONG     _BIT(7)
+#define SDMMC_CMD_RESP_EXP      _BIT(6)
+#define SDMMC_CMD_INDX(n)       ((n) & 0x1F)
+/* Status register defines */
+#define SDMMC_GET_FCNT(x)       (((x)>>17) & 0x1FF)
+#define SDMMC_FIFO_SZ           32
+
+
+/***********************************************************************
+ * NAND Controller register definitions
+ **********************************************************************/
+#define NAND_IRQSTATUS1                __REG (NANDC_PHYS + 0x000)
+#define NAND_IRQMASK1                  __REG (NANDC_PHYS + 0x004)
+#define NAND_IRQSTATUSRAW1             __REG (NANDC_PHYS + 0x008)
+#define NAND_CONFIG                    __REG (NANDC_PHYS + 0x00C)
+#define NAND_IOCONFIG                  __REG (NANDC_PHYS + 0x010)
+#define NAND_TIMING1                   __REG (NANDC_PHYS + 0x014)
+#define NAND_TIMING2                   __REG (NANDC_PHYS + 0x018)
+#define NAND_SETCMD                    __REG (NANDC_PHYS + 0x020)
+#define NAND_SETADDR                   __REG (NANDC_PHYS + 0x024)
+#define NAND_WRITEDATA                 __REG (NANDC_PHYS + 0x028)
+#define NAND_SETCE                     __REG (NANDC_PHYS + 0x02C)
+#define NAND_READDATA                  __REG (NANDC_PHYS + 0x030)
+#define NAND_CHECKSTS                  __REG (NANDC_PHYS + 0x034)
+#define NAND_CONTROLFLOW               __REG (NANDC_PHYS + 0x038)
+#define NAND_GPIO1                     __REG (NANDC_PHYS + 0x040)
+#define NAND_GPIO2                     __REG (NANDC_PHYS + 0x044)
+#define NAND_IRQSTATUS2                __REG (NANDC_PHYS + 0x048)
+#define NAND_IRQMASK2                  __REG (NANDC_PHYS + 0x04C)
+#define NAND_IRQSTATUSRAW2             __REG (NANDC_PHYS + 0x050)
+#define NAND_ECCERRSTATUS              __REG (NANDC_PHYS + 0x078)
+
+/* NAND internal SDRAM address definitions*/
+#define NAND_BUFFER_ADRESS             __REG (IO_NAND_BUF_PHYS)
+
+/* Register description of NANDIRQSTATUS1 */
+#define NAND_NANDIRQSTATUS1_RB4_POS_EDGE       _BIT(31)
+#define NAND_NANDIRQSTATUS1_RB3_POS_EDGE       _BIT(30)
+#define NAND_NANDIRQSTATUS1_RB2_POS_EDGE       _BIT(29)
+#define NAND_NANDIRQSTATUS1_RB1_POS_EDGE       _BIT(28)
+#define NAND_NANDIRQSTATUS1_ERASED_RAM1        _BIT(27)
+#define NAND_NANDIRQSTATUS1_ERASED_RAM0        _BIT(26)
+#define NAND_NANDIRQSTATUS1_WR_RAM1            _BIT(25)
+#define NAND_NANDIRQSTATUS1_WR_RAM0            _BIT(24)
+#define NAND_NANDIRQSTATUS1_RD_RAM1            _BIT(23)
+#define NAND_NANDIRQSTATUS1_RD_RAM0            _BIT(22)
+#define NAND_NANDIRQSTATUS1_ECC_DEC_RAM0       _BIT(21)
+#define NAND_NANDIRQSTATUS1_ECC_ENC_RAM0       _BIT(20)
+#define NAND_NANDIRQSTATUS1_ECC_DEC_RAM1       _BIT(19)
+#define NAND_NANDIRQSTATUS1_ECC_ENC_RAM1       _BIT(18)
+#define NAND_NANDIRQSTATUS1_NOERR_RAM0         _BIT(17)
+#define NAND_NANDIRQSTATUS1_ERR1_RAM0          _BIT(16)
+#define NAND_NANDIRQSTATUS1_ERR2_RAM0          _BIT(15)
+#define NAND_NANDIRQSTATUS1_ERR3_RAM0          _BIT(14)
+#define NAND_NANDIRQSTATUS1_ERR4_RAM0          _BIT(13)
+#define NAND_NANDIRQSTATUS1_ERR5_RAM0          _BIT(12)
+#define NAND_NANDIRQSTATUS1_ERR_UNR_RAM0       _BIT(11)
+#define NAND_NANDIRQSTATUS1_NOERR_RAM1         _BIT(10)
+#define NAND_NANDIRQSTATUS1_ERR1_RAM1          _BIT(9)
+#define NAND_NANDIRQSTATUS1_ERR2_RAM1          _BIT(8)
+#define NAND_NANDIRQSTATUS1_ERR3_RAM1          _BIT(7)
+#define NAND_NANDIRQSTATUS1_ERR4_RAM1          _BIT(6)
+#define NAND_NANDIRQSTATUS1_ERR5_RAM1          _BIT(5)
+#define NAND_NANDIRQSTATUS1_ERR_UNR_RAM1       _BIT(4)
+#define NAND_NANDIRQSTATUS1_AES_DONE_RAM1      _BIT(1)
+#define NAND_NANDIRQSTATUS1_AES_DONE_RAM0      _BIT(0)
+
+/* Register description of NANDCONFIG */
+#define NAND_NANDCONFIG_PEC                _BIT(15) /* Power off ECC clock*/
+#define NAND_NANDCONFIG_ECGC               _BIT(13) /* Enable ECC clock gating*/
+#define NAND_NANDCONFIG_8BIT_ECC           _BIT(12) /* ECC mode*/
+#define NAND_NANDCONFIG_TL_528             _SBF(10, 0x0) /* Transfer limit*/
+#define NAND_NANDCONFIG_TL_516             _SBF(10, 0x2) /* Transfer limit*/
+#define NAND_NANDCONFIG_TL_512             _SBF(10, 0x3) /* Transfer limit*/
+#define NAND_NANDCONFIG_TL_MASK            _SBF(10, 0x3) /* Transfer limit*/
+#define NAND_NANDCONFIG_EO                 _BIT(9) /* */
+#define NAND_NANDCONFIG_DC                 _BIT(8) /* Deactivate CE enable*/
+#define NAND_NANDCONFIG_M                  _BIT(7) /* 512 mode*/
+#define NAND_NANDCONFIG_LC_0               _SBF(5, 0x0) /* Latency Configuration: zero wait state*/
+#define NAND_NANDCONFIG_LC_1               _SBF(5, 0x1) /* Latency Configuration: one wait state*/
+#define NAND_NANDCONFIG_LC_2               _SBF(5, 0x2) /* Latency Configuration: two wait state*/
+#define NAND_NANDCONFIG_LC_MASK            _SBF(5, 0x3) /* Latency Configuration*/
+#define NAND_NANDCONFIG_ES                 _BIT(4) /* Endianess setting */
+#define NAND_NANDCONFIG_DE                 _BIT(3) /* DMA external enable*/
+#define NAND_NANDCONFIG_AO                 _BIT(2) /* */
+#define NAND_NANDCONFIG_WD                 _BIT(1) /* Wide device*/
+#define NAND_NANDCONFIG_EC                 _BIT(0) /* ECC on*/
+
+/* Register description of NANDIOCONFIG */
+#define NAND_NANDIOCONFIG_CFG_IO_DRIVE        _BIT(24) /* Nand IO drive default*/
+#define NAND_NANDIOCONFIG_CFG_DATA_DEF(n)     _SBF(8, ((n) & 0xFFFF)) /* Data to nand default*/
+#define NAND_NANDIOCONFIG_CFG_CLE_1           _SBF(6, 0x01) /* CLE default*/
+#define NAND_NANDIOCONFIG_CFG_ALE_1           _SBF(4, 0x01) /* ALE default*/
+#define NAND_NANDIOCONFIG_CFG_WE_1            _SBF(2, 0x01) /* WE_n default*/
+#define NAND_NANDIOCONFIG_CFG_RE_1            _SBF(0, 0x01) /* RE_n default*/
+
+/* Register description of NANDTIMING1 */
+#define NAND_NANDTIMING1_DEFAULT		   (0x000FFFFF)
+#define NAND_NANDTIMING1_TSRD(n)           _SBF(20, ((n) & 0x3)) /* Single data input delay*/
+#define NAND_NANDTIMING1_TALS(n)           _SBF(16, ((n) & 0x7)) /* Address setup time*/
+#define NAND_NANDTIMING1_TALH(n)           _SBF(12, ((n) & 0x7)) /* Address hold time*/
+#define NAND_NANDTIMING1_TCLS(n)           _SBF(4, ((n) & 0x7)) /* Command setup time*/
+#define NAND_NANDTIMING1_TCLH(n)           ((n) & 0x7) /* Command hold time*/
+
+/* Register description of NANDTIMING2 */
+#define NAND_NANDTIMING2_DEFAULT		   (0xFFFFFFFF)
+#define NAND_NANDTIMING2_TDRD(n)           _SBF(28, ((n) & 0x7)) /* Data input delay*/
+#define NAND_NANDTIMING2_TEBI(n)           _SBF(24, ((n) & 0x7)) /* EBI delay time*/
+#define NAND_NANDTIMING2_TCH(n)            _SBF(20, ((n) & 0x7)) /* Chip select hold time*/
+#define NAND_NANDTIMING2_TCS(n)            _SBF(16, ((n) & 0x7)) /* Chip select setup time*/
+#define NAND_NANDTIMING2_TRH(n)            _SBF(12, ((n) & 0x7)) /* Read enable high hold*/
+#define NAND_NANDTIMING2_TRP(n)            _SBF(8, ((n) & 0x7)) /* Read enable pulse width*/
+#define NAND_NANDTIMING2_TWH(n)            _SBF(4, ((n) & 0x7)) /* Write enable high hold*/
+#define NAND_NANDTIMING2_TWP(n)            ((n) & 0x7) /* Write enable pulse width*/
+
+/* Register description of NANDSETCE */
+#define NAND_NANDSETCE_OVR_EN(n)        _BIT(((n) & 0x3) + 12) /* */
+#define NAND_NANDSETCE_OVR_V(n)         _BIT(((n) & 0x3) + 8) /* */
+#define NAND_NANDSETCE_WP               _BIT(4) /* WP_n pin value*/
+#define NAND_NANDSETCE_CV_MASK          0x0F /* Chip select value*/
+#define NAND_NANDSETCE_CV(n)            (0x0F & ~_BIT(((n) & 0x3))) /* Chip select value*/
+#define NAND_NANDSETCE_CV0              _BIT(0)
+
+/* Register description of NANDCHECKSTS */
+#define NAND_NANDCHECKSTS_RB4_EDGE       _BIT(8) /* mNAND_RYBN3 rising edge*/
+#define NAND_NANDCHECKSTS_RB3_EDGE       _BIT(7) /* mNAND_RYBN2 rising edge*/
+#define NAND_NANDCHECKSTS_RB2_EDGE       _BIT(6) /* mNAND_RYBN1 rising edge*/
+#define NAND_NANDCHECKSTS_RB1_EDGE       _BIT(5) /* mNAND_RYBN0 rising edge*/
+#define NAND_NANDCHECKSTS_RB4_LVL        _BIT(4) /* mNAND_RYBN3 value*/
+#define NAND_NANDCHECKSTS_RB3_LVL        _BIT(3) /* mNAND_RYBN2 value*/
+#define NAND_NANDCHECKSTS_RB2_LVL        _BIT(2) /* mNAND_RYBN1 value*/
+#define NAND_NANDCHECKSTS_RB1_LVL        _BIT(1) /* mNAND_RYBN0 value*/
+#define NAND_NANDCHECKSTS_APB_BSY        _BIT(0) /* APB busy*/
+
+/* Register description of NANDCONTROLFLOW */
+
+/* Write the contents of SRAM1 to the NAND flash*/
+#define NAND_CTRL_WR_RAM1           _BIT(5)
+/* Write the contents of SRAM0 to the NAND flash */
+#define NAND_CTRL_WR_RAM0           _BIT(4)
+/* Read a defined number of bytes from the NAND flash and store them in SRAM1*/
+#define NAND_CTRL_RD_RAM1           _BIT(1)
+/* Read a defined number of bytes from the NAND flash and store them in SRAM0*/
+#define NAND_CTRL_RD_RAM0           _BIT(0)
+
+/* Register description of ... */
+#define NAND_AES_AHB_EN             _BIT(7)
+#define NAND_AES_AHB_DCRYPT_RAM1    _BIT(1)
+#define NAND_AES_AHB_DCRYPT_RAM0    _BIT(0)
+
+
+
+
+#endif  /* __ASM_ARCH_REGISTERS_H */
diff --git a/arch/arm/mach-lpc31xx/include/mach/system.h b/arch/arm/mach-lpc31xx/include/mach/system.h
new file mode 100644
index 0000000..867a12f
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/system.h
@@ -0,0 +1,52 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/system.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <mach/hardware.h>
+#include <mach/clock.h>
+
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle ();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	printk("arch_reset: attempting watchdog reset\n");
+
+	/* enable WDT clock */
+	cgu_clk_en_dis(CGU_SB_WDOG_PCLK_ID, 1);
+
+	/* Disable watchdog */
+	WDT_TCR = 0;
+	WDT_MCR = WDT_MCR_STOP_MR1 | WDT_MCR_INT_MR1;
+
+	/*  If TC and MR1 are equal a reset is generated. */
+	WDT_PR  = 0x00000002;
+	WDT_TC  = 0x00000FF0;
+	WDT_MR0 = 0x0000F000;
+	WDT_MR1 = 0x00001000;
+	WDT_EMR = WDT_EMR_CTRL1(0x3);
+	/* Enable watchdog timer; assert reset at timer timeout */
+	WDT_TCR = WDT_TCR_CNT_EN;
+	cpu_reset (0);/* loop forever and wait for reset to happen */
+
+	/*NOTREACHED*/
+}
diff --git a/arch/arm/mach-lpc31xx/include/mach/timex.h b/arch/arm/mach-lpc31xx/include/mach/timex.h
new file mode 100644
index 0000000..a3a4484
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/timex.h
@@ -0,0 +1,29 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/timex.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include "constants.h"
+
+#define CLOCK_TICK_RATE		(FFAST_CLOCK/2)
+
+#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/uncompress.h b/arch/arm/mach-lpc31xx/include/mach/uncompress.h
new file mode 100644
index 0000000..7a8c7af
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/uncompress.h
@@ -0,0 +1,88 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/uncompress.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Decompression UART routines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "constants.h"
+#include "registers.h"
+
+
+#undef __REG
+#define __REG(x)	(*((volatile u32 *)(x)))
+/***********************************************************************
+ * UART register definitions
+ **********************************************************************/
+#define UART_DLL      __REG (UART_PHYS + 0x00)
+#define UART_FIFO     __REG (UART_PHYS + 0x00)
+#define UART_IE       __REG (UART_PHYS + 0x04)
+#define UART_DLM      __REG (UART_PHYS + 0x04)
+#define UART_IIR      __REG (UART_PHYS + 0x08)
+#define UART_FCR      __REG (UART_PHYS + 0x08)
+#define UART_LCR      __REG (UART_PHYS + 0x0c)
+#define UART_MCR      __REG (UART_PHYS + 0x10)
+#define UART_LSR      __REG (UART_PHYS + 0x14)
+#define UART_MSR      __REG (UART_PHYS + 0x18)
+#define UART_SCR      __REG (UART_PHYS + 0x1c)
+#define UART_ACR      __REG (UART_PHYS + 0x20)
+#define UART_ICR      __REG (UART_PHYS + 0x24)
+#define UART_FDR      __REG (UART_PHYS + 0x28)
+
+
+#define UART_LOAD_DLL(div)          ((div) & 0xFF)
+#define UART_LOAD_DLM(div)          (((div) >> 8) & 0xFF)
+#define UART_LCR_DIVLATCH_EN       _BIT(7)
+#define UART_LCR_WLEN_8BITS        _SBF(0, 3)
+#define UART_FCR_DMA_MODE          _BIT(3)
+#define UART_FCR_TXFIFO_FLUSH      _BIT(2)
+#define UART_FCR_RXFIFO_FLUSH      _BIT(1)
+#define UART_FCR_FIFO_EN           _BIT(0)
+#define UART_LSR_FIFORX_ERR        _BIT(7)
+#define UART_LSR_TEMT              _BIT(6)
+#define UART_LSR_FR                _BIT(3)
+#define UART_LSR_PE                _BIT(2)
+#define UART_LSR_OE                _BIT(1)
+#define UART_LSR_RDR               _BIT(0)
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader. If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void putc(int c)
+{
+	while (!(UART_LSR & UART_LSR_TEMT))
+		barrier();
+
+	UART_FIFO = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
diff --git a/arch/arm/mach-lpc31xx/include/mach/vmalloc.h b/arch/arm/mach-lpc31xx/include/mach/vmalloc.h
new file mode 100644
index 0000000..8f19964
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/vmalloc.h
@@ -0,0 +1,21 @@
+/*  linux/arch/arm/mach-lpc313x/include/mach/vmalloc.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#define VMALLOC_END       (0xe8000000)
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
new file mode 100644
index 0000000..50dc8a7
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -0,0 +1,346 @@
+/*  linux/arch/arm/mach-lpc313x/irq.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Interrupt controller and event router driver for LPC313x & LPC315x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <mach/irqs.h>
+#include <mach/clock.h>
+
+
+static IRQ_EVENT_MAP_T irq_2_event[] = BOARD_IRQ_EVENT_MAP;
+
+static void intc_mask_irq(struct irq_data *data)
+{
+	INTC_REQ_REG(data->irq) = INTC_REQ_WE_ENABLE;
+}
+
+static void intc_unmask_irq(struct irq_data *data)
+{
+	INTC_REQ_REG(data->irq) = INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE;
+}
+
+static int intc_set_wake(struct irq_data *data, unsigned int on)
+{
+	static u32 wake_ints = 0;
+
+	if (on)
+		/* save the irqs which wake */
+		wake_ints |= _BIT(data->irq);
+	else
+		/* clear the irqs which don't wake */
+		wake_ints &= ~_BIT(data->irq);
+
+	/* Note: the clocks to corresponding blocks shouldn't be suspended
+	 * by individual drivers for this logic to work.
+	 */
+	if (wake_ints) {
+		/* enable ARM_IRQ routing to CGU_WAKEUP */
+		EVRT_OUT_MASK_SET(4, EVT_GET_BANK(EVT_arm926_nirq)) = _BIT((EVT_arm926_nirq & 0x1F));
+	} else {
+		/* disable ARM_IRQ routing to CGU_WAKEUP */
+		EVRT_OUT_MASK_CLR(4, EVT_GET_BANK(EVT_arm926_nirq)) = _BIT((EVT_arm926_nirq & 0x1F));
+	}
+
+	//printk("wake on irq=%d value=%d 0x%08x/0x%08x/0x%08x 0x%08x/0x%08x\r\n", irq, value, 
+	//	EVRT_MASK(3), EVRT_APR(3), EVRT_ATR(3),
+	//	EVRT_OUT_MASK(4,3), EVRT_OUT_PEND(4,3));
+
+	return 0;
+}
+
+static struct irq_chip lpc313x_internal_chip = {
+	.name = "INTC",
+	.irq_ack = intc_mask_irq,
+	.irq_mask = intc_mask_irq,
+	.irq_unmask = intc_unmask_irq,
+	.irq_set_wake = intc_set_wake,
+};
+
+static void evt_mask_irq(struct irq_data *data)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+
+	EVRT_MASK_CLR(bank) = _BIT(bit_pos);
+}
+
+static void evt_unmask_irq(struct irq_data *data)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+
+	EVRT_MASK_SET(bank) = _BIT(bit_pos);
+}
+
+static void evt_ack_irq(struct irq_data *data)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+	//EVRT_MASK_CLR(bank) = _BIT(bit_pos);
+	EVRT_INT_CLR(bank) = _BIT(bit_pos);
+}
+
+static int evt_set_type(struct irq_data *data, unsigned int flow_type)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+
+	switch (flow_type) {
+	case IRQ_TYPE_EDGE_RISING:
+		EVRT_APR(bank) |= _BIT(bit_pos);
+		EVRT_ATR(bank) |= _BIT(bit_pos);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		EVRT_APR(bank) &= ~_BIT(bit_pos);
+		EVRT_ATR(bank) |= _BIT(bit_pos);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		EVRT_ATR(bank) |= _BIT(bit_pos);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		EVRT_APR(bank) |= _BIT(bit_pos);
+		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		EVRT_APR(bank) &= ~_BIT(bit_pos);
+		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int evt_set_wake(struct irq_data *data, unsigned int on)
+{
+	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
+	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+
+	if (on)
+		/* enable routing to CGU_WAKEUP */
+		EVRT_OUT_MASK_SET(4, bank) = _BIT(bit_pos);
+	else
+		/* disable routing to CGU_WAKEUP */
+		EVRT_OUT_MASK_CLR(4, bank) = _BIT(bit_pos);
+
+	return 0;
+}
+
+
+static struct irq_chip lpc313x_evtr_chip = {
+	.name = "EVENTROUTER",
+	.irq_ack = evt_ack_irq,
+	.irq_mask = evt_mask_irq,
+	.irq_unmask = evt_unmask_irq,
+	.irq_set_type = evt_set_type,
+	.irq_set_wake = evt_set_wake,
+};
+
+
+#define ROUTER_HDLR(n) \
+	static void router##n##_handler (unsigned int irq, struct irq_desc *desc) { \
+		u32 status, bank, bit_pos; \
+		if (IRQ_EVTR##n##_START == IRQ_EVTR##n##_END) { \
+			/* translate IRQ number */ \
+			irq = IRQ_EVTR##n##_START; \
+			generic_handle_irq(irq); \
+		} else { \
+			for (irq = IRQ_EVTR##n##_START; irq <= IRQ_EVTR##n##_END; irq++) {  \
+				/* compute bank & bit position for the event_pin */ \
+				bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin); \
+				bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F; \
+				status = EVRT_OUT_PEND(n, bank); \
+				if (status & _BIT(bit_pos)) \
+					generic_handle_irq(irq); \
+			} \
+		} \
+	}
+
+
+#if IRQ_EVTR0_END
+ROUTER_HDLR(0)
+#endif /* IRQ_EVTR0_END */
+
+#if IRQ_EVTR1_END
+ROUTER_HDLR(1)
+#endif /* IRQ_EVTR1_END */
+
+#if IRQ_EVTR2_END
+ROUTER_HDLR(2)
+#endif /* IRQ_EVTR2_END */
+
+#if IRQ_EVTR3_END
+ROUTER_HDLR(3)
+#endif /* IRQ_EVTR3_END */
+
+
+void __init lpc313x_init_irq(void)
+{
+	unsigned int irq;
+	int i, j;
+	u32 bank, bit_pos;
+
+	/* enable clock to interrupt controller */
+	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, 1);
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
+
+	/* Set the vector base (we don't use direct vectoring, so this is 0) */
+	INTC_IRQ_VEC_BASE = 0x00000000;
+	INTC_FIQ_VEC_BASE = 0x00000000;
+
+	/* mask all interrupt by setting high priority untill init is done*/
+	INTC_IRQ_PRI_MASK = 0xFF;
+	INTC_FIQ_PRI_MASK = 0xFF;
+
+	/* mask all external events */
+	for (i = 0; i < EVT_MAX_VALID_BANKS; i++)
+	{
+		/* mask all events */
+		EVRT_MASK_CLR(i) = 0xFFFFFFFF;
+		/* clear all pending events */
+		EVRT_INT_CLR(i) = 0xFFFFFFFF;
+
+		for (j = 0; j < EVT_MAX_VALID_INT_OUT; j++)
+		{
+			/* mask all events */
+			EVRT_OUT_MASK_CLR(j,i) = 0xFFFFFFFF;
+		}
+	}
+
+	/* Clear and disable all interrupts. Start from index 1 since 0 is unused.*/
+	for (irq = 1; irq < NR_IRQ_CPU; irq++) {
+		/* Set the initial control values */
+		INTC_REQ_REG(irq) = INTC_REQ_WE_ENABLE;
+
+		/* Initialize as high-active, Disable the interrupt,
+		* Set target to IRQ , Set priority level to 1 (= lowest) for
+		* all the interrupt lines */
+		INTC_REQ_REG(irq) = INTC_REQ_WE_ACT_LOW |
+			INTC_REQ_WE_ENABLE |
+			INTC_REQ_TARGET_IRQ |
+			INTC_REQ_PRIO_LVL(1) |
+			INTC_REQ_WE_PRIO_LVL;
+
+		irq_set_chip_and_handler(irq, &lpc313x_internal_chip,
+					 handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	/* Now configure external/board interrupts using event router */
+	for (irq = IRQ_EVT_START; irq < NR_IRQS; irq++) {
+		/* compute bank & bit position for the event_pin */
+		bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
+		bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
+		
+		printk("irq=%d Event=0x%x bank:%d bit:%d type:%d\r\n", irq,
+			irq_2_event[irq - IRQ_EVT_START].event_pin, bank,
+			bit_pos, irq_2_event[irq - IRQ_EVT_START].type);
+
+		irq_set_chip(irq, &lpc313x_evtr_chip);
+		set_irq_flags(irq, IRQF_VALID);
+		/* configure the interrupt senstivity */
+		switch (irq_2_event[irq - IRQ_EVT_START].type) {
+			case EVT_ACTIVE_LOW:
+				EVRT_APR(bank) &= ~_BIT(bit_pos);
+				EVRT_ATR(bank) &= ~_BIT(bit_pos);
+				irq_set_handler(irq, handle_level_irq);
+				break;
+			case EVT_ACTIVE_HIGH:
+				EVRT_APR(bank) |= _BIT(bit_pos);
+				EVRT_ATR(bank) &= ~_BIT(bit_pos);
+				irq_set_handler(irq, handle_level_irq);
+				break;
+			case EVT_FALLING_EDGE:
+				EVRT_APR(bank) &= ~_BIT(bit_pos);
+				EVRT_ATR(bank) |= _BIT(bit_pos);
+				irq_set_handler(irq, handle_edge_irq);
+				break;
+			case EVT_RISING_EDGE:
+				EVRT_APR(bank) |= _BIT(bit_pos);
+				EVRT_ATR(bank) |= _BIT(bit_pos);
+				irq_set_handler(irq, handle_edge_irq);
+				break;
+			case EVT_BOTH_EDGE:
+				EVRT_ATR(bank) |= _BIT(bit_pos);
+				irq_set_handler(irq, handle_edge_irq);
+			default:
+				printk("Invalid Event type.\r\n");
+				break;
+		}
+		if ( (irq >= IRQ_EVTR0_START) && (irq <= IRQ_EVTR0_END) ) {
+			/* enable routing to vector 0 */
+			EVRT_OUT_MASK_SET(0, bank) = _BIT(bit_pos);
+		} else if ( (irq >= IRQ_EVTR1_START) && (irq <= IRQ_EVTR1_END) ) {
+			/* enable routing to vector 1 */
+			EVRT_OUT_MASK_SET(1, bank) = _BIT(bit_pos);
+		} else if ( (irq >= IRQ_EVTR2_START) && (irq <= IRQ_EVTR2_END) ) {
+			/* enable routing to vector 2 */
+			EVRT_OUT_MASK_SET(2, bank) = _BIT(bit_pos);
+		} else if ( (irq >= IRQ_EVTR3_START) && (irq <= IRQ_EVTR3_END) ) {
+			/* enable routing to vector 3 */
+			EVRT_OUT_MASK_SET(3, bank) = _BIT(bit_pos);
+		} else {
+			printk("Invalid Event router setup.\r\n");
+		}
+	}
+	/* for power management. Wake from internal irqs */
+	EVRT_APR(3) &= ~_BIT(12);
+	EVRT_ATR(3) &= ~_BIT(12);
+	EVRT_MASK_SET(3) = _BIT(12);
+
+	/* install IRQ_EVT_ROUTER0  chain handler */
+#if IRQ_EVTR0_END
+	/* install chain handler for IRQ_EVT_ROUTER0 */
+	irq_set_chained_handler (IRQ_EVT_ROUTER0, router0_handler);
+#endif
+
+#if IRQ_EVTR1_END
+	/* install chain handler for IRQ_EVT_ROUTER1 */
+	irq_set_chained_handler (IRQ_EVT_ROUTER1, router1_handler);
+#endif
+
+#if IRQ_EVTR2_END
+	/* install chain handler for IRQ_EVT_ROUTER2 */
+	irq_set_chained_handler (IRQ_EVT_ROUTER2, router2_handler);
+#endif
+
+#if IRQ_EVTR3_END
+	/* install chain handler for IRQ_EVT_ROUTER3 */
+	irq_set_chained_handler (IRQ_EVT_ROUTER3, router3_handler);
+#endif
+
+	/* Set the priority treshold to 0, i.e. don't mask any interrupt */
+	/* on the basis of priority level, for both targets (IRQ/FIQ)    */
+	INTC_IRQ_PRI_MASK = 0;
+	INTC_FIQ_PRI_MASK = 0;
+}
+
+
diff --git a/arch/arm/mach-lpc31xx/leds.c b/arch/arm/mach-lpc31xx/leds.c
new file mode 100644
index 0000000..aea73b5
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/leds.c
@@ -0,0 +1,102 @@
+/*  linux/arch/arm/mach-lpc313x/leds.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * LED driver for val3153-based boards.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/leds.h>
+#include <mach/gpio.h>
+
+
+static inline void val3153_led_on(unsigned int led)
+{
+	gpio_set_value(led, 0);
+}
+
+static inline void val3153_led_off(unsigned int led)
+{
+	gpio_set_value(led, 1);
+}
+
+static inline void val3153_led_toggle(unsigned int led)
+{
+	unsigned long is_off = gpio_get_value(led);
+	if (is_off)
+		val3153_led_on(led);
+	else
+		val3153_led_off(led);
+}
+
+
+/*
+ * Handle LED events.
+ */
+static void val3153_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch(evt) {
+	case led_start:		/* System startup */
+		val3153_led_on(GPIO_GPIO0);
+		break;
+
+	case led_stop:		/* System stop / suspend */
+		val3153_led_off(GPIO_GPIO0);
+		break;
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:		/* Every 50 timer ticks */
+		val3153_led_toggle(GPIO_GPIO2);
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:	/* Entering idle state */
+		val3153_led_off(GPIO_GPIO0);
+		break;
+
+	case led_idle_end:	/* Exit idle state */
+		val3153_led_on(GPIO_GPIO0);
+		break;
+#endif
+
+	default:
+		break;
+	}
+
+	local_irq_restore(flags);
+}
+
+
+int __init leds_init(void)
+{
+	leds_event = val3153_leds_event;
+
+	leds_event(led_start);
+	return 0;
+}
+
+__initcall(leds_init);
diff --git a/arch/arm/mach-lpc31xx/pm.c b/arch/arm/mach-lpc31xx/pm.c
new file mode 100644
index 0000000..f244379
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/pm.c
@@ -0,0 +1,279 @@
+/*  linux/arch/arm/mach-lpc313x/leds.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * LPC313x/4x/5x power management.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/pm.h>
+#include <linux/rtc.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+
+
+#define LPC313x_ISRAM_VA io_p2v(ISRAM0_PHYS)
+
+/*
+ * Pointers used for sizing and copying suspend function data
+ */
+extern int lpc313x_suspend_mem(void);
+extern int lpc313x_suspend_mem_sz;
+
+
+/* Enable/Disable external refresh controller used by
+ * auto clock scaling feature of CGU.
+ */
+static void lpc313x_ext_refresh_en(int enable)
+{
+	if (enable)
+		SYS_MPMC_TESTMODE0 |= _BIT(12);
+	else
+		SYS_MPMC_TESTMODE0 &= ~_BIT(12);
+
+}
+static int lpc313x_pm_valid_state(suspend_state_t state)
+{
+	switch (state) {
+		case PM_SUSPEND_ON:
+		case PM_SUSPEND_STANDBY:
+		case PM_SUSPEND_MEM:
+			return 1;
+
+		default:
+			return 0;
+	}
+}
+
+
+static suspend_state_t target_state;
+
+/*
+ * Called after processes are frozen, but before we shutdown devices.
+ */
+static int lpc313x_pm_begin(suspend_state_t state)
+{
+	target_state = state;
+	return 0;
+}
+
+static void lpc313x_clk_debug(void)
+{
+#ifdef CONFIG_PM_DEBUG
+	u32 i, clk_pcr;
+	/* print all clocks which are not auto_wake enabled and are still
+	 * running before entering low-power states.
+	 */
+	for ( i = 0; i < CGU_SB_NR_CLK; i++) {
+		clk_pcr = CGU_SB->clk_pcr[i];
+		if ( (clk_pcr & CGU_SB_PCR_RUN) && 
+			((clk_pcr & CGU_SB_PCR_WAKE_EN) == 0) )
+			printk("Opps Clk: %d is still enabled\n", i);
+	}
+#endif
+}
+
+static int lpc313x_enter_sleep(u32 standby)
+{
+	int (*lpc313x_suspend_ptr) (u32);
+	int i;
+	u32 base_clk_state = 0;
+
+#if defined(BACKUP_ISRAM)
+	void *iram_swap_area;
+#endif
+
+	/* print clocks which are still on */
+	lpc313x_clk_debug();
+
+	lpc313x_ext_refresh_en(0);
+	/*
+	 * To simplify stand-by routine, set FFAST as source clock for the
+	 * non-active switch side of SYS, APB0, APB1, APB2 & APB3 domains.
+	 */
+	for (i = 0; i < 2; i++) {
+		if (CGU_SB->base_ssr[i] & CGU_SB_SCR_EN1)
+			CGU_SB->base_fs2[i] = CGU_FIN_SELECT_FFAST;
+		else
+			CGU_SB->base_fs1[i] = CGU_FIN_SELECT_FFAST;
+	}
+	if (standby == 0) {
+		/* switch off remaining pheripheral clock domains */
+		for (i = 2; i < CGU_SB_NR_BASE; i++) {
+			if (CGU_SB->base_scr[i] & CGU_SB_SCR_STOP)
+				base_clk_state |= _BIT(i);
+			else
+				CGU_SB->base_scr[i] |= CGU_SB_SCR_STOP;
+		}
+	} else {
+		/* we need to have interrupt controller clock on for 
+		 * internal events to wake us up.
+		 */
+		CGU_SB->clk_pcr[CGU_SB_INTC_CLK_ID] = CGU_SB_PCR_RUN;
+	}
+
+
+
+#if defined(BACKUP_ISRAM)
+	/* Allocate some space for temporary IRAM storage */
+	iram_swap_area = kmalloc(lpc313x_suspend_mem_sz, GFP_KERNEL);
+	if (!iram_swap_area) {
+		printk(KERN_ERR
+		       "PM Suspend: cannot allocate memory to save portion "
+			"of SRAM\n");
+		return -ENOMEM;
+	}
+	/* Backup a small area of IRAM used for the suspend code */
+	memcpy(iram_swap_area, (void *) LPC313x_ISRAM_VA,
+			lpc313x_suspend_mem_sz);
+#endif
+
+	/*
+	 * Copy code to suspend system into IRAM. The suspend code
+	 * needs to run from IRAM as DRAM may no longer be available
+	 * when the PLL is stopped.
+	 */
+	memcpy((void *) LPC313x_ISRAM_VA, &lpc313x_suspend_mem,
+			lpc313x_suspend_mem_sz);
+	flush_icache_range((unsigned long)LPC313x_ISRAM_VA,
+		(unsigned long)(LPC313x_ISRAM_VA) + lpc313x_suspend_mem_sz);
+
+	/* Transfer to suspend code in IRAM */
+	lpc313x_suspend_ptr = (void *) LPC313x_ISRAM_VA;
+	(void) lpc313x_suspend_ptr(standby);
+
+#if defined(BACKUP_ISRAM)
+	/* Restore original IRAM contents */
+	memcpy((void *) LPC313x_ISRAM_VA, iram_swap_area,
+			lpc313x_suspend_mem_sz);
+
+	kfree(iram_swap_area);
+#endif
+
+	if (standby == 0) {
+		/* switch on domains clocks which were switched off in this
+		 * routine.
+		 */
+		for (i = 2; i < CGU_SB_NR_BASE; i++) {
+			if ((base_clk_state & _BIT(i)) == 0)
+				CGU_SB->base_scr[i] &= ~CGU_SB_SCR_STOP;
+		}
+	} else {
+
+		/* resume the state of interrupt controller clock */
+		CGU_SB->clk_pcr[CGU_SB_INTC_CLK_ID] = CGU_SB_PCR_WAKE_EN |
+					CGU_SB_PCR_RUN | CGU_SB_PCR_AUTO;
+	}
+
+	lpc313x_ext_refresh_en(1);
+
+	return 0;
+}
+
+
+
+static int lpc313x_pm_enter(suspend_state_t state)
+{
+	int ret = 0;
+
+	switch (state) {
+		/*
+		 * Suspend-to-RAM is like STANDBY plus slow clock mode, so
+		 * drivers must suspend more deeply:  only the base domains
+		 * switches SYS_BABSE, APB0, APB1 are clocked using the
+		 * main oscillator. The system can be woken-up by EXTERNAL
+		 * events ONLY. Ie., external interrupts handles through
+		 * event router.
+		 */
+		case PM_SUSPEND_MEM:
+			ret = lpc313x_enter_sleep(0);
+			break;
+
+		/*
+		 * STANDBY mode has *all* drivers suspended; ignores irqs not
+		 * marked as 'wakeup' event sources; and reduces DRAM power.
+		 * System can be woken-up by internal events. The internal
+		 * blocks which are set to wake should have their clocks
+		 * running without WAK_EN bit set in CGU.
+		 */
+		case PM_SUSPEND_STANDBY:
+			ret = lpc313x_enter_sleep(1);
+			break;
+
+		case PM_SUSPEND_ON:
+			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			break;
+
+		default:
+			pr_debug("LPC31: PM - bogus suspend state %d\n", state);
+			goto error;
+	}
+
+	pr_debug("LPC31: PM - wakeup \n");
+
+error:
+	target_state = PM_SUSPEND_ON;
+	return ret;
+}
+
+/*
+ * Called right prior to thawing processes.
+ */
+static void lpc313x_pm_end(void)
+{
+	target_state = PM_SUSPEND_ON;
+}
+
+/*
+ * Call this from platform driver suspend() to see how deeply to suspend.
+ * For internal events to wake the chip we should not stop the module 
+ * clocks. 
+ */
+int lpc313x_entering_suspend_mem(void)
+{
+	return (target_state == PM_SUSPEND_MEM);
+}
+EXPORT_SYMBOL(lpc313x_entering_suspend_mem);
+
+
+static struct platform_suspend_ops lpc313x_pm_ops ={
+	.valid	= lpc313x_pm_valid_state,
+	.begin	= lpc313x_pm_begin,
+	.enter	= lpc313x_pm_enter,
+	.end	= lpc313x_pm_end,
+};
+
+static int __init lpc313x_pm_init(void)
+{
+	pr_info("LPC31: Power Management init.\n");
+
+	/* Make sure all systems clocks are marked
+	 * as wakeable.
+	 */
+
+
+	suspend_set_ops(&lpc313x_pm_ops);
+
+	return 0;
+}
+arch_initcall(lpc313x_pm_init);
diff --git a/arch/arm/mach-lpc31xx/pm_standby.S b/arch/arm/mach-lpc31xx/pm_standby.S
new file mode 100644
index 0000000..7da73c4
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/pm_standby.S
@@ -0,0 +1,216 @@
+/*  linux/arch/arm/mach-lpc313x/pm_standby.S
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2010 NXP semiconductors
+ *
+ * Power management code to put LPC313x in sleep state.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/linkage.h>
+#include <mach/hardware.h>
+
+#define HPLL_LOCK_TIMEOUT	1000
+
+/* CGU defines */
+#define LPC313x_CGU_NR_BASE     12
+
+/* CGU register offsets */
+#define LPC313x_CGU_PWR_OFS      0xC00
+#define LPC313x_CGU_HP0_MD_OFS   0xD00
+#define LPC313x_CGU_HP0_ST_OFS   0xD04
+#define LPC313x_CGU_HP1_MD_OFS   0xD38
+#define LPC313x_CGU_HP1_ST_OFS   0xD3C
+
+/* CGU bit defines */
+#define LPC313x_PWR_NORM		  (1)
+#define LPC313x_PWR_SLEEP		  (3)
+#define LPC313x_HP_ST_LOCK      (1 << 0)
+#define LPC313x_HP_MODE_PD      (1 << 2)
+#define LPC313x_HP_MODE_EN      (1 << 0)
+
+/* MPMC register offsets */
+#define LPC313x_MPMC_CTL_OFS    0x000
+#define LPC313x_MPMC_STAT_OFS   0x004
+#define LPC313x_MPMC_DYNC_OFS   0x020
+
+/* MPMC bit defines */
+#define LPC313x_MPMC_LOW        (0x5)
+#define LPC313x_MPMC_NORM       (0x1)
+#define LPC313x_DYNC_SR         (1 << 2)
+#define LPC313x_STAT_SR         (1 << 2)
+#define LPC313x_STAT_WB         (1 << 1)
+#define LPC313x_STAT_BS         (1 << 0)
+
+/*
+ * Wait until SYSTEM PLL (HPLL0) has locked.
+ */
+	.macro wait_hp0_lock
+	tst r10, #LPC313x_HP_MODE_PD
+	bne 2f
+	mov	r4, #HPLL_LOCK_TIMEOUT
+1:	sub	r4, r4, #1
+	cmp	r4, #0
+	beq	2f
+	ldr	r3, [r1, #LPC313x_CGU_HP0_ST_OFS]
+	tst	r3, #LPC313x_HP_ST_LOCK
+	beq	1b
+2:
+	.endm
+
+/*
+ * Wait until SYSTEM PLL (HPLL1) has locked.
+ */
+	.macro wait_hp1_lock
+	mov	r4, #HPLL_LOCK_TIMEOUT
+	tst r11, #LPC313x_HP_MODE_PD
+	bne 2f
+1:	sub	r4, r4, #1
+	cmp	r4, #0
+	beq	2f
+	ldr	r3, [r1, #LPC313x_CGU_HP1_ST_OFS]
+	tst	r3, #LPC313x_HP_ST_LOCK
+	beq	1b
+2:
+	.endm
+
+	.text
+
+ENTRY(lpc313x_suspend_mem)
+	/* Save registers on stack */
+	stmfd	sp!, {r0 - r12, lr}
+
+	/*
+	 * Register usage:
+	 *  R1 = Base address of LPC31 CGU
+	 *  R2 = Base address of LPC31 MPMC
+	 *  R3 = temporary register
+	 *  R4 = temporary register
+	 *  R5 = temporary register
+	 *  R6 = temporary register
+	 *  R7 = temporary register
+	 *  R8 = temporary register
+	 *  R9 = temporary register
+	 *  R10 = HPLL0 state
+	 *  R11 = HPLL1 state
+	 */
+	ldr	r1, .lpc313x_va_base_cgu
+	ldr	r2, .lpc313x_va_base_mpmc
+
+	/* Drain write buffer */
+	mcr	p15, 0, r0, c7, c10, 4
+
+	/* Put SDRAM in self-refresh mode */
+
+	/* Wait for SDRAM busy status to go busy and then idle
+	 * This guarantees a small windows where DRAM isn't busy
+	 */
+1:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_WB
+	bne 1b
+2:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_BS
+	beq 2b
+3:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_BS
+	bne 3b
+	mov r3, #LPC313x_DYNC_SR
+	/* Enable SDRAM self-refresh mode */
+	str	r3, [r2, #LPC313x_MPMC_DYNC_OFS]
+	/* wait until SDRAM enters self-refresh */
+4:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_SR
+	beq 4b
+	/* put MPMC in low-power mode */
+	mov r3, #LPC313x_MPMC_LOW
+	/* Enable SDRAM self-refresh mode */
+	str	r3, [r2, #LPC313x_MPMC_CTL_OFS]
+
+	/* Skip PLL power-down for standby. */
+	cmp r0, #0
+	bne 5f
+	/* Switch all bases domain clocks to FFAST.
+	 * lpc313x_enter_suspend_mem() is called before this.
+	 */
+	ldr	r5, [r1]
+	eor r5, r5, #3
+	str	r5, [r1]
+	ldr	r5, [r1, #4]
+	eor r5, r5, #3
+	str	r5, [r1, #4]
+
+	/*
+	 * power-down plls
+	 */
+	ldr	r10, [r1, #LPC313x_CGU_HP0_MD_OFS]
+	orr r3, r12, #LPC313x_HP_MODE_PD
+	str	r3, [r1, #LPC313x_CGU_HP0_MD_OFS]
+	ldr	r11, [r1, #LPC313x_CGU_HP1_MD_OFS]
+	orr r3, r12, #LPC313x_HP_MODE_PD
+	str	r3, [r1, #LPC313x_CGU_HP1_MD_OFS]
+
+	/* Go to sleep zzzzzzzzz */
+5:	mov r3, #LPC313x_PWR_SLEEP
+	str r3, [r1, #LPC313x_CGU_PWR_OFS]
+
+	/* Skip PLL power-ups for standby. */
+	cmp r0, #0
+	bne 6f
+	/* Turn on plls */
+	str	r10, [r1, #LPC313x_CGU_HP0_MD_OFS]
+	str	r11, [r1, #LPC313x_CGU_HP1_MD_OFS]
+
+	wait_hp0_lock
+	wait_hp1_lock
+
+	/*
+	 * Restore domain clocks
+	 */
+	ldr	r5, [r1]
+	eor r5, r5, #3
+	str	r5, [r1]
+	ldr	r5, [r1, #4]
+	eor r5, r5, #3
+	str	r5, [r1, #4]
+
+	/* restore MPMC from low-power mode */
+6:	MOV r3, #LPC313x_MPMC_NORM
+	/* Enable SDRAM self-refresh mode */
+	str	r3, [r2, #LPC313x_MPMC_CTL_OFS]
+
+	/* Restore dync_ctl. Remove self-refresh. */
+	mov r3, #0
+	str	r3, [r2, #LPC313x_MPMC_DYNC_OFS]
+	/* wait until SDRAM exits self-refresh */
+7:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
+	tst r4, #LPC313x_STAT_SR
+	bne 7b
+
+	/* Restore registers, and return */
+	ldmfd	sp!, {r0 - r12, pc}
+
+
+.lpc313x_va_base_cgu:
+	.word io_p2v(CGU_SB_PHYS)
+
+.lpc313x_va_base_mpmc:
+	.word io_p2v(MPMC_PHYS)
+
+ENTRY(lpc313x_suspend_mem_sz)
+	.word .-lpc313x_suspend_mem
+
+
diff --git a/arch/arm/mach-lpc31xx/psu.c b/arch/arm/mach-lpc31xx/psu.c
new file mode 100644
index 0000000..45b187e
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/psu.c
@@ -0,0 +1,227 @@
+/*  linux/arch/arm/mach-lpc313x/leds.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Analog die register interface (via sysfs) driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/leds.h>
+#include <linux/input.h>
+#include <linux/mutex.h>
+#include <linux/i2c.h>
+#include <linux/hwmon-sysfs.h>
+#include <mach/hardware.h>
+
+/* Analog die I2C Register offsets*/
+#define    AD_REG_OTGDCLIC_RW                            0x0000
+#define    AD_REG_DCDCLIC_RO                             0x0001
+#define    AD_REG_CGU_RW                                 0x0002
+#define    AD_REG_AIN_0_RW                               0x0010
+#define    AD_REG_AIN_1_RW                               0x0011
+#define    AD_REG_AOUT_RW                                0x0012
+#define    AD_REG_DEC_RW                                 0x0013
+#define    AD_REG_INT_0_RW                               0x0014
+#define    AD_REG_INT_1_RW                               0x0015
+#define    AD_REG_DAIOMUX_RW                             0x0016
+#define    AD_REG_AOUTDECINT_RO                          0x0017
+#define    AD_REG_RTC_TIME                               0x0020
+#define    AD_REG_RTC_ALARM_TIME                         0x0021
+#define    AD_REG_RTC_STATUS                             0x0022
+#define    AD_REG_RTC_SET_ENA_STAT                       0x0023
+#define    AD_REG_RTC_CLR_ENA_STAT                       0x0024
+#define    AD_REG_MOD_ID                                 0x03FF
+
+struct psu_data {
+	struct i2c_client *client;
+};
+
+static struct psu_data g_pca_data;
+
+/* I2C client structure is required for I2C communications.
+ * The probe function is called only once when driver is added.
+ * Hence the following function be used by the other drivers,
+ * to get I2C client structure
+ */
+struct i2c_client *lpc315x_ad_get_i2c_client_struct(void)
+{
+	/* Check if psu_data structure is initialised */
+	if(!g_pca_data.client) {
+		printk(KERN_ERR "I2C not initialised \r\n");
+		return NULL;
+	}
+
+	return g_pca_data.client;
+}
+EXPORT_SYMBOL(lpc315x_ad_get_i2c_client_struct);
+
+/* following are the sysfs callback functions */
+static ssize_t psu_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct sensor_device_attribute *psa = to_sensor_dev_attr(attr);
+	struct i2c_client *client = to_i2c_client(dev);
+	char reg_adr[2];
+	u32 reg_val = 0;
+
+	reg_adr[0] = (psa->index >> 8) & 0xFF;
+	reg_adr[1] = psa->index & 0xFF;
+
+	i2c_master_send(client, reg_adr, 2);
+	i2c_master_recv(client, (char*)&reg_val, 4);
+	return sprintf(buf, "0x%08x\n", reg_val);
+}
+
+static ssize_t psu_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct sensor_device_attribute *psa = to_sensor_dev_attr(attr);
+	struct i2c_client *client = to_i2c_client(dev);
+	unsigned long val = simple_strtoul(buf, NULL, 0);
+	char data[6];
+
+	if (val > 0xff)
+		return -EINVAL;
+	/* 16 bit register address */
+	data[0] = (psa->index >> 8) & 0xFF;
+	data[1] = psa->index & 0xFF;
+	/* 32 bit register value */
+	data[2] = (val >> 24) & 0xFF;
+	data[3] = (val >> 16) & 0xFF;
+	data[4] = (val >> 8) & 0xFF;
+	data[5] = val & 0xFF;
+
+	i2c_master_send(client, data, 6);
+	return count;
+}
+
+/* Define the device attributes */
+
+#define PSU_ENTRY_RO(name, cmd_idx) \
+	static SENSOR_DEVICE_ATTR(name, S_IRUGO, psu_show, NULL, cmd_idx)
+
+#define PSU_ENTRY_RW(name, cmd_idx) \
+	static SENSOR_DEVICE_ATTR(name, S_IRUGO | S_IWUSR, psu_show, \
+				  psu_store, cmd_idx)
+
+PSU_ENTRY_RW(otgdclic, AD_REG_OTGDCLIC_RW);
+PSU_ENTRY_RO(dcdclic, AD_REG_DCDCLIC_RO);
+PSU_ENTRY_RW(cgu, AD_REG_CGU_RW);
+PSU_ENTRY_RW(ain_0, AD_REG_AIN_0_RW);
+PSU_ENTRY_RW(ain_1, AD_REG_AIN_1_RW);
+PSU_ENTRY_RW(aout, AD_REG_AOUT_RW);
+PSU_ENTRY_RW(dec, AD_REG_DEC_RW);
+PSU_ENTRY_RW(int_0, AD_REG_INT_0_RW);
+PSU_ENTRY_RW(int_1, AD_REG_INT_1_RW);
+PSU_ENTRY_RW(daiomux, AD_REG_DAIOMUX_RW);
+PSU_ENTRY_RO(aoutdecint, AD_REG_AOUTDECINT_RO);
+PSU_ENTRY_RW(rtc_time, AD_REG_RTC_TIME);
+PSU_ENTRY_RW(rtc_alarm_time, AD_REG_RTC_ALARM_TIME);
+PSU_ENTRY_RW(rtc_status, AD_REG_RTC_STATUS);
+PSU_ENTRY_RW(rtc_set_ena_stat, AD_REG_RTC_SET_ENA_STAT);
+PSU_ENTRY_RW(rtc_clr_ena_stat, AD_REG_RTC_CLR_ENA_STAT);
+PSU_ENTRY_RO(mod_id, AD_REG_MOD_ID);
+
+static struct attribute *psu_attributes[] = {
+	&sensor_dev_attr_otgdclic.dev_attr.attr,
+	&sensor_dev_attr_dcdclic.dev_attr.attr,
+	&sensor_dev_attr_cgu.dev_attr.attr,
+	&sensor_dev_attr_ain_0.dev_attr.attr,
+	&sensor_dev_attr_ain_1.dev_attr.attr,
+	&sensor_dev_attr_aout.dev_attr.attr,
+	&sensor_dev_attr_dec.dev_attr.attr,
+	&sensor_dev_attr_int_0.dev_attr.attr,
+	&sensor_dev_attr_int_1.dev_attr.attr,
+	&sensor_dev_attr_daiomux.dev_attr.attr,
+	&sensor_dev_attr_aoutdecint.dev_attr.attr,
+	&sensor_dev_attr_rtc_time.dev_attr.attr,
+	&sensor_dev_attr_rtc_alarm_time.dev_attr.attr,
+	&sensor_dev_attr_rtc_status.dev_attr.attr,
+	&sensor_dev_attr_rtc_set_ena_stat.dev_attr.attr,
+	&sensor_dev_attr_rtc_clr_ena_stat.dev_attr.attr,
+	&sensor_dev_attr_mod_id.dev_attr.attr,
+	NULL
+};
+
+static struct attribute_group psu_defattr_group = {
+	.attrs = psu_attributes,
+};
+
+
+static int psu_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct psu_data *data = &g_pca_data;
+
+	printk(KERN_INFO "PSU_probe\n");
+	if (!i2c_check_functionality(client->adapter,
+		I2C_FUNC_SMBUS_BYTE_DATA))
+		return -EIO;
+
+	memset(data, 0, sizeof(struct psu_data));
+
+	dev_info(&client->dev, "setting platform data\n");
+	i2c_set_clientdata(client, data);
+	data->client = client;
+
+	printk(KERN_INFO "PSU_probe 1\n");
+       /* Register sysfs hooks */
+	return sysfs_create_group(&client->dev.kobj,
+				  &psu_defattr_group);
+}
+
+static int psu_remove(struct i2c_client *client)
+{
+	struct psu_data *data = i2c_get_clientdata(client);
+	sysfs_remove_group(&client->dev.kobj, &psu_defattr_group);
+	kfree(data);
+	i2c_set_clientdata(client, NULL);
+	return 0;
+}
+
+static const struct i2c_device_id psu_id[] = {
+	{ "lpc3152-psu", 0 },
+	{ }
+};
+
+static struct i2c_driver psu_driver = {
+	.driver = {
+		.name   = "lpc3152-psu",
+	},
+	.id_table = psu_id,
+	.probe  = psu_probe,
+	.remove = psu_remove,
+};
+
+static int __init psu_init(void)
+{
+	cgu_clk_en_dis(CGU_SB_SYSCLK_O_ID, 1);
+	return i2c_add_driver(&psu_driver);
+}
+
+static void __exit psu_exit(void)
+{
+	i2c_del_driver(&psu_driver);
+}
+
+module_init(psu_init);
+module_exit(psu_exit);
+
diff --git a/arch/arm/mach-lpc31xx/time.c b/arch/arm/mach-lpc31xx/time.c
new file mode 100644
index 0000000..d0a34ec
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/time.c
@@ -0,0 +1,96 @@
+/*  arch/arm/mach-lpc313x/time.c
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ *  Timer driver for LPC313x & LPC315x.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/time.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+
+#include <asm/mach/time.h>
+#include <mach/gpio.h>
+#include <mach/board.h>
+//#include <mach/cgu.h>
+
+
+static irqreturn_t lpc313x_timer_interrupt(int irq, void *dev_id)
+{
+	TIMER_CLEAR(TIMER0_PHYS) = 0;
+	timer_tick();
+	return IRQ_HANDLED;
+}
+
+static struct irqaction lpc313x_timer_irq = {
+	.name		= "LPC313x Timer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= lpc313x_timer_interrupt,
+};
+
+static void __init lpc313x_timer_init (void)
+{
+	/* Switch on needed Timer clocks & switch off others*/
+	cgu_clk_en_dis(CGU_SB_TIMER0_PCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_TIMER1_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_TIMER2_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_TIMER3_PCLK_ID, 0);
+
+	/* Stop/disable all timers */
+	TIMER_CONTROL(TIMER0_PHYS) = 0;
+
+	TIMER_LOAD(TIMER0_PHYS) = LATCH;
+	TIMER_CONTROL(TIMER0_PHYS) = (TM_CTRL_ENABLE | TM_CTRL_PERIODIC);
+	TIMER_CLEAR(TIMER0_PHYS) = 0;
+	setup_irq (IRQ_TIMER0, &lpc313x_timer_irq);
+}
+
+/*!
+ * Returns number of us since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ */
+static unsigned long lpc313x_gettimeoffset(void)
+{
+	u32 elapsed = LATCH - TIMER_VALUE(TIMER0_PHYS);
+	return ((elapsed * 100) / (XTAL_CLOCK / 20000));
+}
+
+static void lpc313x_timer_suspend(void)
+{
+	TIMER_CONTROL(TIMER0_PHYS) &= ~TM_CTRL_ENABLE;	/* disable timers */
+}
+
+static void lpc313x_timer_resume(void)
+{
+	TIMER_CONTROL(TIMER0_PHYS) |= TM_CTRL_ENABLE;	/* enable timers */
+}
+
+
+struct sys_timer lpc313x_timer = {
+	.init = lpc313x_timer_init,
+	.offset = lpc313x_gettimeoffset,
+	.suspend = lpc313x_timer_suspend,
+	.resume = lpc313x_timer_resume,
+};
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
new file mode 100644
index 0000000..37ff9f0
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -0,0 +1,301 @@
+/* linux/arch/arm/mach-lpc313x/usb.c -- platform level USB initialization
+ *
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * USB initialization code.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#undef	DEBUG
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mod_devicetable.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/fsl_devices.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+
+/****************************************************************************
+* USBOTG register definition
+****************************************************************************/
+#define USB_DEV_USBCMD			__REG(USBOTG_PHYS + 0x140)
+#define USB_DEV_USBSTS			__REG(USBOTG_PHYS + 0x144)
+#define USB_DEV_USBINTR			__REG(USBOTG_PHYS + 0x148)
+#define USB_DEV_FRINDEX			__REG(USBOTG_PHYS + 0x14C)
+#define USB_DEV_CONFIGFLAG              __REG(USBOTG_PHYS + 0x180)
+#define USB_DEV_PORTSC1			__REG(USBOTG_PHYS + 0x184)
+#define USB_DEV_OTGSC			__REG(USBOTG_PHYS + 0x1A4)
+#define USB_DEV_USBMODE			__REG(USBOTG_PHYS + 0x1A8)
+
+/* bit defines for USBCMD register */
+#define USBCMD_RS	  _BIT(0)
+#define USBCMD_RST	  _BIT(1)
+#define USBCMD_ATDTW	  _BIT(12)
+#define USBCMD_SUTW	  _BIT(13)
+
+/* bit defines for PRTSC1 register */
+#define USBPRTS_CCS	  _BIT(0)
+#define USBPRTS_PE	  _BIT(2)
+#define USBPRTS_FPR	  _BIT(6)
+#define USBPRTS_SUSP	  _BIT(7)
+#define USBPRTS_PR	  _BIT(8)
+#define USBPRTS_HSP	  _BIT(9)
+#define USBPRTS_PLPSCD	  _BIT(23)
+#define USBPRTS_PFSC	  _BIT(24)
+
+/* bit defines for OTGSC register */
+#define OTGSC_VD          _BIT(0)
+#define OTGSC_VC          _BIT(1)
+#define OTGSC_HAAR        _BIT(2)
+#define OTGSC_OT          _BIT(3)
+#define OTGSC_DP          _BIT(4)
+#define OTGSC_IDPU        _BIT(5)
+#define OTGSC_HADP        _BIT(6)
+#define OTGSC_HABA        _BIT(7)
+
+#define OTGSC_ID_INT      0
+#define OTGSC_AVV_INT     1
+#define OTGSC_ASV_INT     2
+#define OTGSC_BSV_INT     3
+#define OTGSC_BSE_INT     4
+#define OTGSC_1mST_INT    5
+#define OTGSC_DPS_INT     6
+#define OTGSC_STATUS(n)   _BIT(8 + (n))
+#define OTGSC_INT_STAT(n) _BIT(16 + (n))
+#define OTGSC_INT_EN(n)   _BIT(24 + (n))
+#define OTGSC_INT_STAT_MASK (0x007F0000)
+
+/*-------------------------------------------------------------------------*/
+static struct resource lpc313x_usb_resource[] = {
+	[0] = {
+		.start = (u32) (USBOTG_PHYS),
+		.end   = (u32) (USBOTG_PHYS + SZ_4K),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_USB,
+		.end   = IRQ_USB,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct lpc313x_usb_board_t {
+	/* timer for VBUS enable */
+	struct timer_list	vbus_timer;
+	/* board specific over current monitor */
+	int	vbus_ovrc_irq;
+};
+
+static struct lpc313x_usb_board_t lpc313x_usb_brd;
+
+static u64 usb_dmamask = 0xffffffffUL;;
+static void	lpc313x_usb_release(struct device *dev);
+
+struct fsl_usb2_platform_data lpc313x_fsl_config = {
+#if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
+	.operating_mode = FSL_USB2_DR_OTG,
+#elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_DEVICE,
+#elif !defined(CONFIG_USB_GADGET_FSL_USB2) && defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_HOST,
+#endif
+	.phy_mode = FSL_USB2_PHY_UTMI,
+};
+
+#if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
+
+static struct platform_device lpc313x_udc_device = {
+	.name = "fsl-usb2-udc",
+	.dev = {
+		.dma_mask          = &usb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.release           = lpc313x_usb_release,
+		.platform_data     = &lpc313x_fsl_config,
+	},
+	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
+	.resource      = lpc313x_usb_resource,
+};
+#endif
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_OTG)
+
+static struct platform_device lpc313x_ehci_device = {
+	.name		= "lpc-ehci",
+	.dev = {
+		.dma_mask          = &usb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.release           = lpc313x_usb_release,
+		.platform_data     = &lpc313x_fsl_config,
+	},
+	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
+	.resource      = lpc313x_usb_resource,
+};
+#endif
+
+
+/*-------------------------------------------------------------------------*/
+static void	lpc313x_usb_release(struct device *dev)
+{
+	// do nothing
+}
+
+static irqreturn_t lpc313x_vbus_ovrc_irq(int irq, void *data)
+{
+	struct lpc313x_usb_board_t* brd = data;
+	/* disable VBUS power */
+	lpc313x_vbus_power(0);
+	/* Disable over current IRQ */
+	disable_irq_nosync(irq);
+	printk(KERN_INFO "Disabling VBUS as device is drawing too much current!!\n");
+	printk(KERN_INFO "Please disconnect the high-power USB device!!\n");
+
+	/* start the timer to re-enable power to VBUS and IRQ */
+	mod_timer(&brd->vbus_timer, jiffies + msecs_to_jiffies(2000));
+
+	return IRQ_HANDLED;
+}
+
+static void lpc313x_vbusen_timer(unsigned long data)
+{
+	struct lpc313x_usb_board_t* brd = (struct lpc313x_usb_board_t*)data;
+	/* enable VBUS power */
+	lpc313x_vbus_power(1);
+	msleep(2);
+	/* enable the VBUS overcurrent monitoring IRQ */
+	enable_irq(brd->vbus_ovrc_irq);
+}
+
+
+/*-------------------------------------------------------------------------*/
+int __init usbotg_init(void)
+{
+	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	int retval = 0;
+
+	/* enable USB to AHB clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 1);
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
+
+	/* reset USB block */
+	cgu_soft_reset_module(USB_OTG_AHB_RST_N_SOFT);
+
+	/* check if bootloader already enabled USB PLL */
+	if (SYS_USB_ATX_PLL_PD_REG != 0) {
+		/* enable USB OTG PLL */
+		SYS_USB_ATX_PLL_PD_REG = 0x0;
+		/* wait for PLL to lock */
+		while (!(EVRT_RSR(bank) & _BIT(bit_pos)));
+	}
+
+	/* reset the controller */
+	USB_DEV_USBCMD = USBCMD_RST;
+	/* wait for reset to complete */
+	while (USB_DEV_USBCMD & USBCMD_RST);
+
+	/* enable pull-up on ID pin so that we detect external pull-downs*/
+	USB_DEV_OTGSC |= OTGSC_IDPU;
+	/* delay */
+	udelay(5);
+	
+	/* check ID state */
+	if ((USB_DEV_OTGSC & OTGSC_STATUS(OTGSC_ID_INT))) {
+#if defined(CONFIG_USB_GADGET_FSL_USB2)
+		/* register gadget */
+		printk(KERN_INFO "Registering USB gadget 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
+		retval = platform_device_register(&lpc313x_udc_device);
+		if ( 0 != retval )
+			printk(KERN_INFO "Can't register lpc313x_udc_device device\n");
+#else
+		printk(KERN_ERR "Unable to register USB gadget. Check USB_ID jumper!!!!!\n");
+#endif
+	} else {
+#if defined(CONFIG_USB_EHCI_HCD)
+		/* enable VBUS power */
+		lpc313x_vbus_power(1);
+		msleep(2);
+
+		/* register host */
+		printk(KERN_INFO "Registering USB host 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
+		retval = platform_device_register(&lpc313x_ehci_device);
+		if ( 0 != retval )
+			printk(KERN_INFO "Can't register lpc313x_ehci_device device\n");
+
+		/* Create VBUS enable timer */
+		setup_timer(&lpc313x_usb_brd.vbus_timer, lpc313x_vbusen_timer,
+				(unsigned long)&lpc313x_usb_brd);
+
+#if defined(CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
+		/* set thw I2SRX_WS0 pin as GPIO_IN for vbus overcurrent flag */
+		retval = gpio_request(GPIO_I2SRX_WS0, "vbus overcurrent");
+		if ( 0 != retval )
+			printk(KERN_INFO "Can't acquire GPIO_I2SRX_WS0\n");
+		gpio_direction_input(GPIO_I2SRX_WS0);
+		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_EA_VBUS_OVRC;
+
+#else
+		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_VBUS_OVRC;
+#endif
+
+		/* request IRQ to handle VBUS power event */
+		retval = request_irq( lpc313x_usb_brd.vbus_ovrc_irq, lpc313x_vbus_ovrc_irq, 
+			IRQF_DISABLED, "VBUSOVR", 
+			&lpc313x_usb_brd);
+
+		if ( 0 != retval )
+			printk(KERN_INFO "Unable to register IRQ_VBUS_OVRC handler\n");
+		
+#else
+		printk(KERN_ERR "Unable to register USB host. Check USB_ID jumper!!!!!\n");
+#endif
+	}
+	
+#if !defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_OTG) && !defined(CONFIG_USB_EHCI_HCD)
+	/* if no USB component is enabled power-down USB block */
+	/* put in host mode */
+	USB_DEV_USBMODE = 0x3;
+
+	/* switch off PHY clock */
+	USB_DEV_PORTSC1 |= 0x00000080;
+	USB_DEV_PORTSC1 |= 0x00800000;
+
+	/* power off USB PLL */
+	SYS_USB_ATX_PLL_PD_REG = 1;
+	/* disable USB to AHB clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 0);
+#endif
+
+	return retval;
+}
+
+arch_initcall(usbotg_init);
diff --git a/arch/arm/mach-lpc31xx/wdt.c b/arch/arm/mach-lpc31xx/wdt.c
new file mode 100644
index 0000000..0cf5d37
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/wdt.c
@@ -0,0 +1,47 @@
+/*
+ * LPC313x Watchdog timer device registration
+ *
+ * drivers/watchdog/wdt_lpc313x.c
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/platform_device.h>
+#include <mach/constants.h>
+#include <mach/irqs.h>
+
+static struct resource watchdog_resources[] = {
+	{
+		.start = WDT_PHYS,
+		.end = WDT_PHYS + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device watchdog_device = {
+	.name = "lpc313x-wdt",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(watchdog_resources),
+	.resource = watchdog_resources,
+};
+
+static int __init wdt_device_init(void)
+{
+	return platform_device_register(&watchdog_device);
+}
+
+arch_initcall(wdt_device_init);
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index ccbe16f..a1e221b 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -429,7 +429,43 @@ raumfeld_rc		MACH_RAUMFELD_RC	RAUMFELD_RC		2413
 raumfeld_connector	MACH_RAUMFELD_CONNECTOR	RAUMFELD_CONNECTOR	2414
 raumfeld_speaker	MACH_RAUMFELD_SPEAKER	RAUMFELD_SPEAKER	2415
 tnetv107x		MACH_TNETV107X		TNETV107X		2418
+snake			MACH_SNAKE		SNAKE			2419
+cwmx27			MACH_CWMX27		CWMX27			2420
+sch_m480		MACH_SCH_M480		SCH_M480		2421
+platypus		MACH_PLATYPUS		PLATYPUS		2422
+pss2			MACH_PSS2		PSS2			2423
+davinci_apm150		MACH_DAVINCI_APM150	DAVINCI_APM150		2424
+str9100			MACH_STR9100		STR9100			2425
+net5big			MACH_NET5BIG		NET5BIG			2426
+seabed9263		MACH_SEABED9263		SEABED9263		2427
 mx51_m2id		MACH_MX51_M2ID		MX51_M2ID		2428
+octvocplus_eb		MACH_OCTVOCPLUS_EB	OCTVOCPLUS_EB		2429
+klk_firefox		MACH_KLK_FIREFOX	KLK_FIREFOX		2430
+klk_wirma_module	MACH_KLK_WIRMA_MODULE	KLK_WIRMA_MODULE	2431
+klk_wirma_mmi		MACH_KLK_WIRMA_MMI	KLK_WIRMA_MMI		2432
+supersonic		MACH_SUPERSONIC		SUPERSONIC		2433
+liberty			MACH_LIBERTY		LIBERTY			2434
+mh355			MACH_MH355		MH355			2435
+pc7802			MACH_PC7802		PC7802			2436
+gnet_sgc		MACH_GNET_SGC		GNET_SGC		2437
+einstein15		MACH_EINSTEIN15		EINSTEIN15		2438
+cmpd			MACH_CMPD		CMPD			2439
+davinci_hase1		MACH_DAVINCI_HASE1	DAVINCI_HASE1		2440
+lgeincitephone		MACH_LGEINCITEPHONE	LGEINCITEPHONE		2441
+ea313x			MACH_EA313X		EA313X			9998
+fwbd_39064		MACH_FWBD_39064		FWBD_39064		2443
+fwbd_390128		MACH_FWBD_390128	FWBD_390128		2444
+pelco_moe		MACH_PELCO_MOE		PELCO_MOE		2445
+minimix27		MACH_MINIMIX27		MINIMIX27		2446
+omap3_thunder		MACH_OMAP3_THUNDER	OMAP3_THUNDER		2447
+passionc		MACH_PASSIONC		PASSIONC		2448
+mx27amata		MACH_MX27AMATA		MX27AMATA		2449
+bgat1			MACH_BGAT1		BGAT1			2450
+buzz			MACH_BUZZ		BUZZ			2451
+mb9g20			MACH_MB9G20		MB9G20			2452
+yushan			MACH_YUSHAN		YUSHAN			2453
+lizard			MACH_LIZARD		LIZARD			2454
+omap3polycom		MACH_OMAP3POLYCOM	OMAP3POLYCOM		2455
 smdkv210		MACH_SMDKV210		SMDKV210		2456
 omap_zoom3		MACH_OMAP_ZOOM3		OMAP_ZOOM3		2464
 omap_3630sdp		MACH_OMAP_3630SDP	OMAP_3630SDP		2465
@@ -1126,3 +1162,7 @@ atdgp318		MACH_ATDGP318		ATDGP318		3494
 m28evk			MACH_M28EVK		M28EVK			3613
 smdk4212		MACH_SMDK4212		SMDK4212		3638
 smdk4412		MACH_SMDK4412		SMDK4412		3765
+val3153			MACH_VAL3153		VAL3153			9999
+val3154			MACH_VAL3154		VAL3154			9997
+ea3152			MACH_EA3152		EA3152			9996
+
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index a3afac4..bdf4c37 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -537,7 +537,7 @@ config I2C_PMCMSP
 
 config I2C_PNX
 	tristate "I2C bus support for Philips PNX and NXP LPC targets"
-	depends on ARCH_PNX4008 || ARCH_LPC32XX
+	depends on ARCH_PNX4008 || ARCH_LPC32XX || ARCH_LPC31XX
 	help
 	  This driver supports the Philips IP3204 I2C IP block master and/or
 	  slave controller
diff --git a/drivers/i2c/busses/i2c-pnx.c b/drivers/i2c/busses/i2c-pnx.c
index 627dbda..bee912b 100644
--- a/drivers/i2c/busses/i2c-pnx.c
+++ b/drivers/i2c/busses/i2c-pnx.c
@@ -175,7 +175,8 @@ static int i2c_pnx_master_xmit(struct i2c_pnx_algo_data *alg_data)
 		/* We still have something to talk about... */
 		val = *alg_data->mif.buf++;
 
-		if (alg_data->mif.len == 1)
+		/* last byte of a message */
+		if ((alg_data->mif.len == 1) && alg_data->last)
 			val |= stop_bit;
 
 		alg_data->mif.len--;
diff --git a/drivers/net/ethernet/cirrus/cs89x0.c b/drivers/net/ethernet/cirrus/cs89x0.c
index f328da2..a6e971f 100644
--- a/drivers/net/ethernet/cirrus/cs89x0.c
+++ b/drivers/net/ethernet/cirrus/cs89x0.c
@@ -183,6 +183,19 @@ static unsigned int cs8900_irq_map[] = {IRQ_IXDP2X01_CS8900, 0, 0, 0};
 #include <mach/qq2440.h>
 static unsigned int netcard_portlist[] __used __initdata = { QQ2440_CS8900_VIRT_BASE + 0x300, 0 };
 static unsigned int cs8900_irq_map[] = { QQ2440_CS8900_IRQ, 0, 0, 0 };
+#elif defined(CONFIG_ARCH_PNX010X)
+#include <mach/gpio.h>
+#define CIRRUS_DEFAULT_BASE	IO_ADDRESS(EXT_STATIC2_s0_BASE + 0x200000)	/* = Physical address 0x48200000 */
+#define CIRRUS_DEFAULT_IRQ	VH_INTC_INT_NUM_CASCADED_INTERRUPT_1 /* Event inputs bank 1 - ID 35/bit 3 */
+static unsigned int netcard_portlist[] __used __initdata = {CIRRUS_DEFAULT_BASE, 0};
+static unsigned int cs8900_irq_map[] = {CIRRUS_DEFAULT_IRQ, 0, 0, 0};
+#elif defined(CONFIG_MACH_VAL3153)
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#define CS8900_IOBARRIER	(*(volatile u16 __force*) io_p2v(INTC_PHYS))
+#define CIRRUS_DEFAULT_BASE	io_p2v(EXT_SRAM1_PHYS + 0x10000)	/* = Physical address 0x20030000 */
+static unsigned int netcard_portlist[] __used __initdata = {CIRRUS_DEFAULT_BASE, 0};
+static unsigned int cs8900_irq_map[] = {IRQ_CS8900_ETH_INT, 0, 0, 0};
 #elif defined(CONFIG_MACH_MX31ADS)
 #include <mach/board-mx31ads.h>
 static unsigned int netcard_portlist[] __used __initdata = {
@@ -321,6 +334,12 @@ struct net_device * __init cs89x0_probe(int unit)
 	if (net_debug)
 		printk("cs89x0:cs89x0_probe(0x%x)\n", io);
 
+#ifdef CONFIG_MACH_VAL3153
+	if(unit > 0) {
+		err = -ENODEV;
+		goto out;
+	}
+#endif
 	if (io > 0x1ff)	{	/* Check a single specified location. */
 		err = cs89x0_probe1(dev, io, 0);
 	} else if (io != 0) {	/* Don't probe at all. */
@@ -368,6 +387,37 @@ writeword(unsigned long base_addr, int portno, u16 value)
 {
 	__raw_writel(value, base_addr + (portno << 1));
 }
+#elif defined(CONFIG_ARCH_PNX010X)
+static u16
+readword(unsigned long base_addr, int portno)
+{
+	return inw(base_addr + (portno << 1));
+}
+
+static void
+writeword(unsigned long base_addr, int portno, u16 value)
+{
+	outw(value, base_addr + (portno << 1));
+}
+#elif defined(CONFIG_MACH_VAL3153)
+static u16
+readword(unsigned long base_addr, int portno)
+{
+	u16 v;
+	CS8900_IOBARRIER;
+	v = inw(base_addr + portno);
+	CS8900_IOBARRIER;
+	return v;
+}
+
+static void
+writeword(unsigned long base_addr, int portno, u16 value)
+{
+	CS8900_IOBARRIER;
+	outw(value, base_addr + portno);
+	CS8900_IOBARRIER;
+}
+
 #else
 static u16
 readword(unsigned long base_addr, int portno)
@@ -543,6 +593,12 @@ cs89x0_probe1(struct net_device *dev, int ioaddr, int modular)
 		goto out1;
 	}
 
+#if defined(CONFIG_MACH_VAL3153)
+	/* truely reset the chip */
+	writeword(ioaddr, ADD_PORT, 0x0114);
+	writeword(ioaddr, DATA_PORT, 0x0040);
+#endif
+
 	/* if they give us an odd I/O address, then do ONE write to
            the address port, to get it back to address zero, where we
            expect to find the EISA signature word. An IO with a base of 0x3
@@ -608,9 +664,12 @@ cs89x0_probe1(struct net_device *dev, int ioaddr, int modular)
 	   the driver will always do *something* instead of complain that
 	   adapter_cnf is 0. */
 
-
+/* quick hack for VAL3153 boards to reuse the mac address set by boot loader */
+#if !defined(CONFIG_MACH_VAL3153)
         if ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) ==
-	      (EEPROM_OK|EEPROM_PRESENT)) {
+	      (EEPROM_OK|EEPROM_PRESENT)) 
+#endif
+	{
 	        /* Load the MAC. */
 		for (i=0; i < ETH_ALEN/2; i++) {
 	                unsigned int Addr;
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index 2a22f52..ac989b0 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -874,6 +874,7 @@ static void dm9000_send_packet(struct net_device *dev,
 
 	/* Issue TX polling command */
 	iow(dm, DM9000_TCR, TCR_TXREQ);	/* Cleared after TX complete */
+	dev->trans_start = jiffies; /* save the time stamp */
 }
 
 /*
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index eadf33d..f08f78d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -47,7 +47,8 @@
 #define PORT_U6_16550A	19	/* ST-Ericsson U6xxx internal UART */
 #define PORT_TEGRA	20	/* NVIDIA Tegra internal UART */
 #define PORT_XR17D15X	21	/* Exar XR17D15x UART */
-#define PORT_MAX_8250	21	/* max port ID */
+#define PORT_NXP16750	22	
+#define PORT_MAX_8250	22	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
