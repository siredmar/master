sound support for lpc3xx

From: Jon Smirl <jonsmirl@terra.(none)>


---
 arch/arm/mach-lpc31xx/board-ea313x.c     |   39 +
 sound/soc/Kconfig                        |    1 
 sound/soc/Makefile                       |    1 
 sound/soc/codecs/Kconfig                 |    4 
 sound/soc/codecs/Makefile                |    3 
 sound/soc/codecs/lpc315x_codec.c         | 1559 ++++++++++++++++++++++++++++++
 sound/soc/codecs/lpc315x_codec.h         |  163 +++
 sound/soc/codecs/uda1380.c               |   22 
 sound/soc/lpc313x/Kconfig                |  196 ++++
 sound/soc/lpc313x/Makefile               |   18 
 sound/soc/lpc313x/lpc313x-i2s-clocking.c |  369 +++++++
 sound/soc/lpc313x/lpc313x-i2s-clocking.h |   66 +
 sound/soc/lpc313x/lpc313x-i2s.c          |  436 ++++++++
 sound/soc/lpc313x/lpc313x-i2s.h          |   31 +
 sound/soc/lpc313x/lpc313x-pcm.c          |  571 +++++++++++
 sound/soc/lpc313x/lpc313x-pcm.h          |   29 +
 sound/soc/lpc313x/lpc313x-uda1380.c      |  250 +++++
 sound/soc/lpc313x/lpc315x-codec.c        |  217 ++++
 18 files changed, 3974 insertions(+), 1 deletions(-)
 create mode 100644 sound/soc/codecs/lpc315x_codec.c
 create mode 100644 sound/soc/codecs/lpc315x_codec.h
 create mode 100644 sound/soc/lpc313x/Kconfig
 create mode 100644 sound/soc/lpc313x/Makefile
 create mode 100644 sound/soc/lpc313x/lpc313x-i2s-clocking.c
 create mode 100644 sound/soc/lpc313x/lpc313x-i2s-clocking.h
 create mode 100644 sound/soc/lpc313x/lpc313x-i2s.c
 create mode 100644 sound/soc/lpc313x/lpc313x-i2s.h
 create mode 100644 sound/soc/lpc313x/lpc313x-pcm.c
 create mode 100644 sound/soc/lpc313x/lpc313x-pcm.h
 create mode 100644 sound/soc/lpc313x/lpc313x-uda1380.c
 create mode 100644 sound/soc/lpc313x/lpc315x-codec.c

diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index 038bebf..bfd5678 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -374,7 +374,7 @@ static struct platform_device	lpc313x_nand_device = {
 	.dev		= {
 		.dma_mask		= &nand_dmamask,
 		.coherent_dma_mask	= 0xffffffff,
-				.platform_data	= &ea313x_plat_nand,
+		.platform_data	= &ea313x_plat_nand,
 	},
 	.num_resources	= ARRAY_SIZE(lpc313x_nand_resources),
 	.resource	= lpc313x_nand_resources,
@@ -528,6 +528,38 @@ arch_initcall(lpc313x_spimtd_register);
 #endif
 #endif
 
+#if defined(CONFIG_SND_USE_EA3131)
+
+static u64 audio_dmamask = 0xffffffffUL;
+static struct platform_device lpc313x_uda1380_device = {
+	.name		= "lpc313x-uda1380",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &audio_dmamask,
+		.coherent_dma_mask = 0xffffffffUL,
+	},
+};
+
+static struct platform_device lpc313x_i2s_device = {
+	.name		= "lpc313x-i2s",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &audio_dmamask,
+		.coherent_dma_mask = 0xffffffffUL,
+	},
+};
+
+static struct platform_device lpc313x_audio_device = {
+	.name		= "lpc313x-audio",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &audio_dmamask,
+		.coherent_dma_mask = 0xffffffffUL,
+	},
+};
+
+#endif
+
 static struct platform_device *devices[] __initdata = {
 	&lpc313x_mci_device,
 #if defined (CONFIG_MTD_NAND_LPC313X)
@@ -536,6 +568,11 @@ static struct platform_device *devices[] __initdata = {
 #if defined(CONFIG_SPI_LPC313X)
 	&lpc313x_spi_device,
 #endif
+#if defined(CONFIG_SND_USE_EA3131)
+	&lpc313x_uda1380_device,
+	&lpc313x_i2s_device,
+	&lpc313x_audio_device,
+#endif
 };
 
 static struct map_desc ea313x_io_desc[] __initdata = {
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 1381db8..fedc56d 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -60,6 +60,7 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
+source "sound/soc/lpc313x/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 9ea8ac8..9c0ea2d 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -22,3 +22,4 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
+obj-$(CONFIG_SND_SOC)	+= lpc313x/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index fa787d4..2cd29e2 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -47,6 +47,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_SSM2602 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_STA32X if I2C
 	select SND_SOC_STAC9766 if SND_SOC_AC97_BUS
+	select SND_SOC_LPC315X_CODEC if I2C
 	select SND_SOC_TLV320AIC23 if I2C
 	select SND_SOC_TLV320AIC26 if SPI_MASTER
 	select SND_SOC_TLV320AIC32X4 if I2C
@@ -269,6 +270,9 @@ config SND_SOC_TWL6040
 config SND_SOC_UDA134X
        tristate
 
+config SND_SOC_LPC315X_CODEC
+       tristate
+
 config SND_SOC_UDA1380
         tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a2c7842..423ba79 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -46,6 +46,7 @@ snd-soc-uda1380-objs := uda1380.o
 snd-soc-wl1273-objs := wl1273.o
 snd-soc-wm1250-ev1-objs := wm1250-ev1.o
 snd-soc-wm5100-objs := wm5100.o wm5100-tables.o
+snd-soc-lpc315x-codec-objs := lpc315x_codec.o
 snd-soc-wm8350-objs := wm8350.o
 snd-soc-wm8400-objs := wm8400.o
 snd-soc-wm8510-objs := wm8510.o
@@ -121,6 +122,7 @@ obj-$(CONFIG_SND_SOC_CX20442)	+= snd-soc-cx20442.o
 obj-$(CONFIG_SND_SOC_DA7210)	+= snd-soc-da7210.o
 obj-$(CONFIG_SND_SOC_DFBMCS320)	+= snd-soc-dfbmcs320.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
+obj-$(CONFIG_SND_SOC_LPC315X_CODEC)	+= snd-soc-lpc315x-codec.o
 obj-$(CONFIG_SND_SOC_L3)	+= snd-soc-l3.o
 obj-$(CONFIG_SND_SOC_JZ4740_CODEC)	+= snd-soc-jz4740-codec.o
 obj-$(CONFIG_SND_SOC_MAX98088)	+= snd-soc-max98088.o
@@ -195,3 +197,4 @@ obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
 obj-$(CONFIG_SND_SOC_WM2000)	+= snd-soc-wm2000.o
 obj-$(CONFIG_SND_SOC_WM9090)	+= snd-soc-wm9090.o
+
diff --git a/sound/soc/codecs/lpc315x_codec.c b/sound/soc/codecs/lpc315x_codec.c
new file mode 100644
index 0000000..546d649
--- /dev/null
+++ b/sound/soc/codecs/lpc315x_codec.c
@@ -0,0 +1,1559 @@
+/*
+ * sound/soc/codecs/lpc315x_codec.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/tlv.h>
+
+#include <mach/lpc315x_ad.h>
+#include "lpc315x_codec.h"
+
+#define ANALOG_DIE_I2C_ADDR 	(0x0C)
+
+#define DEC_GAIN 		(0x0)
+#define AVC_COA_VOL 		(0x7C0)
+#define AVC_FIN_VOL 		(0x1)
+
+/*
+ * LPC315X CODEC structure
+ * */
+static struct snd_soc_codec *lpc315x_codec;
+
+/*
+ * LPC315X codec private data
+ * */
+struct lpc315x_codec_priv {
+	struct snd_soc_codec	codec;
+	u32			lpc315x_reg_cache[LPC315X_CODEC_NUM_REGS];
+	struct work_struct	work;
+};
+static struct lpc315x_codec_priv *lpc315x_codec_prv;
+
+/*
+ * LPC315X CODEC register cache
+ */
+static const u32 lpc315x_codec_regs[LPC315X_CODEC_NUM_REGS] = {
+	0x00000000, /* PGA */
+	0x0002FFFC, /* AIN_1 */
+	0x8000F5FB, /* AOUT */
+	0x00000000, /* DEC */
+	0x00000200, /* INT0 */
+	0x00000000, /* INT1 */
+	0x00010303, /* I2SMUX1 */
+	0x00000000, /* DEC_STA */
+};
+
+/* Register cache dirty flags */
+static unsigned long lpc315x_codec_cache_dirty;
+
+/*
+ * Read LPC315X CODEC register cache
+ */
+static inline u32 lpc315x_codec_read_reg_cache(struct snd_soc_codec *codec,
+		unsigned int reg)
+{
+	u32 *cache = codec->reg_cache;
+
+	/* Check if register offset is valid */
+	if (reg > LPC315X_CODEC_DEC_STA) {
+		return -1;
+	}
+
+	/* Return data */
+	return cache[reg - LPC315X_CODEC_CODEC_START];
+}
+
+/*
+ * Write LPC315X CODEC register cache
+ */
+static inline void lpc315x_codec_write_reg_cache(struct snd_soc_codec
+		*codec, unsigned int reg, u32 value)
+{
+	u32 *cache = codec->reg_cache;
+
+	/* Check if register offset is valid */
+	if (reg > LPC315X_CODEC_DEC_STA)
+		return;
+
+	/* Set dirty flag */
+	if (cache[reg - LPC315X_CODEC_CODEC_START] != value) {
+		set_bit((reg - LPC315X_CODEC_CODEC_START),
+				&lpc315x_codec_cache_dirty);
+	}
+
+	/* Write to register cache */
+	cache[reg - LPC315X_CODEC_CODEC_START] = value;
+	return;
+}
+
+/*
+ * Write to LPC315X CODEC registers using I2C functions
+ */
+static int lpc315x_codec_register_rw(struct snd_soc_codec *codec,
+		unsigned int reg, u32 *value, int read)
+{
+	int ret = 0;
+	u8 off[2], data[6];
+	u32 val = 0;
+
+	if(read) {
+		/*
+		* Send register offsets:
+		*  data[0] is MSB of register offset (0x00)
+	 	*  data[1] is LSB of register offset
+		*  Read register data:
+	 	*  data[0] is Data bits 31:24
+	 	*  data[1] is Data bits 23:16
+	 	*  data[2] is Data bits 15:8
+	 	*  data[3] is Data bits 7:0
+	 	*/
+		/* Register offsets */
+		off[0] = (u8) ((reg >> 8) & 0xFF);
+		off[1] = (u8) (reg & 0xFF);
+
+		/* Read Operation */
+		if (codec->hw_write(codec->control_data, off, 2) == 2) {
+			if (i2c_master_recv(codec->control_data, data, 4) == 4) {
+				*value = ((data[0] & 0xFF) << 24);
+				*value |= ((data[1] & 0xFF) << 16);
+				*value |= ((data[2] & 0xFF) << 8);
+				*value |= (data[3] & 0xFF);
+				pr_debug("lpc315x codec read: hw read %x val %x\n", reg, *value);
+			}
+			else {
+				pr_debug("lpc315x codec read: hw read reg %x failed \n", reg);
+				ret = -EIO;
+			}
+		}
+		else {
+			pr_debug("lpc315x codec read: hw send addres %x failed \n", reg);
+			ret = -EIO;
+		}
+	}
+	else {
+		/*  Send register offsets, followed by data bytes
+	 	 *  data[0] is MSB of register offset (0x00)
+	 	 *  data[1] is LSB of register offset
+	 	 *  data[2] is Data bits 31:24
+	 	 *  data[3] is Data bits 23:16
+	 	 *  data[4] is Data bits 15:8
+	 	 *  data[5] is Data bits 7:0
+	 	*/
+		val = *value;
+		data[0] = (u8) ((reg >> 8) & 0xFF);
+		data[1] = (u8) (reg & 0xFF);
+		data[2] = (u8) ((val >> 24) & 0xFF);
+		data[3] = (u8) ((val >> 16) & 0xFF);
+		data[4] = (u8) ((val >> 8) & 0xFF);
+		data[5] = (u8) (val & 0xFF);
+
+		/* Write to CODEC register */
+		if (codec->hw_write(codec->control_data, data, 6) != 6) {
+			pr_debug("lpc315x codec write: hw reg write  %x failed \n", reg);
+			ret = -EIO;
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * Write to LPC315X CODEC register space
+ */
+static int lpc315x_codec_write(struct snd_soc_codec *codec,
+		unsigned int reg, unsigned int value)
+{
+	int ret = 0;
+
+	/* Write to reg cache */
+	lpc315x_codec_write_reg_cache(codec, reg, value);
+
+	/* Write to Analog Die register */
+	ret = lpc315x_codec_register_rw(codec, reg, &value, 0);
+	if(!ret) {
+		pr_debug("lpc315x codec: hw write %x val %x\n", reg, value);
+
+		/* Clear cache dirty flag */
+		clear_bit((reg - LPC315X_CODEC_CODEC_START),
+			&lpc315x_codec_cache_dirty);
+	}
+
+	return ret;
+}
+
+/*
+ * LPC315X CODEC work queue function
+ * */
+static void lpc315x_codec_work(struct work_struct *work)
+{
+	u16 bit, reg;
+	u32 data;
+
+	for_each_bit(bit, &lpc315x_codec_cache_dirty,
+			(LPC315X_CODEC_DEC_STA - LPC315X_CODEC_CODEC_START)) {
+		reg = bit + LPC315X_CODEC_CODEC_START;
+		data = lpc315x_codec_read_reg_cache(lpc315x_codec, reg);
+		lpc315x_codec_write(lpc315x_codec, reg, data);
+		clear_bit(bit, &lpc315x_codec_cache_dirty);
+	}
+}
+
+/*
+ * LPC315X CODEC volatge ramp up & ramp down function
+ * for Playback functionality
+ * This will be called after the DAC widget is powered up
+ * snd after powered down
+ * */
+static int lpc315x_codec_ref_vol(struct snd_soc_dapm_widget *w,
+				 struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	unsigned int cgu_reg = 0;
+	u32 aout_reg, int0_reg, ain_reg, int1_reg, i2srx1_reg;
+
+	switch(event) {
+	case SND_SOC_DAPM_POST_PMU:
+		/* Complete the power up sequence for playback.
+		 * This code will be executed after DACs are powered up
+		 * */
+		/* By Default, decimator is connected Interpolator.
+		 * Connect I2SRX1 output Interpolator.
+		 * */
+		i2srx1_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_I2SMUX1);
+		i2srx1_reg &= ~(LPC315X_CODEC_I2SMUX1_DEMUX_MSK);
+		lpc315x_codec_write(codec, LPC315X_CODEC_I2SMUX1, i2srx1_reg);
+
+		/* Connect DAC outputs to HP Amplifiers */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg |= LPC315X_CODEC_AOUT_SWDAC_ON;
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Ramp up Interpolator volatge */
+		int0_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_INT0);
+		int0_reg &= ~(LPC315X_CODEC_INT0_PD_DAC);
+		lpc315x_codec_write(codec, LPC315X_CODEC_INT0, int0_reg);
+		mdelay(30);
+
+		/* Ramp up Reference Volatge */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg |= LPC315X_CODEC_AOUT_VREF_SLOW_UP;
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+		mdelay(500);
+
+		/* Set Interpolator Volume & Unmute */
+		int1_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_INT1);
+		int1_reg &= ~(LPC315X_CODEC_INT1_MAS_MUTE |
+				LPC315X_CODEC_INT1_MAS_VOL_L_MSK |
+		     	     LPC315X_CODEC_INT1_MAS_VOL_R_MSK);
+		lpc315x_codec_write(codec, LPC315X_CODEC_INT1, int1_reg);
+
+		/* By default AVC is muted, set AVC Volume & unmute */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg &= ~(LPC315X_CODEC_AOUT_AVC_COA_GAIN_MSK |
+				LPC315X_CODEC_AOUT_AVC_FIN_GAIN_MSK);
+		aout_reg |=
+			((AVC_COA_VOL << LPC315X_CODEC_AOUT_AVC_COA_GAIN_POS)|
+			(AVC_FIN_VOL << LPC315X_CODEC_AOUT_AVC_FIN_GAIN_POS));
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		break;
+
+	case SND_SOC_DAPM_POST_PMD:
+		/* Complete the power down sequence for playback.
+		 * This code will be executed aftet DACs are powered down
+		 * */
+
+		/* Power down Central Reference source */
+		ain_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AIN1);
+		ain_reg |= (LPC315X_CODEC_AIN1_PD_VCOM_VREF1);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AIN1, ain_reg);
+
+		/* Power down Reference buffer Voltage */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg |= (LPC315X_CODEC_AOUT_VREF_SLOW);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Power down HP Amplifiers */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg |= (LPC315X_CODEC_AOUT_PD_HP_L |
+				LPC315X_CODEC_AOUT_PD_HP_C |
+				LPC315X_CODEC_AOUT_PD_HP_R );
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Switch off NS, DSP, DAC clocks */
+		lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+				&cgu_reg, 1);
+		cgu_reg |= (LPC315X_CODEC_CGU_PD_DSP_CLK |
+				LPC315X_CODEC_CGU_PD_NS_CLK |
+				LPC315X_CODEC_CGU_PD_I2SRX_BCLK |
+				LPC315X_CODEC_CGU_PD_I2SRX_SYSCLK |
+				LPC315X_CODEC_CGU_PD_I2C256FS_CLK |
+				LPC315X_CODEC_CGU_PD_DAC_CLK);
+		lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+				&cgu_reg, 0);
+		break;
+	default:
+		BUG();
+	}
+
+	return 0;
+}
+
+/* Digital Demux control */
+static const char *lpc315x_codec_dmux_sel[] = {
+	"I2SRX1",
+	"Decimator",
+};
+
+/* De-emphasis control */
+static const char *lpc315x_codec_deemp_sel[] = {
+	"None",
+	"32kHz",
+	"44.1kHz",
+	"48kHz",
+	"96kHz",
+};
+
+/* Silence detection time window */
+static const char *lpc315x_codec_sdet_sel[] = {
+	"3200fs samples",
+	"4800fs samples",
+	"9600fs samples",
+	"19200fs samples",
+};
+
+/* Nosie Shaper Enums */
+static const char *lpc315x_codec_ns_sel[] = {
+	"1-bit",
+	"4-bit",
+	"5-bit",
+	"6-bit",
+};
+
+/* Interpolator Input data rate Enums */
+static const char *lpc315x_codec_os_sel[] = {
+	"1fs",
+	"2fs0",
+	"2fs1",
+	"8fs",
+};
+
+/* Interpolator Filter Settings Enums */
+static const char *lpc315x_codec_fil_sel[] = {
+	"2fs-8fs FIR for slow0",
+	"2fs-8fs FIR for slow1",
+	"2fs-8fs FIR for slow2",
+	"2fs-8fs FIR for sharp",
+};
+
+/* Data Weight Enums */
+static const char *lpc315x_codec_dwa_sel[] = {
+	"Uni-Directional",
+	"Bi-Directional",
+};
+
+/* MUX0 enum */
+static const char *lpc315x_mux0_sel[] = {
+	"Tuner In",
+	"Line In",
+};
+
+/* MUX1 enum */
+static const char *lpc315x_mux1_sel[] = {
+	"Lin/Tun In",
+	"Mic In",
+};
+
+/* DAC Switch enum */
+static const char *lpc315x_swdac_sel[] = {
+	"AVC only",
+	"Both AVC & SDAC",
+};
+
+/* Digital Demux selection */
+static const struct soc_enum lpc315x_codec_dmux_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_I2SMUX1, 16, 2, lpc315x_codec_dmux_sel);
+
+/* from -64 to 63 dB in 0.5 dB steps (-128...63) */
+static DECLARE_TLV_DB_SCALE(int_gain_tlv, -6400, 50, 1);
+
+/* De-emphasis settings */
+static const struct soc_enum lpc315x_codec_deemp_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_INT0, 0, 5, lpc315x_codec_deemp_sel);
+
+/* Silence Detector Settings */
+static const struct soc_enum lpc315x_codec_sdet_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_INT0, 4, 4, lpc315x_codec_sdet_sel);
+
+/* Interpolator Input data rate */
+static const struct soc_enum lpc315x_codec_ns_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_INT0, 9, 4, lpc315x_codec_ns_sel);
+
+/* Interpolator Input data rate */
+static const struct soc_enum lpc315x_codec_os_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_INT0, 11, 4, lpc315x_codec_os_sel);
+
+/* Interpolator Filter Settings */
+static const struct soc_enum lpc315x_codec_fil_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_INT0, 13, 4, lpc315x_codec_fil_sel);
+
+/* from -64 to 63 dB in 0.5 dB steps (-128...63) */
+static DECLARE_TLV_DB_SCALE(dec_gain_tlv, -6400, 50, 1);
+
+/* Data weight algorithm */
+static const struct soc_enum lpc315x_codec_dwa_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_AOUT, 2, 2, lpc315x_codec_dwa_sel);
+
+/* from 0 to 24dB in 3dB steps */
+static DECLARE_TLV_DB_SCALE(line_pga_tlv, 0, 300, 0);
+
+/* from 0 to 24dB in 3dB steps */
+static DECLARE_TLV_DB_SCALE(mic_pga_tlv, 0, 300, 0);
+
+/*
+ * LPC315X AVC Coarse Volume control functions
+ * */
+/* from 0 to -60dB in 6dB steps */
+static DECLARE_TLV_DB_SCALE(avc_coa_tlv, -6000, 600, 1);
+
+/*
+ * LPC315X AVC Coarse Volume put function
+ * */
+static int snd_soc_lpc315x_coa_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	u32 i, val, reg, avc_gain;
+
+	val = (ucontrol->value.integer.value[0] & 0xF);
+	/* conversion to AVC Coarse volume bit pattern
+	* 0000  = Mute  (00000000000) = 0x000
+	* 0001  = -60dB (10000000000) = 0x400
+	* 0010  = -54dB (11000000000) = 0x600
+	* 0011  = -48dB (11100000000) = 0x700
+	* 0100  = -42dB (11110000000) = 0x780
+	* 0101  = -36dB (11111000000) = 0x7C0
+	* 0110  = -30dB (11111100000) = 0x7E0
+	* 0111  = -24dB (11111110000) = 0x7F0
+	* 1000  = -18dB (11111111000) = 0x7F8
+	* 1001  = -12dB (11111111100) = 0x7FC
+	* 1010  = -06dB (11111111110) = 0x7FE
+	* 1011  =  00dB (11111111111) = 0x7FF (Max)
+	*/
+	if(val >= 0xB) {
+		avc_gain = 0x7FF; /* 0dB */
+	}
+	else if(!val) {
+		avc_gain = 0; /* Mute */
+	}
+	else {
+		/* Calculate bit pattern */
+		avc_gain = 0x400;
+		for(i = 1; i < val; i++) {
+			avc_gain |= (avc_gain >> 1);
+		}
+	}
+
+	/* Write to register */
+	reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_AOUT);
+       	reg &= ~(0x7FF << LPC315X_CODEC_AOUT_AVC_COA_GAIN_POS);
+	reg |= (avc_gain << LPC315X_CODEC_AOUT_AVC_COA_GAIN_POS);
+	lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, reg);
+
+	return 0;
+}
+
+/*
+ * LPC315X AVC Coarse Volume get function
+ * */
+static int snd_soc_lpc315x_coa_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	u32 reg, cnt;
+
+	/* Get value from register */
+	reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_AOUT);
+
+	/* Calculate count value from register value */
+       	reg = ((reg >> LPC315X_CODEC_AOUT_AVC_COA_GAIN_POS) & 0x7FF);
+	if(reg >= 0x7FF) {
+		cnt = 0xB;
+	}
+	else if(!reg) {
+		cnt = 0;
+	}
+	else {
+		for(cnt = 1; reg; cnt++) {
+			reg &= (reg - 1);
+		}
+	}
+	ucontrol->value.integer.value[0] = cnt;
+	return 0;
+
+}
+
+/* AVC Coarse Volume TLV macro */
+#define SOC_LPC315X_AVCCOA_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, .get = snd_soc_lpc315x_coa_get_volsw,\
+	.put = snd_soc_lpc315x_coa_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) }
+
+/*
+ * LPC315X AVC Fine Volume control functions
+ * */
+/* from 0 to -4.5dB in 1.5dB steps */
+static DECLARE_TLV_DB_SCALE(avc_fin_tlv, -450, 150, 1);
+
+/*
+ * LPC315X AVC Fine Volume put function
+ * */
+static int snd_soc_lpc315x_fin_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	u32 val, reg, avc_gain;
+
+	val = (ucontrol->value.integer.value[0] & 0x7);
+	/* conversion to AVC Fine volume bit pattern
+	* 000  = -4.5dB (000) = 0x0
+	* 001  = -3.0dB (001) = 0x1
+	* 010  = -1.5dB (011) = 0x3
+	* 011  =  0.0dB (111) = 0x7 (Max)
+	*/
+	if( val >= 0x3) {
+		val = 0x3;
+	}
+	avc_gain = (1 << val) - 1;
+
+	/* Write into register */
+	reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_AOUT);
+       	reg &= ~(0x7 << LPC315X_CODEC_AOUT_AVC_FIN_GAIN_POS);
+	reg |= (avc_gain << LPC315X_CODEC_AOUT_AVC_FIN_GAIN_POS);
+	lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, reg);
+
+	return 0;
+}
+
+/*
+ * LPC315X AVC Fine Volume get function
+ * */
+static int snd_soc_lpc315x_fin_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	u32 reg, cnt;
+
+	/* Get value from register */
+	reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_AOUT);
+
+	/* Calculate count value from register value */
+       	reg = ((reg >> LPC315X_CODEC_AOUT_AVC_FIN_GAIN_POS) & 0x7);
+	cnt = 0;
+	while(reg != ((1 << cnt) - 1)) {
+		cnt++;
+	}
+
+	if(cnt >= 0x3) {
+		cnt = 0x3;
+	}
+	ucontrol->value.integer.value[0] = cnt;
+	return 0;
+
+}
+
+/* AVC Fine Volume TLV macro */
+#define SOC_LPC315X_AVCFIN_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, .get = snd_soc_lpc315x_fin_get_volsw,\
+	.put = snd_soc_lpc315x_fin_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) }
+/*
+ * Audio Controls
+ * */
+static const struct snd_kcontrol_new lpc315x_codec_snd_ctrls[] = {
+	/* MIC PGA Gain Control */
+	SOC_SINGLE_TLV("Mic Capture Volume", LPC315X_CODEC_PGA, 4, 8, 0,
+			mic_pga_tlv),
+	/* PGA Gain Control for Left & Right channels */
+	SOC_DOUBLE_TLV("Line Capture Volume", LPC315X_CODEC_PGA, 8, 0, 8, 0,
+			line_pga_tlv),
+	/* ADC Dither Input for Left & Right Channels */
+	SOC_DOUBLE("ADC Dither Input", LPC315X_CODEC_AIN1, 3, 2, 1, 0),
+	/* Feedback in Loopfilter */
+	SOC_DOUBLE("Loopfilter Feedback", LPC315X_CODEC_AIN1, 1, 0, 1, 0),
+	/* AVC outputs to AB Amplifier */
+	SOC_SINGLE("AVC Output Switch", LPC315X_CODEC_AOUT, 31, 1, 0),
+	/* AVC Coarse Volume Control */
+	SOC_LPC315X_AVCCOA_SINGLE_TLV("AVC Coarse Volume Control",
+			LPC315X_CODEC_AOUT, 16, 11, 0, avc_coa_tlv),
+	/* AVC Fine Volume Control */
+	SOC_LPC315X_AVCFIN_SINGLE_TLV("AVC Fine Volume Control",
+			LPC315X_CODEC_AOUT, 27, 3, 0, avc_fin_tlv),
+	/* Data Weight Algorithm */
+	SOC_ENUM("Data Weight Algorithm", lpc315x_codec_dwa_enum),
+	/* AGC Time settings */
+	SOC_SINGLE("AGC Timing", LPC315X_CODEC_DEC, 25, 7, 0),
+	/* AGC Levels */
+	SOC_SINGLE("AGC Target level", LPC315X_CODEC_DEC, 23, 3, 1),
+	/* AGC Switch */
+	SOC_SINGLE("AGC Switch", LPC315X_CODEC_DEC, 22, 1, 0),
+	/* Decimator Mute */
+	SOC_SINGLE("ADC Dec Mute", LPC315X_CODEC_DEC, 21, 1, 0),
+	/* Channel Polarity Inverting Switch */
+	SOC_SINGLE("ADC Polarity Inv Switch", LPC315X_CODEC_DEC,
+			20, 1, 0),
+	/* Input DC blocking filter (before Decimator) */
+	SOC_SINGLE("Input DC Filter Switch", LPC315X_CODEC_DEC, 19, 1, 0),
+	/* Output DC blocking filter (after Decimator) */
+	SOC_SINGLE("Output DC Filter Switch", LPC315X_CODEC_DEC, 18, 1, 0),
+	/* Enable soft start up after reset switch */
+	SOC_SINGLE("Db Linear After Reset Switch", LPC315X_CODEC_DEC,
+			17, 1, 0),
+	/* Enable  sy timer after reset switch */
+	SOC_SINGLE("Timer After Reset Switch", LPC315X_CODEC_DEC, 16, 1, 0),
+	/* ADC Capture volume */
+	SOC_DOUBLE_S8_TLV("ADC Capture Volume", LPC315X_CODEC_DEC,
+			-128, 127, dec_gain_tlv),
+	/* DAC Polarity Inversion Switch */
+	SOC_SINGLE("DAC Polarity inverting Switch", LPC315X_CODEC_INT0,
+			15, 1, 0),
+	/* Interpolator Filter Settings */
+	SOC_ENUM("INT Filter Settings", lpc315x_codec_fil_enum),
+	/* Input data rate */
+	SOC_ENUM("Oversampling Input", lpc315x_codec_os_enum),
+	/* Nosie Shaper Settings */
+	SOC_ENUM("Noise Shaper", lpc315x_codec_ns_enum),
+	/* Silence Enable Switch */
+	SOC_SINGLE("Overule Silence Dit Switch", LPC315X_CODEC_INT0,
+			3, 1, 0),
+	/* Silence Detector Switch */
+	SOC_SINGLE("Silence Detector Switch", LPC315X_CODEC_INT0, 6, 1, 0),
+	/* Silence Detector Settings */
+	SOC_ENUM("Silence Detector Setting", lpc315x_codec_sdet_enum),
+	/* De-emphasis settings */
+	SOC_ENUM("PCM Playback De-emphasis", lpc315x_codec_deemp_enum),
+	/* Interpolator Volume Control Settings */
+	SOC_DOUBLE_S8_TLV("ADC Playback Volume", LPC315X_CODEC_INT1,
+			-128, 127, int_gain_tlv),
+	/* Digital Mux Selection */
+	SOC_ENUM("Digital Mux Switch", lpc315x_codec_dmux_enum),
+};
+
+static const struct soc_enum lpc315x_muxl0_sel_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_AIN1, 17, 2, lpc315x_mux0_sel);
+static const struct soc_enum lpc315x_muxr0_sel_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_AIN1, 15, 2, lpc315x_mux0_sel);
+static const struct soc_enum lpc315x_muxl1_sel_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_AIN1, 18, 2, lpc315x_mux1_sel);
+static const struct soc_enum lpc315x_muxr1_sel_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_AIN1, 16, 2, lpc315x_mux1_sel);
+static const struct soc_enum lpc315x_swdac_sel_enum =
+	SOC_ENUM_SINGLE(LPC315X_CODEC_AOUT, 31, 2, lpc315x_swdac_sel);
+static const struct snd_kcontrol_new lpc315x_muxl0_control =
+	SOC_DAPM_ENUM("Route", lpc315x_muxl0_sel_enum);
+static const struct snd_kcontrol_new lpc315x_muxr0_control =
+	SOC_DAPM_ENUM("Route", lpc315x_muxr0_sel_enum);
+static const struct snd_kcontrol_new lpc315x_muxl1_control =
+	SOC_DAPM_ENUM("Route", lpc315x_muxl1_sel_enum);
+static const struct snd_kcontrol_new lpc315x_muxr1_control =
+	SOC_DAPM_ENUM("Route", lpc315x_muxr1_sel_enum);
+static const struct snd_kcontrol_new lpc315x_output_mux_control =
+	SOC_DAPM_ENUM("Route", lpc315x_swdac_sel_enum);
+
+/*
+ * Audio widgets
+ * */
+static const struct snd_soc_dapm_widget lpc315x_codec_dapm_widgets[] = {
+	SND_SOC_DAPM_MUX("Output Mux", SND_SOC_NOPM, 0, 0,
+		&lpc315x_output_mux_control),
+	SND_SOC_DAPM_MUX("MUX_L0", SND_SOC_NOPM, 0, 0,
+		&lpc315x_muxl0_control),
+	SND_SOC_DAPM_MUX("MUX_R0", SND_SOC_NOPM, 0, 0,
+		&lpc315x_muxr0_control),
+	SND_SOC_DAPM_MUX("MUX_L1", SND_SOC_NOPM, 0, 0,
+		&lpc315x_muxl1_control),
+	SND_SOC_DAPM_MUX("MUX_R1", SND_SOC_NOPM, 0, 0,
+		&lpc315x_muxr1_control),
+	SND_SOC_DAPM_PGA("Mic LNA", LPC315X_CODEC_AIN1, 14, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic PGA", LPC315X_CODEC_AIN1, 12, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Left PGA", LPC315X_CODEC_AIN1, 13, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Right PGA", LPC315X_CODEC_AIN1, 11, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic SDC", LPC315X_CODEC_AIN1, 9, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Left SDC", LPC315X_CODEC_AIN1, 10, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Right SDC", LPC315X_CODEC_AIN1, 8, 1, NULL, 0),
+	SND_SOC_DAPM_ADC("SADC Left", "Left Capture",
+			LPC315X_CODEC_AIN1, 7, 1),
+	SND_SOC_DAPM_ADC("SADC Right", "Right Capture",
+			LPC315X_CODEC_AIN1, 6, 1),
+	SND_SOC_DAPM_INPUT("ADC_MIC"),
+	SND_SOC_DAPM_INPUT("ADC_VINL"),
+	SND_SOC_DAPM_INPUT("ADC_VINR"),
+	SND_SOC_DAPM_INPUT("ADC_TINL"),
+	SND_SOC_DAPM_INPUT("ADC_TINR"),
+	SND_SOC_DAPM_OUTPUT("HP_OUTL"),
+	SND_SOC_DAPM_OUTPUT("HP_OUTC"),
+	SND_SOC_DAPM_OUTPUT("HP_OUTR"),
+	SND_SOC_DAPM_PGA("HP Amp Left", LPC315X_CODEC_AOUT, 14, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("HP Amp Right", LPC315X_CODEC_AOUT, 12, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("AVC Left", LPC315X_CODEC_AOUT, 1, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("AVC Right", LPC315X_CODEC_AOUT, 0, 1, NULL, 0),
+	SND_SOC_DAPM_DAC("SDAC Right", "Right Playback",
+			LPC315X_CODEC_AOUT, 4, 1),
+	SND_SOC_DAPM_DAC_E("SDAC Left", "Left Playback",
+			LPC315X_CODEC_AOUT, 5, 1, lpc315x_codec_ref_vol,
+			SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),
+};
+
+/*
+ * Audio paths
+ * */
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Audio output path */
+	{"HP_OUTL", NULL, "HP Amp Left"},
+	{"HP_OUTR", NULL, "HP Amp Right"},
+
+	/* Headphone Amplifier */
+	{"HP Amp Left", NULL, "AVC Left"},
+	{"HP Amp Right", NULL, "AVC Right"},
+	{"HP Amp Right", "Both AVC & SDAC", "SDAC Right"},
+	{"HP Amp Left", "Both AVC & SDAC", "SDAC Left"},
+
+	/* Audio  Input paths */
+	/* ADC <- MUX1 */
+	{"SADC Left", NULL, "MUX_L1"},
+	{"SADC Right", NULL, "MUX_R1"},
+
+	/* MUX1 <- Mic SDC */
+	{"MUX_L1", "Mic In", "Mic SDC"},
+	{"MUX_R1", "Mic In", "Mic SDC"},
+	/* Mic SDC <- Mic PGA */
+	{"Mic SDC", NULL, "Mic PGA"},
+	/* Mic PGA <- Mic LNA */
+	{"Mic PGA", NULL, "Mic LNA"},
+	/* Mic LNA <- MIC Input */
+	{"Mic LNA", NULL, "ADC_MIC"},
+
+	/* MUX1 <- Left & Right SDC */
+	{"MUX_L1", "Lin/Tun In", "Left SDC"},
+	{"MUX_R1", "Lin/Tun In", "Right SDC"},
+	/* Left & Right SDC <- Left & Right PGA */
+	{"Left SDC", NULL, "Left PGA"},
+	{"Right SDC", NULL, "Right PGA"},
+	/* Left & Right PGA <- MUX0 */
+	{"Left PGA", NULL, "MUX_L0"},
+	{"Right PGA", NULL, "MUX_R0"},
+	/* MUX0 <- Line/Tuner Stereo Inputs */
+	{"MUX_L0", "Line In", "ADC_VINL"},
+	{"MUX_R0", "Line In", "ADC_VINR"},
+	{"MUX_L0", "Tuner In", "ADC_TINL"},
+	{"MUX_R0", "Tuner In", "ADC_TINR"},
+
+};
+
+/*
+ * LPC315X CODEC Add Audio widgets function
+ * */
+static int lpc315x_codec_add_widgets(struct snd_soc_codec *codec)
+{
+	/* Add LPC315X CODEC audio widgets */
+	snd_soc_dapm_new_controls(codec, lpc315x_codec_dapm_widgets,
+				  ARRAY_SIZE(lpc315x_codec_dapm_widgets));
+
+	/* Add LPC315X CODEC audio paths */
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+	return 0;
+}
+
+/*
+ * LPC315X CODEC set format function for both Playback & Capture
+ * */
+static int lpc315x_codec_set_dai_fmt_both(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u32 i2s_mux_reg;
+
+	/* Set up DAI based upon fmt */
+	i2s_mux_reg = lpc315x_codec_read_reg_cache(codec,
+			LPC315X_CODEC_I2SMUX1);
+	i2s_mux_reg &= ~(LPC315X_CODEC_I2SMUX1_TX_FMT_MSK |
+			LPC315X_CODEC_I2SMUX1_RX_FMT_MSK);
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		i2s_mux_reg |= LPC315X_CODEC_I2SMUX1_TX_FMT_I2S |
+			LPC315X_CODEC_I2SMUX1_RX_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_LSB:
+		i2s_mux_reg |= LPC315X_CODEC_I2SMUX1_TX_FMT_LSB_16 |
+			LPC315X_CODEC_I2SMUX1_RX_FMT_LSB_16;
+		break;
+	}
+
+	/* DATAI is slave only, so in single-link mode,
+	 * this has to be slave */
+	if ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)
+		return -EINVAL;
+
+	lpc315x_codec_write(codec, LPC315X_CODEC_I2SMUX1, i2s_mux_reg);
+
+	return 0;
+}
+
+/*
+ * LPC315X CODEC set format function for Playback
+ * */
+static int lpc315x_codec_set_dai_fmt_playback(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u32 i2s_mux_reg;
+
+	/* Set up DAI based upon fmt */
+	i2s_mux_reg = lpc315x_codec_read_reg_cache(codec,
+			LPC315X_CODEC_I2SMUX1);
+	i2s_mux_reg &= ~(LPC315X_CODEC_I2SMUX1_RX_FMT_MSK);
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		i2s_mux_reg |= LPC315X_CODEC_I2SMUX1_RX_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_LSB:
+		i2s_mux_reg |= LPC315X_CODEC_I2SMUX1_RX_FMT_LSB_16;
+		break;
+	}
+
+	/* DATAI is slave only, so this has to be slave */
+	if ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)
+		return -EINVAL;
+
+	lpc315x_codec_write(codec, LPC315X_CODEC_I2SMUX1, i2s_mux_reg);
+
+	return 0;
+}
+
+/*
+ * LPC315X CODEC set format function for Capture
+ * */
+static int lpc315x_codec_set_dai_fmt_capture(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u32 i2s_mux_reg;
+
+	/* set up DAI based upon fmt */
+	i2s_mux_reg = lpc315x_codec_read_reg_cache(codec,
+			LPC315X_CODEC_I2SMUX1);
+	i2s_mux_reg &= ~(LPC315X_CODEC_I2SMUX1_TX_FMT_MSK);
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		i2s_mux_reg |= LPC315X_CODEC_I2SMUX1_TX_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_LSB:
+		i2s_mux_reg |= LPC315X_CODEC_I2SMUX1_TX_FMT_LSB_16;
+		break;
+	}
+
+	/* DATAI is slave only, so this has to be slave */
+	if ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)
+		return -EINVAL;
+
+	lpc315x_codec_write(codec, LPC315X_CODEC_I2SMUX1, i2s_mux_reg);
+
+	return 0;
+}
+
+/*
+ * LPC315X CODEC trigger function
+ * */
+static int lpc315x_codec_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	struct lpc315x_codec_priv *prv = codec->private_data;
+	u32 int0_reg = lpc315x_codec_read_reg_cache(codec,
+			LPC315X_CODEC_INT0);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		lpc315x_codec_write_reg_cache(codec, LPC315X_CODEC_INT0,
+			int0_reg & ~LPC315X_CODEC_INT0_SET_SIL);
+		schedule_work(&prv->work);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		lpc315x_codec_write_reg_cache(codec, LPC315X_CODEC_INT0,
+				int0_reg | LPC315X_CODEC_INT0_SET_SIL);
+		schedule_work(&prv->work);
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * LPC315X CODEC HW parameters function
+ * */
+static int lpc315x_codec_pcm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	unsigned int cgu_reg = 0;
+	u32 aout_reg, ain_reg, int0_reg, dec_reg;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* Playback power up sequence */
+		/* Power up DAC Clocks */
+		lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+				&cgu_reg, 1);
+		cgu_reg &= ~(LPC315X_CODEC_CGU_PD_DSP_CLK |
+				LPC315X_CODEC_CGU_PD_NS_CLK |
+				LPC315X_CODEC_CGU_PD_I2SRX_BCLK |
+				LPC315X_CODEC_CGU_PD_I2SRX_SYSCLK |
+				LPC315X_CODEC_CGU_PD_I2C256FS_CLK |
+				LPC315X_CODEC_CGU_PD_DAC_CLK);
+		lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+				&cgu_reg, 0);
+		/* Power up HP */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg &= ~(LPC315X_CODEC_AOUT_PD_HP_L |
+			LPC315X_CODEC_AOUT_PD_HP_C |
+			LPC315X_CODEC_AOUT_PD_HP_R);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Power up Reference buffer */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg &= ~(LPC315X_CODEC_AOUT_VREF_SLOW);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Power up Central Reference source */
+		ain_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AIN1);
+		ain_reg &= ~(LPC315X_CODEC_AIN1_PD_VCOM_VREF1);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AIN1, ain_reg);
+
+		/* Power down INT DAC */
+		int0_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_INT0);
+		int0_reg |= (LPC315X_CODEC_INT0_PD_DAC);
+		lpc315x_codec_write(codec, LPC315X_CODEC_INT0, int0_reg);
+	}
+	else {
+		/* Recording power up sequence */
+		/* Switch on ADC, Decimator clocks */
+		lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+				&cgu_reg, 1);
+		cgu_reg &= ~(LPC315X_CODEC_CGU_PD_DEC_CLK |
+				LPC315X_CODEC_CGU_PD_I2STX_BCLK |
+				LPC315X_CODEC_CGU_PD_I2STX_SYSCLK |
+				LPC315X_CODEC_CGU_PD_I2C256FS_CLK |
+				LPC315X_CODEC_CGU_PD_ADCSYS_CLK |
+				LPC315X_CODEC_CGU_PD_ADC2_CLK |
+				LPC315X_CODEC_CGU_PD_ADC1_CLK);
+		lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+				&cgu_reg, 0);
+		/* Mute */
+		dec_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_DEC);
+		dec_reg |= (LPC315X_CODEC_DEC_MUTE);
+		dec_reg &= ~(LPC315X_CODEC_DEC_AGC_EN);
+		lpc315x_codec_write(codec, LPC315X_CODEC_DEC, dec_reg);
+
+		/* Power up Reference buffer */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg &= ~(LPC315X_CODEC_AOUT_VREF_SLOW);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Power up Central Reference source */
+		ain_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AIN1);
+		ain_reg &= ~(LPC315X_CODEC_AIN1_PD_VCOM_VREF1 |
+				LPC315X_CODEC_AIN1_PD_BIAS);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AIN1, ain_reg);
+
+		/* Ramp up Reference voltage */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg |= LPC315X_CODEC_AOUT_VREF_SLOW_UP;
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+		mdelay(500);
+
+		/* Enable Decimator & set Volume */
+		dec_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_DEC);
+		dec_reg &= ~(LPC315X_CODEC_DEC_GAIN_R_MASK |
+				LPC315X_CODEC_DEC_GAIN_L_MASK |
+				LPC315X_CODEC_DEC_MUTE);
+		dec_reg |= ((DEC_GAIN << LPC315X_CODEC_DEC_GAIN_R_POS) |
+				(DEC_GAIN << LPC315X_CODEC_DEC_GAIN_L_POS) |
+				LPC315X_CODEC_DEC_DC_IN_FIL |
+				LPC315X_CODEC_DEC_DC_OUT_FIL);
+		lpc315x_codec_write(codec, LPC315X_CODEC_DEC, dec_reg);
+	}
+
+	return 0;
+}
+
+/*
+ * LPC315X CODEC PCM shutdown function
+ * */
+static void lpc315x_codec_pcm_shutdown(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	unsigned int cgu_reg = 0;
+	u32 aout_reg, dec_reg, int0_reg, ain_reg, int1_reg;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* Set Interpolator to mute */
+		int1_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_INT1);
+		int1_reg |= (LPC315X_CODEC_INT1_MAS_MUTE);
+		lpc315x_codec_write(codec, LPC315X_CODEC_INT1, int1_reg);
+
+		/* Set AVC to mute  */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg &= ~(LPC315X_CODEC_AOUT_AVC_COA_GAIN_MSK |
+				LPC315X_CODEC_AOUT_AVC_FIN_GAIN_MSK);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Playback power down sequence */
+		/* Ramp down Reference Volatge */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg &= ~(LPC315X_CODEC_AOUT_VREF_SLOW_UP);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+		mdelay(500);
+
+		/* Ramp down INT DAC volatge */
+		int0_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_INT0);
+		int0_reg |= (LPC315X_CODEC_INT0_PD_DAC);
+		lpc315x_codec_write(codec, LPC315X_CODEC_INT0, int0_reg);
+		mdelay(30);
+
+		/* Disconnect DAC outputs to HP */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg &= ~(LPC315X_CODEC_AOUT_SWDAC_ON);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+	}
+	else {
+		/* Mute */
+		dec_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_DEC);
+		dec_reg |= (LPC315X_CODEC_DEC_MUTE);
+		dec_reg &= ~(LPC315X_CODEC_DEC_AGC_EN);
+		lpc315x_codec_write(codec, LPC315X_CODEC_DEC, dec_reg);
+
+		/* Recording power down sequence */
+		/* Ramp down Reference voltage */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg &= ~(LPC315X_CODEC_AOUT_VREF_SLOW_UP);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+		mdelay(500);
+
+		/* Power up Central Reference source */
+		ain_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AIN1);
+		ain_reg |= (LPC315X_CODEC_AIN1_PD_VCOM_VREF1);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AIN1, ain_reg);
+
+		/* Power down Reference buffer */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg |= (LPC315X_CODEC_AOUT_VREF_SLOW);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Power down AVC */
+		aout_reg = lpc315x_codec_read_reg_cache(codec,
+				LPC315X_CODEC_AOUT);
+		aout_reg |= (LPC315X_CODEC_AOUT_PD_ANVC_L |
+			LPC315X_CODEC_AOUT_PD_ANVC_R);
+		lpc315x_codec_write(codec, LPC315X_CODEC_AOUT, aout_reg);
+
+		/* Switch off ADC, Decimator clocks */
+		lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+				&cgu_reg, 1);
+		cgu_reg &= ~(LPC315X_CODEC_CGU_PD_DEC_CLK |
+				LPC315X_CODEC_CGU_PD_I2SRX_BCLK |
+				LPC315X_CODEC_CGU_PD_I2SRX_SYSCLK |
+				LPC315X_CODEC_CGU_PD_I2C256FS_CLK |
+				LPC315X_CODEC_CGU_PD_ADCSYS_CLK |
+				LPC315X_CODEC_CGU_PD_ADC2_CLK |
+				LPC315X_CODEC_CGU_PD_ADC1_CLK);
+		lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+				&cgu_reg, 0);
+	}
+
+	return;
+}
+
+/*
+ * LPC315X CODEC Mute function
+ * */
+static int lpc315x_codec_mute(struct snd_soc_dai *codec_dai,
+		int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u32 int1_reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_INT1)
+		& ~LPC315X_CODEC_INT1_MAS_MUTE;
+
+	/* Mute */
+	if (mute) {
+		lpc315x_codec_write(codec, LPC315X_CODEC_INT1,
+				int1_reg | LPC315X_CODEC_INT1_MAS_MUTE);
+	}
+	else {
+		lpc315x_codec_write(codec, LPC315X_CODEC_INT1, int1_reg);
+	}
+
+	return 0;
+}
+
+/*
+ * LPC315X CODEC BIAS control function
+ * */
+static int lpc315x_codec_set_bias_level(struct snd_soc_codec *codec,
+	enum snd_soc_bias_level level)
+{
+	u32 ain1_reg = lpc315x_codec_read_reg_cache(codec,
+			LPC315X_CODEC_AIN1);
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+	case SND_SOC_BIAS_STANDBY:
+		ain1_reg &= ~LPC315X_CODEC_AIN1_PD_BIAS;
+		lpc315x_codec_write(codec, LPC315X_CODEC_AIN1, ain1_reg);
+		break;
+	case SND_SOC_BIAS_OFF:
+		lpc315x_codec_write(codec, LPC315X_CODEC_AIN1,
+				LPC315X_CODEC_AIN1_BIAS_OFF);
+		break;
+	}
+
+	codec->bias_level = level;
+	return 0;
+}
+
+/*
+ * LPC315X CODEC supported data rates
+ * */
+#define LPC315X_CODEC_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		       SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
+		       SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+
+/*
+ * DAI operations for both Playback & Capture
+ * */
+static struct snd_soc_dai_ops lpc315x_codec_ops = {
+	.hw_params	= lpc315x_codec_pcm_hw_params,
+	.shutdown	= lpc315x_codec_pcm_shutdown,
+	.trigger	= lpc315x_codec_trigger,
+	.digital_mute = lpc315x_codec_mute,
+	.set_fmt	= lpc315x_codec_set_dai_fmt_both,
+};
+
+/*
+ * DAI operations for Playback
+ * */
+static struct snd_soc_dai_ops lpc315x_codec_ops_playback = {
+	.hw_params	= lpc315x_codec_pcm_hw_params,
+	.shutdown	= lpc315x_codec_pcm_shutdown,
+	.trigger	= lpc315x_codec_trigger,
+	.digital_mute = lpc315x_codec_mute,
+	.set_fmt	= lpc315x_codec_set_dai_fmt_playback,
+};
+
+/*
+ * DAI operations for Capture
+ * */
+static struct snd_soc_dai_ops lpc315x_codec_ops_capture = {
+	.hw_params	= lpc315x_codec_pcm_hw_params,
+	.shutdown	= lpc315x_codec_pcm_shutdown,
+	.trigger	= lpc315x_codec_trigger,
+	.digital_mute = lpc315x_codec_mute,
+	.set_fmt	= lpc315x_codec_set_dai_fmt_capture,
+};
+
+/*
+ * LPC315X CODEC DAI
+ * */
+struct snd_soc_dai lpc315x_codec_dais[] = {
+{
+	.name = "LPC315X_CODEC",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC315X_CODEC_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC315X_CODEC_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &lpc315x_codec_ops,
+},
+{ /* playback only - dual interface */
+	.name = "LPC315X_CODEC",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC315X_CODEC_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &lpc315x_codec_ops_playback,
+},
+{ /* capture only - dual interface*/
+	.name = "LPC315X_CODEC",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC315X_CODEC_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &lpc315x_codec_ops_capture,
+},
+};
+EXPORT_SYMBOL_GPL(lpc315x_codec_dais);
+
+/*
+ * LPC315X CODEC suspend function
+ * */
+static int lpc315x_codec_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->card->codec;
+
+	/* Set to OFF */
+	lpc315x_codec_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+/*
+ * LPC315X CODEC resume function
+ * */
+static int lpc315x_codec_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->card->codec;
+	u8 data[6];
+	u32 i, *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(lpc315x_codec_regs); i++) {
+		data[0] = ((i >> 8) & 0xFF);
+		data[1] = (i & 0xFF);
+		data[2] = ((cache[i]  >> 24) & 0xFF);
+		data[3] = ((cache[i] >> 16) & 0xFF);
+		data[4] = ((cache[i] >> 8) & 0xFF);
+		data[5] = (cache[i] & 0xFF);
+		codec->hw_write(codec->control_data, data, 6);
+	}
+
+	/* Set the BIAS levels */
+	lpc315x_codec_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	lpc315x_codec_set_bias_level(codec, codec->suspend_bias_level);
+
+	return 0;
+}
+
+/*
+ * LPC315X CODEC probe function
+ * */
+static int lpc315x_codec_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	int ret = 0;
+	u32 cgu_reg = 0;
+
+	/* Check if LPC315X CODECX registered */
+	if (lpc315x_codec == NULL) {
+		dev_err(&pdev->dev, "Codec device not registered\n");
+		return -ENODEV;
+	}
+
+	socdev->card->codec = lpc315x_codec;
+	codec = lpc315x_codec;
+
+	/* Register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1,
+			SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to create pcms: %d\n", ret);
+		goto pcm_err;
+	}
+
+	/* Select ADC & DAC clocks */
+	lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU,
+			&cgu_reg, 1);
+	cgu_reg &= ~(LPC315X_CODEC_CGU_PD_I2C256FS_CLK |
+			LPC315X_CODEC_CGU_ADCSYS_256FS |
+			LPC315X_CODEC_CGU_ADC2_128FS |
+			LPC315X_CODEC_CGU_ADC1_OFF |
+			LPC315X_CODEC_CGU_CLKDAC_256FS |
+			LPC315X_CODEC_CGU_CLKINT_256FS);
+	/* DAC Clock not inverted */
+	lpc315x_codec_register_rw(codec, LPC315X_CODEC_CGU, &cgu_reg, 0);
+
+	/* power on device */
+	lpc315x_codec_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	/* Add LPC315X CODEC controls */
+	snd_soc_add_controls(codec, lpc315x_codec_snd_ctrls,
+				ARRAY_SIZE(lpc315x_codec_snd_ctrls));
+
+	/* Add Widgets & Audio map */
+	lpc315x_codec_add_widgets(codec);
+pcm_err:
+	return ret;
+}
+
+/*
+ * LPC315X CODEC remove function
+ * */
+static int lpc315x_codec_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->card->codec;
+
+	/* Set BIAS level to off */
+	if (codec->control_data)
+		lpc315x_codec_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	/* Unregister PCMs */
+	snd_soc_free_pcms(socdev);
+
+	/* Remove DAPM widgets */
+	snd_soc_dapm_free(socdev);
+
+	return 0;
+}
+
+/*
+ * CODEC device
+ * */
+struct snd_soc_codec_device soc_codec_lpc315x_dev = {
+	.probe = 	lpc315x_codec_probe,
+	.remove = 	lpc315x_codec_remove,
+	.suspend = 	lpc315x_codec_suspend,
+	.resume =	lpc315x_codec_resume,
+};
+EXPORT_SYMBOL_GPL(soc_codec_lpc315x_dev);
+
+/*
+ * LPC315X CODEC register function
+ * */
+static int lpc315x_codec_register(struct lpc315x_codec_priv *codec_prv)
+{
+	int ret = 0, i;
+	struct snd_soc_codec *codec = &codec_prv->codec;
+
+	/* Check if LPC315X CODEC registered */
+	if (lpc315x_codec) {
+		dev_err(codec->dev, "Another LPC315X CODEC is registered\n");
+		return -EINVAL;
+	}
+
+	/* Initialise CODEC structure */
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	codec->private_data = codec_prv;
+	codec->name = "LPC315X_CODEC";
+	codec->owner = THIS_MODULE;
+	codec->read = lpc315x_codec_read_reg_cache;
+	codec->write = lpc315x_codec_write;
+	codec->bias_level = SND_SOC_BIAS_OFF;
+	codec->set_bias_level = lpc315x_codec_set_bias_level;
+	codec->dai = lpc315x_codec_dais;
+	codec->num_dai = ARRAY_SIZE(lpc315x_codec_dais);
+	codec->reg_cache_size = ARRAY_SIZE(lpc315x_codec_regs);
+	codec->reg_cache = &codec_prv->lpc315x_reg_cache;
+	codec->reg_cache_step = 1;
+
+	/* Copy register contents */
+	memcpy(codec->reg_cache, lpc315x_codec_regs,
+			sizeof(lpc315x_codec_regs));
+
+	/* Initialise work queue */
+	INIT_WORK(&codec_prv->work, lpc315x_codec_work);
+
+	/* Store devier structure */
+	for (i = 0; i < ARRAY_SIZE(lpc315x_codec_dais); i++)
+		lpc315x_codec_dais[i].dev = codec->dev;
+
+	/* Initialise LPC315X CODEC structure */
+	lpc315x_codec = codec;
+
+	/* Register CODEC */
+	ret = snd_soc_register_codec(codec);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register codec: %d\n", ret);
+		goto err_reset;
+	}
+
+	/* Register CODEC DAIs */
+	ret = snd_soc_register_dais(lpc315x_codec_dais,
+			ARRAY_SIZE(lpc315x_codec_dais));
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register DAIs: %d\n", ret);
+		goto err_dai;
+	}
+
+	return 0;
+
+err_dai:
+	snd_soc_unregister_codec(codec);
+err_reset:
+	return ret;
+}
+
+/*
+ * LPC315X CODEC unregister function
+ * */
+static void lpc315x_codec_unregister(struct lpc315x_codec_priv
+		    *codec_prv)
+{
+	/* Unregister CODEC DAIs */
+	snd_soc_unregister_dais(lpc315x_codec_dais,
+			ARRAY_SIZE(lpc315x_codec_dais));
+
+	/* Unregister CODEC */
+	snd_soc_unregister_codec(&codec_prv->codec);
+
+	/* Free memory */
+	kfree(codec_prv);
+
+	/* Invalidate CODEC structure pointer */
+	lpc315x_codec = NULL;
+}
+
+/*
+ * LPC315X CODEC driver module initialisation function
+ * */
+static int __init lpc315x_codec_init(void)
+{
+	struct i2c_client *i2c;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	printk(KERN_INFO "CODEC I2C Probe called \r\n");
+
+	/* Get I2C client structure structure */
+	i2c = lpc315x_ad_get_i2c_client_struct();
+	if (!i2c) {
+		pr_err("Unable to get I2C client \n");
+		return -ENODEV;
+	}
+
+	/* Allocate memory for LPC315X CODEC private structure */
+	lpc315x_codec_prv = kzalloc(sizeof(struct lpc315x_codec_priv),
+			GFP_KERNEL);
+	if (lpc315x_codec_prv == NULL) {
+		pr_err("Failed to allocate memory \n");
+		return -ENOMEM;
+	}
+
+	/* Initialise CODEC structure */
+	codec = &lpc315x_codec_prv->codec;
+	codec->hw_write = (hw_write_t) i2c_master_send;
+	codec->control_data = i2c;
+	codec->dev = &i2c->dev;
+
+	/* Register LPC315X CODEC */
+	ret = lpc315x_codec_register(lpc315x_codec_prv);
+	if (ret != 0) {
+		pr_err("Failed to register LPC315X CODEC \n");
+		kfree(lpc315x_codec_prv);
+	}
+
+	return ret;
+}
+
+/*
+ * LPC315X CODEC driver module exit function
+ * */
+static void __exit lpc315x_codec_exit(void)
+{
+	/* Unregister LPC315X CODEC */
+	lpc315x_codec_unregister(lpc315x_codec_prv);
+
+	return;
+}
+
+module_init(lpc315x_codec_init);
+module_exit(lpc315x_codec_exit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC Audio CODEC driver for LPC315X codec");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/lpc315x_codec.h b/sound/soc/codecs/lpc315x_codec.h
new file mode 100644
index 0000000..9502432
--- /dev/null
+++ b/sound/soc/codecs/lpc315x_codec.h
@@ -0,0 +1,163 @@
+/*
+ * sound/soc/codecs/lpc315x_codec.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LPC315X_CODEC_H
+#define _LPC315X_CODEC_H
+
+/* LPC315X CODEC register addresses */
+#define LPC315X_CODEC_CODEC_START	(0x00000010)
+
+#define LPC315X_CODEC_CGU		(0x00000002)
+#define LPC315X_CODEC_PGA		(0x00000010)
+#define LPC315X_CODEC_AIN1		(0x00000011)
+#define LPC315X_CODEC_AOUT		(0x00000012)
+#define LPC315X_CODEC_DEC		(0x00000013)
+#define LPC315X_CODEC_INT0		(0x00000014)
+#define LPC315X_CODEC_INT1		(0x00000015)
+#define LPC315X_CODEC_I2SMUX1		(0x00000016)
+#define LPC315X_CODEC_DEC_STA		(0x00000017)
+
+#define LPC315X_CODEC_NUM_REGS	(0x8)
+
+/* PGA register bit definitions */
+#define LPC315X_CODEC_PGA_RC		(0x0000000F)
+#define LPC315X_CODEC_PGA_MIC		(0x000000F0)
+#define LPC315X_CODEC_PGA_LC		(0x00000F00)
+
+/* AIN1 register bit definitions */
+#define LPC315X_CODEC_AIN1_XFBADR		(0x00000001)
+#define LPC315X_CODEC_AIN1_XFBADL		(0x00000002)
+#define LPC315X_CODEC_AIN1_DITHR		(0x00000004)
+#define LPC315X_CODEC_AIN1_PD_VCOM_VREF1	(0x00000010)
+#define LPC315X_CODEC_AIN1_PD_BIAS		(0x00000020)
+#define LPC315X_CODEC_AIN1_PD_ADCR		(0x00000040)
+#define LPC315X_CODEC_AIN1_PD_ADCL		(0x00000080)
+#define LPC315X_CODEC_AIN1_PD_SDCR		(0x00000100)
+#define LPC315X_CODEC_AIN1_PD_SDCM		(0x00000200)
+#define LPC315X_CODEC_AIN1_PD_SDCL		(0x00000400)
+#define LPC315X_CODEC_AIN1_PD_PGAR		(0x00000800)
+#define LPC315X_CODEC_AIN1_PD_PGAM		(0x00001000)
+#define LPC315X_CODEC_AIN1_PD_PGAL		(0x00002000)
+#define LPC315X_CODEC_AIN1_PD_LNA		(0x00004000)
+
+#define LPC315X_CODEC_AIN1_BIAS_OFF		(0x00007FFF)
+
+/* MUX0 & MUX1 input selection for right channel */
+#define LPC315X_CODEC_AIN1_MUXR_MSK		(0x00018000)
+#define LPC315X_CODEC_AIN1_MUXR_TIN		(0x00000000)
+#define LPC315X_CODEC_AIN1_MUXR_LIN		(0x00008000)
+#define LPC315X_CODEC_AIN1_MUXR_MIN_TBY		(0x00010000)
+#define LPC315X_CODEC_AIN1_MUXR_MIN_LBY		(0x00018000)
+
+/* MUX0 & MUX1 input selection for left channel */
+#define LPC315X_CODEC_AIN1_MUXL_MSK		(0x00060000)
+#define LPC315X_CODEC_AIN1_MUXL_TIN		(0x00000000)
+#define LPC315X_CODEC_AIN1_MUXL_LIN		(0x00020000)
+#define LPC315X_CODEC_AIN1_MUXL_MIN_TBY		(0x00040000)
+#define LPC315X_CODEC_AIN1_MUXL_MIN_LBY		(0x00060000)
+
+/* AOUT register bit definitions */
+#define LPC315X_CODEC_AOUT_PD_ANVC_R		(0x00000001)
+#define LPC315X_CODEC_AOUT_PD_ANVC_L		(0x00000002)
+#define LPC315X_CODEC_AOUT_PD_SET_DWA		(0x00000004)
+#define LPC315X_CODEC_AOUT_PD_SET_I2S_FMT	(0x00000008)
+#define LPC315X_CODEC_AOUT_PD_SDAC_R		(0x00000010)
+#define LPC315X_CODEC_AOUT_PD_SDAC_L		(0x00000020)
+
+#define LPC315X_CODEC_AOUT_CTRL_SET_LMT		(0x000000C0)
+
+#define LPC315X_CODEC_AOUT_PD_HP_R		(0x00001000)
+#define LPC315X_CODEC_AOUT_PD_HP_C		(0x00002000)
+#define LPC315X_CODEC_AOUT_PD_HP_L		(0x00004000)
+#define LPC315X_CODEC_AOUT_VREF_SLOW		(0x00008000)
+#define LPC315X_CODEC_AOUT_VREF_SLOW_UP		(0x40000000)
+#define LPC315X_CODEC_AOUT_SWDAC_ON		(0x80000000)
+
+#define LPC315X_CODEC_AOUT_AVC_COA_GAIN_POS	(16)
+#define LPC315X_CODEC_AOUT_AVC_COA_GAIN_MSK	(0x07FF0000)
+#define LPC315X_CODEC_AOUT_AVC_FIN_GAIN_POS	(27)
+#define LPC315X_CODEC_AOUT_AVC_FIN_GAIN_MSK	(0x38000000)
+
+/* I2S MUX - Format values */
+#define LPC315X_CODEC_I2SMUX1_TX_FMT_MSK	(0x00000007)
+#define LPC315X_CODEC_I2SMUX1_TX_FMT_I2S	(0x00000003)
+#define LPC315X_CODEC_I2SMUX1_TX_FMT_LSB_16	(0x00000004)
+#define LPC315X_CODEC_I2SMUX1_TX_FMT_LSB_18	(0x00000005)
+#define LPC315X_CODEC_I2SMUX1_TX_FMT_LSB_20	(0x00000006)
+#define LPC315X_CODEC_I2SMUX1_TX_FMT_LSB_24	(0x00000007)
+
+#define LPC315X_CODEC_I2SMUX1_RX_FMT_MSK	(0x00000700)
+#define LPC315X_CODEC_I2SMUX1_RX_FMT_DAD	(0x00000000)
+#define LPC315X_CODEC_I2SMUX1_RX_FMT_SPD	(0x00000100)
+#define LPC315X_CODEC_I2SMUX1_RX_FMT_I2S	(0x00000300)
+#define LPC315X_CODEC_I2SMUX1_RX_FMT_LSB_16	(0x00000400)
+#define LPC315X_CODEC_I2SMUX1_RX_FMT_LSB_18	(0x00000500)
+#define LPC315X_CODEC_I2SMUX1_RX_FMT_LSB_20	(0x00000600)
+#define LPC315X_CODEC_I2SMUX1_RX_FMT_LSB_24	(0x00000700)
+
+#define LPC315X_CODEC_I2SMUX1_DEMUX_MSK		(0x00010000)
+
+/* INT0 Register bit definitions */
+#define	LPC315X_CODEC_INT0_PD_DAC		(0x00000080)
+#define	LPC315X_CODEC_INT0_SET_SIL		(0x00000008)
+
+/* Analog CGU register bit definitions */
+#define	LPC315X_CODEC_CGU_CLKDAC_INV		(0x00800000)
+#define	LPC315X_CODEC_CGU_ADCSYS_256FS		(0x00100000)
+#define	LPC315X_CODEC_CGU_ADC1_OFF		(0x00080000)
+#define	LPC315X_CODEC_CGU_ADC2_128FS		(0x00040000)
+#define	LPC315X_CODEC_CGU_CLKDAC_256FS		(0x00020000)
+#define	LPC315X_CODEC_CGU_CLKINT_256FS		(0x00010000)
+
+/* Playback clocks */
+#define	LPC315X_CODEC_CGU_PD_I2C256FS_CLK	(0x00000001)
+#define	LPC315X_CODEC_CGU_PD_DSP_CLK		(0x00000002)
+#define	LPC315X_CODEC_CGU_PD_NS_CLK		(0x00000004)
+#define	LPC315X_CODEC_CGU_PD_I2SRX_BCLK		(0x00000040)
+#define	LPC315X_CODEC_CGU_PD_I2SRX_SYSCLK	(0x00000080)
+#define	LPC315X_CODEC_CGU_PD_DAC_CLK		(0x00000800)
+
+/* Recording clocks */
+#define	LPC315X_CODEC_CGU_PD_DEC_CLK		(0x00000008)
+#define	LPC315X_CODEC_CGU_PD_I2STX_BCLK		(0x00000010)
+#define	LPC315X_CODEC_CGU_PD_I2STX_SYSCLK	(0x00000020)
+#define	LPC315X_CODEC_CGU_PD_ADC2_CLK		(0x00001000)
+#define	LPC315X_CODEC_CGU_PD_ADC1_CLK		(0x00002000)
+#define	LPC315X_CODEC_CGU_PD_ADCSYS_CLK		(0x00004000)
+
+/* INT1 register definitions */
+#define	LPC315X_CODEC_INT1_MAS_MUTE		(0x00010000)
+#define	LPC315X_CODEC_INT1_MAS_VOL_L_POS	(0)
+#define	LPC315X_CODEC_INT1_MAS_VOL_L_MSK	(0x000000FF)
+#define	LPC315X_CODEC_INT1_MAS_VOL_R_POS	(8)
+#define	LPC315X_CODEC_INT1_MAS_VOL_R_MSK	(0x0000FF00)
+
+/* Decimator register bits */
+#define	LPC315X_CODEC_DEC_GAIN_R_MASK		(0x000000FF)
+#define	LPC315X_CODEC_DEC_GAIN_L_MASK		(0x0000FF00)
+#define	LPC315X_CODEC_DEC_GAIN_R_POS		(0)
+#define	LPC315X_CODEC_DEC_GAIN_L_POS		(8)
+#define	LPC315X_CODEC_DEC_DC_IN_FIL		(0x00080000)
+#define	LPC315X_CODEC_DEC_DC_OUT_FIL		(0x00040000)
+#define	LPC315X_CODEC_DEC_MUTE			(0x00200000)
+#define	LPC315X_CODEC_DEC_AGC_EN		(0x00400000)
+
+extern struct snd_soc_codec_device soc_codec_lpc315x_dev;
+extern struct snd_soc_dai lpc315x_codec_dais[];
+
+#endif
diff --git a/sound/soc/codecs/uda1380.c b/sound/soc/codecs/uda1380.c
index 0441893..b7ae0f7 100644
--- a/sound/soc/codecs/uda1380.c
+++ b/sound/soc/codecs/uda1380.c
@@ -320,6 +320,7 @@ static const struct snd_kcontrol_new uda1380_snd_controls[] = {
 	SOC_SINGLE("DAC Polarity inverting Switch", UDA1380_MIXER, 15, 1, 0),	/* DA_POL_INV */
 	SOC_ENUM("Noise Shaper", uda1380_sel_ns_enum),				/* SEL_NS */
 	SOC_ENUM("Digital Mixer Signal Control", uda1380_mix_enum),		/* MIX_POS, MIX */
+	SOC_SINGLE("Silence Switch", UDA1380_MIXER, 7, 1, 0),			/* SILENCE, force DAC output to silence */
 	SOC_SINGLE("Silence Detector Switch", UDA1380_MIXER, 6, 1, 0),		/* SDET_ON */
 	SOC_ENUM("Silence Detector Setting", uda1380_sdet_enum),		/* SD_VALUE */
 	SOC_ENUM("Oversampling Input", uda1380_os_enum),			/* OS */
@@ -595,6 +596,24 @@ static void uda1380_pcm_shutdown(struct snd_pcm_substream *substream,
 	uda1380_write(codec, UDA1380_CLK, clk);
 }
 
+static int uda1380_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 mute_reg = uda1380_read_reg_cache(codec, UDA1380_DEEMP) & ~R13_MTM;
+
+	/* FIXME: mute(codec,0) is called when the magician clock is already
+	 * set to WSPLL, but for some unknown reason writing to interpolator
+	 * registers works only when clocked by SYSCLK */
+	u16 clk = uda1380_read_reg_cache(codec, UDA1380_CLK);
+	uda1380_write(codec, UDA1380_CLK, ~R00_DAC_CLK & clk);
+	if (mute)
+		uda1380_write(codec, UDA1380_DEEMP, mute_reg | R13_MTM);
+	else
+		uda1380_write(codec, UDA1380_DEEMP, mute_reg);
+	uda1380_write(codec, UDA1380_CLK, clk);
+	return 0;
+}
+
 static int uda1380_set_bias_level(struct snd_soc_codec *codec,
 	enum snd_soc_bias_level level)
 {
@@ -647,6 +666,7 @@ static struct snd_soc_dai_ops uda1380_dai_ops = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
 	.trigger	= uda1380_trigger,
+	.digital_mute = uda1380_mute,
 	.set_fmt	= uda1380_set_dai_fmt_both,
 };
 
@@ -654,6 +674,7 @@ static struct snd_soc_dai_ops uda1380_dai_ops_playback = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
 	.trigger	= uda1380_trigger,
+	.digital_mute = uda1380_mute,
 	.set_fmt	= uda1380_set_dai_fmt_playback,
 };
 
@@ -661,6 +682,7 @@ static struct snd_soc_dai_ops uda1380_dai_ops_capture = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
 	.trigger	= uda1380_trigger,
+	.digital_mute = uda1380_mute,
 	.set_fmt	= uda1380_set_dai_fmt_capture,
 };
 
diff --git a/sound/soc/lpc313x/Kconfig b/sound/soc/lpc313x/Kconfig
new file mode 100644
index 0000000..552dadb
--- /dev/null
+++ b/sound/soc/lpc313x/Kconfig
@@ -0,0 +1,196 @@
+config SND_LPC313X_SOC
+        tristate "SoC Audio for the NXP LPC313X System-on-a-Chip"
+				depends on ARCH_LPC31XX && SND_SOC && MACH_EA313X
+        help
+          Say Y or M if you want to add audio support for the LPC313X.
+          You will also need to to select the audio interfaces to
+	  support below.
+
+config SND_LPC315X_SOC
+	tristate "SoC Audio for the NXP LPC315X System-on-a-Chip"
+	depends on ARCH_LPC31XX && SND_SOC && MACH_EA3152
+	help
+	Say Y or M if you want to add audio support for the LPC313X.
+	You will also need to to select the audio interfaces to
+	support below.
+
+config SND_LPC313X_SOC_I2S
+        bool
+
+config SND_LPC313X_SOC_I2S_UDA1380
+        bool "SoC Audio for the UDA1380 CODEC using I2S/I2C"
+        depends on SND_LPC313X_SOC
+        select I2C_PNX
+        select SND_LPC313X_SOC_I2S
+        select SND_SOC_UDA1380
+        help
+          Say Y here if you want to add support for SoC audio on the
+	  LPC313x with the UDA1380 CODEC. This requires an I2S channel
+	  and I2C channel connected to the I2C interface of the
+	  UDA1380 codec.
+
+config SND_LPC315X_SOC_I2S_LPC315X_CODEC
+	bool "SoC Audio for the Analog Die CODEC using I2S/I2C in 315X SoC"
+	depends on SND_LPC315X_SOC
+	select I2C_PNX
+	select SND_LPC313X_SOC_I2S
+	select SND_SOC_LPC315X_CODEC
+	help
+		Say Y here if you want to add support for SoC audio on the
+		LPC315x with the Analog Die CODEC. This requires an I2S channel
+		and I2C channel connected to the I2C interface of the
+		Analog Die CODEC.
+
+config SND_USE_EA3131
+        bool "Enable audio configuration for the EA3131 board"
+        depends on SND_LPC313X_SOC
+	select SND_LPC313X_SOC_I2S_UDA1380
+	select SND_I2C1_CHANNEL_UDA1380
+	select SND_I2S_RX1_MASTER
+	select SND_I2S_TX1_MASTER
+	select SND_CODEC_FS256
+        help
+          Say Y to configuration audio for the EA3131 board. The EA3131
+	  board used the I2S1 channel with the UDA1380 audio CODEC and
+	  I2C on channel 1.
+
+config SND_USE_EA3152
+	bool "Enable audio configuration for the EA3152 board"
+	depends on SND_LPC315X_SOC
+	select SND_LPC315X_SOC_I2S_LPC315X_CODEC
+	select SND_I2C1_CHANNEL_LPC315X_CODEC
+	select SND_I2S_RX1_MASTER
+	select SND_I2S_TX1_MASTER
+	select SND_CODEC_FS128
+	help
+		Say Y to configuration audio for the EA3152 board. The EA3152
+		board uses the I2S1 channel with the Analog Die audio CODEC and
+		I2C on channel 1.
+
+config SND_I2C1_CHANNEL_UDA1380
+	bool "I2C1 channel connected to the UDA1380"
+	depends on SND_LPC313X_SOC_I2S_UDA1380
+	help
+	  Say Y here to use the I2C1 channel to communicate with the
+	  UDA1380 CODEC. Not selecting this option will use I2C0.
+
+config SND_I2C1_CHANNEL_LPC315X_CODEC
+	bool "I2C1 channel connected to the Analog Die Audio CODEC"
+	depends on SND_LPC315X_SOC_I2S_LPC315X_CODEC
+	help
+	  Say Y here to use the I2C1 channel to communicate with the
+	  Analog Die Audio CODEC. Not selecting this option will use I2C0.
+
+choice
+	prompt "I2S RX channel configuration"
+	depends on SND_LPC313X_SOC_I2S
+	help
+	  This menu selects the I2S RX (record) channel configurations
+
+	config SND_I2S_RX0_MASTER
+	bool "I2S RX0 master mode"
+	help
+	  Select this option to only used the I2S RX0 channel for
+	  audio record in master mode.
+
+	config SND_I2S_RX1_MASTER
+	bool "I2S RX1 master mode"
+	help
+	  Select this option to only used the I2S RX1 channel for
+	  audio record in master mode.
+
+	config SND_I2S_RX0_SLAVE
+	bool "I2S RX0 slave mode"
+	help
+	  Select this option to only used the I2S RX0 channel for
+	  audio record in slave mode.
+
+	config SND_I2S_RX1_SLAVE
+	bool "I2S RX1 slave mode"
+	help
+	  Select this option to only used the I2S RX1 channel for
+	  audio record in slave mode.
+
+endchoice
+
+choice
+	prompt "I2S TX channel configuration"
+	depends on SND_LPC313X_SOC_I2S
+	help
+	  This menu selects the I2S TX (playback) channel configurations
+
+	config SND_I2S_TX0_MASTER
+	bool "I2S TX0 master mode"
+	help
+	  Select this option to only used the I2S TX0 channel for
+	  audio playback in master mode.
+
+	config SND_I2S_TX1_MASTER
+	bool "I2S TX1 master mode"
+	help
+	  Select this option to only used the I2S TX1 channel for
+	  audio record in playback mode.
+
+endchoice
+
+choice
+	prompt "WS clock divider"
+	depends on SND_LPC313X_SOC_I2S && SND_LPC313X_SOC
+	help
+	  This divider is used to generate the WS rate from the CODEC
+	  clock. The CODEC clock may or may not be generated by the LPC313x.
+	  If it is, it is generated on the CLK_256FS pin. This divider is
+	  usually a factor of 256, 384, 512, 768, or 1024 times the sample
+	  frequency. Selected the correct multiplier here to have the audio
+	  driver generate the correct clock rates for the audio CODEC.
+
+	config SND_CODEC_FS256
+	bool "CODEC clock is 256FS"
+
+	config SND_CODEC_FS384
+	bool "CODEC clock is 384FS"
+
+	config SND_CODEC_FS512
+	bool "CODEC clock is 512FS"
+
+	config SND_CODEC_FS768
+	bool "CODEC clock is 768FS"
+
+	config SND_CODEC_FS1024
+	bool "CODEC clock is 1024FS"
+
+endchoice
+
+choice
+	prompt "WS clock divider"
+	depends on SND_LPC313X_SOC_I2S && SND_LPC315X_SOC
+	help
+	  This divider is used to generate the WS rate from the CODEC
+	  clock. The CODEC clock is generated by LPC315x digital Die.
+	  It is generated on the CLK_256FS pin. This divider is
+	  usually a factor of 128 times the sample frequency.
+	  Selected the correct multiplier here to have the audio
+	  driver generate the correct clock rates for the audio CODEC.
+
+	config SND_CODEC_FS128
+	bool "CODEC clock is 128FS"
+
+endchoice
+
+config SND_CODEC_NO_FS256_NEEDED
+        bool "Disable the CLK_FS256 signals"
+				depends on SND_LPC313X_SOC || SND_LPC315X_SOC
+        help
+          For audio CODECs that do not need the FS256 clock, enable this
+	  option. These CODECs usually generate internal clocking based
+	  on the BCK and ES signals from the LPC313X I2S signals.
+
+config SND_USE_DMA_LINKLIST
+        bool "Use a DMA linked list instead of a circular buffer"
+	default y
+				depends on SND_LPC313X_SOC || SND_LPC315X_SOC
+        help
+          The audio driver supports 2 DMA mode: circular buffer mode and
+	  DMA linked list mode. This option lets you choose which mode to
+	  use. DMA linked list mode is recommended.
+
diff --git a/sound/soc/lpc313x/Makefile b/sound/soc/lpc313x/Makefile
new file mode 100644
index 0000000..8c42e30
--- /dev/null
+++ b/sound/soc/lpc313x/Makefile
@@ -0,0 +1,18 @@
+# LPC313X Platform Support
+snd-soc-lpc313x-objs := lpc313x-pcm.o
+snd-soc-lpc313x-i2s-objs := lpc313x-i2s.o
+
+obj-$(CONFIG_SND_LPC313X_SOC) += snd-soc-lpc313x.o
+obj-$(CONFIG_SND_LPC315X_SOC) += snd-soc-lpc313x.o
+obj-$(CONFIG_SND_LPC313X_SOC_I2S) += snd-soc-lpc313x-i2s.o lpc313x-i2s-clocking.o
+
+# LPC3XXX Machine Support
+snd-soc-lpc313x-uda1380-objs := lpc313x-uda1380.o
+
+obj-$(CONFIG_SND_LPC313X_SOC_I2S_UDA1380) += snd-soc-lpc313x-uda1380.o
+
+# LPC315X Machine Support
+snd-soc-lpc315x-codec-objs := lpc315x-codec.o
+
+obj-$(CONFIG_SND_LPC315X_SOC_I2S_LPC315X_CODEC) += snd-soc-lpc315x-codec.o
+
diff --git a/sound/soc/lpc313x/lpc313x-i2s-clocking.c b/sound/soc/lpc313x/lpc313x-i2s-clocking.c
new file mode 100644
index 0000000..9e93378
--- /dev/null
+++ b/sound/soc/lpc313x/lpc313x-i2s-clocking.c
@@ -0,0 +1,369 @@
+/*
+ * sound/soc/lpc313x/lpc313x-i2s-clocking.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ * Note: Fractional clock divider domains are defined in the bootloader
+ * code. As of the time this driver was developed, the fractional
+ * divider groupings are mapped as follows:
+ *     Group 17 -> TX0 WS, TX1, WS, RX0 WS, RX1 WS
+ *     Group 18 -> TX0 BCK, TX1 BCK
+ *     Group 19 -> CLK_256FS, TX_CLK0
+ *     Group 20 -> RX0 BCK, RX1 BCK
+ *
+ * The driver supports the following sample rates and FS clock
+ * multipliers. These rates are dependent on an external 12MHz
+ * oscillator input. All these rates are generated from a small set of
+ * PLL frequencies and a fractional divider. Some of the rates can be
+ * generated by more than 1PLL frequency.
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  256FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  384FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  512FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  768FS     Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ *  1024FS    Yes Yes     Yes Yes Yes    Yes Yes Yes   Yes
+ */
+
+#include <linux/io.h>
+
+#include <mach/board.h>
+#include <mach/registers.h>
+#include "lpc313x-i2s-clocking.h"
+
+struct i2s_clk_setup {
+	u32 target_codec_rate;
+	u32 real_fs_codec_rate;
+};
+static struct i2s_clk_setup i2s_clk_state;
+
+/*
+ * clock setup enable/disable selection arrays - these clocks are enabled as a group
+ * for a specific I2S channel
+ */
+static CGU_CLOCK_ID_T rx0clks[] = {
+	CGU_SB_I2SRX_IF_0_PCLK_ID,
+	CGU_SB_I2SRX_FIFO_0_PCLK_ID,
+	CGU_SB_I2SRX_BCK0_N_ID,
+	CGU_SB_I2SRX_WS0_ID,
+	CGU_SB_I2SRX_BCK0_ID,
+	CGU_SB_INVALID_CLK_ID
+};
+static CGU_CLOCK_ID_T tx0clks[] = {
+	CGU_SB_I2STX_IF_0_PCLK_ID,
+	CGU_SB_I2STX_FIFO_0_PCLK_ID,
+	CGU_SB_I2STX_BCK0_N_ID,
+	CGU_SB_I2STX_WS0_ID,
+	CGU_SB_INVALID_CLK_ID
+};
+static CGU_CLOCK_ID_T rx1clks[] = {
+	CGU_SB_I2SRX_IF_1_PCLK_ID,
+	CGU_SB_I2SRX_FIFO_1_PCLK_ID,
+	CGU_SB_I2SRX_BCK1_N_ID,
+	CGU_SB_I2SRX_WS1_ID,
+	CGU_SB_I2SRX_BCK1_ID,
+	CGU_SB_INVALID_CLK_ID
+};
+static CGU_CLOCK_ID_T tx1clks[] = {
+	CGU_SB_I2STX_IF_1_PCLK_ID,
+	CGU_SB_I2STX_FIFO_1_PCLK_ID,
+	CGU_SB_I2STX_BCK1_N_ID,
+	CGU_SB_I2STX_WS1_ID,
+	CGU_SB_INVALID_CLK_ID
+};
+
+typedef CGU_CLOCK_ID_T * P_CGU_CLOCK_ID_T;
+static P_CGU_CLOCK_ID_T clkarray[CLK_TX_1 + 1] = {
+	rx0clks,
+	tx0clks,
+	rx1clks,
+	tx1clks
+};
+
+/* 48K*1024 sysclk rate settings (12M oscillator input),
+   49152000Hz FS clock, error .003999Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS     48          32  24         16  12        8
+ *  256FS     24          16  12         8   6         4
+ *  384FS     16              8              4
+ *  512FS     12          8              4   3         2
+ *  768FS     8               4              2
+ *  1024FS    6           4   3          2             1
+*/
+static CGU_HPLL_SETUP_T pllsetup_48K_1024 = {
+	CGU_FIN_SELECT_FFAST, 514, 21708, 5, 0, 44, 21, 0, (48000 * 1024)
+};
+
+/* 48K*768 sysclk rate settings (12M oscillator input),
+   36864000Hz FS clock, error .003999Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS     36          24  18         12            6
+ *  256FS     18          12  9          6             3
+ *  384FS     12          8   6          4   3         2
+ *  512FS     9           6
+ *  768FS     6           4              2             1
+ *  1024FS
+*/
+static CGU_HPLL_SETUP_T pllsetup_48K_768 = {
+	CGU_FIN_SELECT_FFAST, 514, 21299, 21, 0, 44, 22, 0, (48000 * 768)
+};
+
+/* 44.1K*1024 sysclk rate settings (12M oscillator input),
+   45158400Hz FS clock, error .0131999Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS         32              16              8
+ *  256FS         16              8               4
+ *  384FS
+ *  512FS         8               4               2
+ *  768FS
+ *  1024FS        4               2               1
+*/
+static CGU_HPLL_SETUP_T pllsetup_44_1K_1024 = {
+	CGU_FIN_SELECT_FFAST, 770, 8191, 2, 0, 16, 8, 0, (44100 * 1024)
+};
+
+/* 44.1K*768 sysclk rate settings (12M oscillator input),
+   33868800Hz FS clock, error .0099Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS         24              12              6
+ *  256FS         12              6               3
+ *  384FS         8               4               2
+ *  512FS         6               3
+ *  768FS         4               2               1
+ *  1024FS        3
+*/
+static CGU_HPLL_SETUP_T pllsetup_44_1K_768 = {
+	CGU_FIN_SELECT_FFAST, 514, 19660, 11, 0, 48, 23, 0, (44100 * 768)
+};
+
+/* 32K*1024 sysclk rate settings (12M oscillator input),
+   32768000Hz FS clock, error .01638Hz
+   used for the following rates with the following dividers:
+ *            8K  11.025K 12K 16K 22.05K 24K 32K 44.1K 48K
+ *  128FS     32              16             8
+ *  256FS     16              8              4
+ *  384FS
+ *  512FS     8               4              2
+ *  768FS
+ *  1024FS                                   1
+*/
+static CGU_HPLL_SETUP_T pllsetup_32K_1024 = {
+	CGU_FIN_SELECT_FFAST, 770, 32765, 21, 0, 20, 10, 0, (32000 * 1024)
+};
+
+static CGU_HPLL_SETUP_T *ppll_list[] = {
+	&pllsetup_32K_1024,
+	&pllsetup_44_1K_768,
+	&pllsetup_44_1K_1024,
+	&pllsetup_48K_768,
+	&pllsetup_48K_1024,
+	NULL
+};
+
+#if defined(CONFIG_SND_LPC315X_SOC)
+/* For LPC315X Analog CODEC 128FS clock has to be used */
+static const u32 fsdiv =
+#if defined (CONFIG_SND_CODEC_FS128)
+	128;
+#endif
+#endif
+
+#if defined(CONFIG_SND_LPC313X_SOC)
+static const u32 fsdiv =
+#if defined (CONFIG_SND_CODEC_FS256)
+	256;
+#elif defined (CONFIG_SND_CODEC_FS384)
+	384;
+#elif defined (CONFIG_SND_CODEC_FS512)
+	512;
+#elif defined (CONFIG_SND_CODEC_FS768)
+	768;
+#elif defined (CONFIG_SND_CODEC_FS1024)
+	1024;
+#endif
+#endif
+
+static u32 lpc313x_set_best_rate(u32 freq)
+{
+	CGU_FDIV_SETUP_T clk_div;
+	u32 diff;
+	int i = 0;
+
+	clk_div.stretch = 1;
+
+	while (ppll_list[i] != NULL)
+	{
+		/* Find match divider based on current FS divider and rate */
+		diff = ppll_list[i]->freq / fsdiv;
+		clk_div.m = diff / freq;
+		diff = diff - (freq * clk_div.m);
+
+		if (diff == 0)
+		{
+			if (clk_div.m <= 1)
+			{
+				clk_div.n = 0;
+				clk_div.m = 0;
+			}
+			else
+			{
+				clk_div.n = 1;
+			}
+
+			/* Set PLL rate and divider for CODEC clock */
+			i2s_clk_state.real_fs_codec_rate = ppll_list[i]->freq;
+			cgu_hpll_config(CGU_HPLL0_ID, ppll_list[i]);
+			cgu_fdiv_config(19, clk_div, 1);
+			return freq;
+		}
+
+		i++;
+	}
+
+	return 0;
+}
+
+/*
+ * Sets up the audio PLL to generate a frequency as close as possible to
+ * the target clkrate frequency
+ */
+static u32 lpc313x_set_codec_freq(u32 freq)
+{
+	if (freq == 0)
+	{
+		/* Disable the required audio CODEC clocks */
+		cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 0);
+		cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 0);
+	}
+	else if (freq != i2s_clk_state.target_codec_rate)
+	{
+		/* Disable the required audio CODEC clocks during frequency change */
+		cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 0);
+		cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 0);
+
+		freq = lpc313x_set_best_rate(freq);
+		if (freq > 0)
+		{
+#if !defined (CONFIG_SND_CODEC_NO_FS256_NEEDED)
+			/* Enable clock */
+			cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 1);
+#endif
+			cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 1);
+		}
+	}
+
+	i2s_clk_state.target_codec_rate = freq;
+
+	return freq;
+}
+
+/*
+ * Start or stop a channel's clocks
+ */
+static void lpc313x_ch_clk_disen(enum i2s_supp_clks chclk, int en)
+{
+	int i = 0;
+	P_CGU_CLOCK_ID_T pclks = (P_CGU_CLOCK_ID_T) clkarray[chclk];
+
+	while (pclks[i] != CGU_SB_INVALID_CLK_ID)
+	{
+		cgu_clk_en_dis(pclks[i], en);
+		i++;
+	}
+}
+
+/*
+ * Sets up the channel bit clock to generate a rate as close as possible
+ * to the target clkrate frequency
+ */
+static u32 lpc313x_set_ch_freq(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
+{
+	CGU_FDIV_SETUP_T ch_div;
+
+	if (ws_freq == 0)
+	{
+		/* Turn channel clock off */
+		lpc313x_ch_clk_disen(chclk, 0);
+		bit_freq = 0;
+	}
+	else
+	{
+		/* Stop channel clocks for the change */
+		lpc313x_ch_clk_disen(chclk, 0);
+
+		ch_div.stretch = 1;
+		ch_div.n = 1;
+
+		/* Find divider to generate target WS frequency from PLL */
+		ch_div.m = i2s_clk_state.real_fs_codec_rate / ws_freq;
+		cgu_fdiv_config(17, ch_div, 1);
+
+		/* Find divider to generate target bck frequency from PLL */
+		ch_div.m = i2s_clk_state.real_fs_codec_rate / bit_freq;
+
+		if ((chclk == CLK_RX_0) || (chclk == CLK_RX_1)) {
+			cgu_fdiv_config(20, ch_div, 1);
+		}
+		if ((chclk == CLK_TX_0) || (chclk == CLK_TX_1)) {
+			cgu_fdiv_config(18, ch_div, 1);
+		}
+
+		/* Enable channel clock */
+		lpc313x_ch_clk_disen(chclk, 1);
+	}
+
+	return ws_freq;
+}
+
+/*
+ * Set the audio CODEC clock rate or 0 to disable the clock, returns
+ * the actual programmed clock rate. The programmed rate is generated on
+ * the FS256 pin has a rate of (256 * clkrate).
+ */
+u32 lpc313x_main_clk_rate(u32 freq)
+{
+	u32 ret = 0;
+	/* Compute and set proper divider */
+	ret = lpc313x_set_codec_freq(freq);
+#if defined (CONFIG_SND_DEBUG_VERBOSE)
+	pr_info("LPC313x ASOC main clock : %d (%d)\n",
+		i2s_clk_state.target_codec_rate,
+		i2s_clk_state.real_fs_codec_rate);
+#endif
+	return ret;
+}
+
+/*
+ * Set a specific channel's bit clock and word select rates. his applies
+ * to the channel's WS and BCLK signals. Returns the actual programmed
+ * WS clock rate.
+ */
+u32 lpc313x_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
+{
+	/* Compute and set proper divider */
+	return lpc313x_set_ch_freq(chclk, ws_freq, bit_freq);
+}
+
diff --git a/sound/soc/lpc313x/lpc313x-i2s-clocking.h b/sound/soc/lpc313x/lpc313x-i2s-clocking.h
new file mode 100644
index 0000000..d00103a
--- /dev/null
+++ b/sound/soc/lpc313x/lpc313x-i2s-clocking.h
@@ -0,0 +1,66 @@
+/*
+ * sound/soc/lpc313x/lpc313x-i2s-clocking.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ * This file provides the necessary clocking and control functions for the
+ * sound drivers on the LPC313X. These functions include clock enable and
+ * disable, and clock frequency setup on the WS, BCLK, and SYSCLK pins.
+ *
+ * Pin mapping is as follows:
+ *     Chip signal name         CODEC signal name
+ *     CLK_256FS                Audio CODEC clock
+ *     I2SRX_WS0                I2S RX channel 0 Word select clock
+ *     I2SRX_WS1                I2S RX channel 1 Word select clock
+ *     I2STX_WS0                I2S TX channel 0 Word select clock
+ *     I2STX_WS1                I2S TX channel 1 Word select clock
+ *     I2SRX_BCK0               I2S RX channel 0 serial data bit clock
+ *     I2SRX_BCK1               I2S RX channel 1 serial data bit clock
+ *     I2STX_BCK0               I2S TX channel 0 serial data bit clock
+ *     I2STX_BCK1               I2S TX channel 1 serial data bit clock
+ */
+
+#ifndef __LPC313X_I2S_CLOCKING_H
+#define __LPC313X_I2S_CLOCKING_H
+
+#include <linux/types.h>
+
+/*
+ * I2S supported clock groupings
+ */
+enum i2s_supp_clks {CLK_RX_0, CLK_TX_0, CLK_RX_1, CLK_TX_1};
+
+/*
+ * Set the audio CODEC clock rate or 0 to disable the clock, returns
+ * the actual programmed clock rate. The programmed rate is generated on
+ * the FS256 pin has a rate of (256 * clkrate).
+ */
+u32 lpc313x_main_clk_rate(u32 clkrate);
+
+/*
+ * Set a specific channel's bit clock and word select rates. his applies
+ * to the channel's WS and BCLK signals. Returns the actual programmed
+ * WS clock rate.
+ */
+u32 lpc313x_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq);
+
+#endif /* __LPC313X_I2S_CLOCKING */
diff --git a/sound/soc/lpc313x/lpc313x-i2s.c b/sound/soc/lpc313x/lpc313x-i2s.c
new file mode 100644
index 0000000..bdf6b45
--- /dev/null
+++ b/sound/soc/lpc313x/lpc313x-i2s.c
@@ -0,0 +1,436 @@
+/*
+ * sound/soc/lpc313x/lpc313x-i2s.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/board.h>
+#include <mach/registers.h>
+
+#include "lpc313x-i2s-clocking.h"
+#include "lpc313x-pcm.h"
+#include "lpc313x-i2s.h"
+
+#define I2S_NAME "lpc313x-i2s"
+
+/* All major audio rates are support and 16-bit I2S data is supported */
+#define LPC313X_I2S_RATES \
+    (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+     SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+     SNDRV_PCM_RATE_48000)
+#define LPC313X_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16)
+
+#define CH_PLAY 0
+#define CH_REC  1
+
+/* Structure that keeps I2S direction data */
+struct lpc313x_i2s_ch_info {
+	char *name;                 /* Name of this channel */
+	unsigned short ch_on;       /* Flag used to indicate if clocks are on */
+	unsigned short daifmt;
+	u32 ws_freq;
+	int i2s_ch;
+	enum i2s_supp_clks chclk;
+};
+
+/* Common I2S structure data */
+struct lpc313x_i2s_info {
+	spinlock_t lock;
+	unsigned short initialized;
+	struct lpc313x_i2s_ch_info ch_info[2];
+	u32 freq;
+};
+
+/* Common I2S structure data */
+static struct lpc313x_i2s_info i2s_info =
+{
+	.lock = __SPIN_LOCK_UNLOCKED(i2s_info.lock),
+	.initialized = 0,
+	.ch_info = 
+	{
+		[0] =
+		{
+#if defined (CONFIG_SND_I2S_TX0_MASTER)
+			.name  = "i2s0_play",
+			.chclk = CLK_TX_0,
+			.i2s_ch = I2S_CH_TX0,
+#else
+			.name  = "i2s1_play",
+			.chclk = CLK_TX_1,
+			.i2s_ch = I2S_CH_TX1,
+#endif
+			.ch_on = 0,
+		},
+		[1] =
+		{
+#if defined (CONFIG_SND_I2S_RX0_MASTER)
+			.name  = "i2s0_mrec",
+			.chclk = CLK_RX_0,
+			.i2s_ch = I2S_CH_RX0,
+#endif
+#if defined (CONFIG_SND_I2S_RX1_MASTER)
+			.name  = "i2s1_mrec",
+			.chclk = CLK_RX_1,
+			.i2s_ch = I2S_CH_RX1,
+#endif
+#if defined (SND_I2S_RX0_SLAVE)
+			.name  = "i2s0_srec",
+			/* Not supported yet, generate an error */
+			.i2s_ch = I2S_CH_RX0,
+#error
+#endif
+#if defined (SND_I2S_RX1_SLAVE)
+			.name  = "i2s1_srec",
+			/* Not supported yet, generate an error */
+			.i2s_ch = I2S_CH_RX1,
+#error
+#endif
+			.ch_on = 0,
+		},
+	},
+};
+
+static inline int lpc313x_get_ch_dir(struct snd_pcm_substream *substream)
+{
+	int dir = CH_REC;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dir = CH_PLAY;
+	}
+
+	return dir;
+}
+
+static void lpc313x_i2s_shutdown(struct snd_pcm_substream *substream,
+									struct snd_soc_dai *dai)
+{
+	int dir = lpc313x_get_ch_dir(substream);
+
+	if (i2s_info.ch_info[dir].ch_on == 0) {
+		/* This channel is not enabled! */
+		pr_warning("%s: I2S channel is not on!\n", i2s_info.ch_info[dir].name);
+		return;
+	}
+
+	/* Channel specific shutdown */
+	lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
+	i2s_info.ch_info[dir].ch_on = 0;
+
+	/* Can we shutdown I2S interface to save some power? */
+	if (i2s_info.ch_info[1 - dir].ch_on != 0) {
+		/* Other channel is busy, exit without shutting down main clock */
+		return;
+	}
+
+	/* Safe to shut down */
+	if (i2s_info.initialized == 0) {
+		/* Nothing is enabled! */
+		pr_warning("I2S shutdown (%s) when nothing is enabled!\n",
+			i2s_info.ch_info[dir].name);
+		return;
+	}
+
+	/* Disable I2S register access clock */
+	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 0);
+
+	i2s_info.initialized = 0;
+}
+
+static int lpc313x_i2s_startup(struct snd_pcm_substream *substream,
+								struct snd_soc_dai *dai)
+{
+	int dir = lpc313x_get_ch_dir(substream);
+
+	/* Select master/slave mode for RX channel */
+	if (dir == CH_REC) {
+#if defined (CONFIG_SND_I2S_RX0_SLAVE) | defined (CONFIG_SND_I2S_RX1_SLAVE)
+		I2S_CFG_MUX_SETTINGS = 0;
+#endif
+#if defined (CONFIG_SND_I2S_RX0_MASTER)
+		I2S_CFG_MUX_SETTINGS = I2S_RXO_SELECT_MASTER;
+#endif
+#if defined (CONFIG_SND_I2S_RX1_MASTER)
+		I2S_CFG_MUX_SETTINGS = I2S_RX1_SELECT_MASTER;
+#endif
+	}
+
+	if (i2s_info.ch_info[dir].ch_on != 0) {
+		/* This channel already enabled! */
+		pr_warning("%s: I2S channel is busy!\n", i2s_info.ch_info[dir].name);
+		return -EBUSY;
+	}
+
+	/* Initialize I2S interface */
+	if (i2s_info.initialized == 0) {
+		/* Enable I2S register access clock */
+		cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
+		cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
+
+		i2s_info.initialized = 1;
+	}
+
+	/* Channel specific init, ok to leave the clocks off for now */
+	i2s_info.ch_info[dir].ch_on = 1;
+	lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
+
+	/* Mask all interrupts for the I2S channel */
+	I2S_CH_INT_MASK(i2s_info.ch_info[dir].i2s_ch) = I2S_FIFO_ALL_MASK;
+
+	return 0;
+}
+
+static int lpc313x_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				      int clk_id, unsigned int freq, int dir)
+{
+	/* Will use in HW params later */
+//	i2s_info.ch_info[cpu_dai->id].ws_freq = freq;
+	i2s_info.ch_info[CH_REC].ws_freq = freq;
+	i2s_info.ch_info[CH_PLAY].ws_freq = freq;
+	return 0;
+}
+
+static int lpc313x_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+				   unsigned int fmt)
+{
+	/* Will use in HW params later */
+//	i2s_info.ch_info[cpu_dai->id].daifmt = fmt;
+	i2s_info.ch_info[CH_REC].daifmt = fmt;
+	i2s_info.ch_info[CH_PLAY].daifmt = fmt;
+
+	return 0;
+}
+
+static int lpc313x_i2s_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+				      int div_id, int div)
+{
+	/* This function isn't used */
+	(void) cpu_dai;
+	(void) div_id;
+	(void) div;
+
+	return 0;
+}
+
+static int lpc313x_i2s_hw_params(struct snd_pcm_substream *substream,
+			         struct snd_pcm_hw_params *params,
+					 struct snd_soc_dai *dai)
+{
+	int dir = lpc313x_get_ch_dir(substream);
+	u32 tmp;
+
+	/* Setup the I2S data format */
+	tmp = 0;
+	switch (i2s_info.ch_info[dir].daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			spin_lock_irq(&i2s_info.lock);
+			tmp = I2S_FORMAT_SETTINGS &
+				~I2S_SET_FORMAT(i2s_info.ch_info[dir].i2s_ch,
+				I2S_FORMAT_MASK);
+			I2S_FORMAT_SETTINGS = tmp | I2S_SET_FORMAT(i2s_info.ch_info[dir].i2s_ch,
+				I2S_FORMAT_I2S);
+			spin_unlock_irq(&i2s_info.lock);
+			break;
+
+		default:
+			pr_warning("%s: Unsupported audio data format\n",
+				i2s_info.ch_info[dir].name);
+			return -EINVAL;
+	}
+
+#if defined (CONFIG_SND_DEBUG_VERBOSE)
+	pr_info("Desired clock rate : %d\n", i2s_info.ch_info[dir].ws_freq);
+	pr_info("Channels           : %d\n", params_channels(params));
+	pr_info("Data format        : %d\n", i2s_info.ch_info[dir].daifmt);
+#endif
+
+	/* The playback and record rates are shared, so just set the CODEC clock
+	   to the selected rate (will actually generate 256 * rate) */
+	i2s_info.freq = i2s_info.ch_info[dir].ws_freq;
+	if (lpc313x_main_clk_rate(i2s_info.freq) == 0)
+	{
+		pr_warning("Unsupported audio data rate (%d)\n",
+			i2s_info.freq);
+		return -EINVAL;
+	}
+
+	/* Now setup the selected channel clocks (WS and BCK) */
+	if (lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, i2s_info.freq,
+		(i2s_info.freq * 32)) == 0)
+	{
+		pr_warning("Unsupported channel data rates (ws=%d, bck=%d)\n",
+			i2s_info.freq, (i2s_info.freq * 32));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lpc313x_i2s_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		break;
+
+	default:
+		pr_warning("lpc313x_i2s_triggers: Unsupported cmd: %d\n",
+				cmd);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int lpc313x_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	/* Shutdown active clocks */
+	if (i2s_info.ch_info[CH_PLAY].ch_on != 0) {
+		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk, 0, 0);
+	}
+	if (i2s_info.ch_info[CH_REC].ch_on != 0) {
+		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk, 0, 0);
+	}
+
+	/* Disable I2S register access clock */
+	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 0);
+	/* shutdown main clocks */
+	lpc313x_main_clk_rate(0);
+
+	return 0;
+}
+
+static int lpc313x_i2s_resume(struct snd_soc_dai *cpu_dai)
+{
+	/* resume main clocks */
+	lpc313x_main_clk_rate(i2s_info.freq);
+	/* Enable I2S register access clock */
+	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
+
+	/* resume active clocks */
+	if (i2s_info.ch_info[CH_PLAY].ch_on != 0) {
+		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk,
+		i2s_info.ch_info[CH_PLAY].ws_freq, (i2s_info.freq * 32));
+	}
+	if (i2s_info.ch_info[CH_REC].ch_on != 0) {
+		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk,
+		i2s_info.ch_info[CH_REC].ws_freq, (i2s_info.freq * 32));
+	}
+
+	return 0;
+}
+
+#else
+#define lpc313x_i2s_suspend	NULL
+#define lpc313x_i2s_resume	NULL
+#endif
+
+static struct snd_soc_dai_ops lpc313x_i2s_dai_ops = {
+		.startup = lpc313x_i2s_startup,
+		.shutdown = lpc313x_i2s_shutdown,
+		.trigger = lpc313x_i2s_trigger,
+		.hw_params = lpc313x_i2s_hw_params,
+		.set_sysclk = lpc313x_i2s_set_dai_sysclk,
+		.set_fmt = lpc313x_i2s_set_dai_fmt,
+		.set_clkdiv = lpc313x_i2s_set_dai_clkdiv,		
+};
+
+struct snd_soc_dai_driver lpc313x_i2s_dai = {
+	 .name = I2S_NAME,
+	 .id = 0,
+	 .suspend = lpc313x_i2s_suspend,
+	 .resume = lpc313x_i2s_resume,
+	 .playback = {
+		      .channels_min = 2,
+		      .channels_max = 2,
+		      .rates = LPC313X_I2S_RATES,
+		      .formats = LPC313X_I2S_FORMATS,
+		      },
+	 .capture = {
+		     .channels_min = 2,
+		     .channels_max = 2,
+		     .rates = LPC313X_I2S_RATES,
+		     .formats = LPC313X_I2S_FORMATS,
+		     },
+	 .ops = &lpc313x_i2s_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL_GPL(lpc313x_i2s_dai);
+
+static __devinit int lpc313x_i2s_dev_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_dai(&pdev->dev, &lpc313x_i2s_dai);
+}
+
+static __devexit int lpc313x_i2s_dev_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_dai(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver lpc313x_i2s_driver = {
+	.probe  = lpc313x_i2s_dev_probe,
+	.remove = lpc313x_i2s_dev_remove,
+	.driver = {
+		.name = I2S_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init lpc313x_i2s_init(void)
+{
+	return platform_driver_register(&lpc313x_i2s_driver);
+}
+module_init(lpc313x_i2s_init);
+
+static void __exit lpc313x_i2s_exit(void)
+{
+	platform_driver_unregister(&lpc313x_i2s_driver);
+}
+module_exit(lpc313x_i2s_exit);
+
+/* Module information */
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC LPC313X I2S interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" I2S_NAME);
+
diff --git a/sound/soc/lpc313x/lpc313x-i2s.h b/sound/soc/lpc313x/lpc313x-i2s.h
new file mode 100644
index 0000000..4282053
--- /dev/null
+++ b/sound/soc/lpc313x/lpc313x-i2s.h
@@ -0,0 +1,31 @@
+/*
+ * sound/soc/lpc313x/lpc313x-i2s.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __SOUND_SOC_LPC313X_I2S_H
+#define __SOUND_SOC_LPC313X_I2S_H
+
+#include <linux/types.h>
+
+extern struct snd_soc_dai_driver lpc313x_i2s_dai;
+
+#endif
+
diff --git a/sound/soc/lpc313x/lpc313x-pcm.c b/sound/soc/lpc313x/lpc313x-pcm.c
new file mode 100644
index 0000000..76b1dce
--- /dev/null
+++ b/sound/soc/lpc313x/lpc313x-pcm.c
@@ -0,0 +1,571 @@
+/*
+ * sound/soc/lpc313x/lpc313x-pcm.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <mach/dma.h>
+#include "lpc313x-pcm.h"
+
+#define SND_NAME "lpc313x-audio"
+static u64 lpc313x_pcm_dmamask = DMA_BIT_MASK(32);
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+/* The DMA controller in the LPC31XX has limited interrupt support
+   for DMA. A timer is used instead to update the current buffer
+   position */
+#define MIN_PERIODS 8
+#define MAX_PERIODS 32
+#define DMA_LIST_SIZE (MAX_PERIODS * sizeof(dma_sg_ll_t))
+#define MIN_BYTES_PERIOD 2048
+#define MAX_BYTES_PERIOD 4096
+#define MINTICKINC ((MIN_BYTES_PERIOD * HZ * (MIN_PERIODS / 4)) / (48000 * 2 * 2))
+
+#else
+#define MIN_PERIODS 2
+#define MAX_PERIODS 2
+#define MIN_BYTES_PERIOD (32 * 1024)
+#define MAX_BYTES_PERIOD (32 * 1024)
+#endif
+
+#if defined (CONFIG_SND_I2S_TX0_MASTER)
+#define TX_FIFO_ADDR (I2S_PHYS + 0x0E0)
+#define TX_DMA_CHCFG DMA_SLV_I2STX0_L
+#else
+#define TX_FIFO_ADDR (I2S_PHYS + 0x160)
+#define TX_DMA_CHCFG DMA_SLV_I2STX1_L
+#endif
+#if defined (CONFIG_SND_I2S_RX0_MASTER) | defined (CONFIG_SND_I2S_RX0_SLAVE)
+#define RX_FIFO_ADDR (I2S_PHYS + 0x1E0)
+#define RX_DMA_CHCFG DMA_SLV_I2SRX0_L
+#else
+#define RX_FIFO_ADDR (I2S_PHYS + 0x260)
+#define RX_DMA_CHCFG DMA_SLV_I2SRX1_L
+#endif
+
+static const struct snd_pcm_hardware lpc313x_pcm_hardware = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_RESUME |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats = (SND_SOC_DAIFMT_I2S),
+	.period_bytes_min = MIN_BYTES_PERIOD,
+	.period_bytes_max = MAX_BYTES_PERIOD,
+	.periods_min = MIN_PERIODS,
+	.periods_max = MAX_PERIODS,
+	.buffer_bytes_max = (MAX_PERIODS * MAX_BYTES_PERIOD)
+};
+
+struct lpc313x_dma_data {
+	dma_addr_t dma_buffer;	/* physical address of DMA buffer */
+	dma_addr_t dma_buffer_end; /* first address beyond DMA buffer */
+	size_t period_size;
+	int num_periods;
+
+	/* DMA configuration and support */
+	int dmach;
+	volatile dma_addr_t dma_cur;
+	u32 dma_cfg_base;
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+	dma_sg_ll_t *p_sg_cpu;
+	dma_sg_ll_t *p_sg_dma;
+	struct timer_list timer[2];
+	int inccount;
+#endif
+};
+
+/*
+ * DMA ISR - occurs when a new DMA buffer is needed
+ */
+static void lpc313x_pcm_dma_irq(int ch, dma_irq_type_t dtype, void *handle) {
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *) handle;
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc313x_dma_data *prtd = rtd->private_data;
+
+	(void) dtype;
+	(void) ch;
+
+	/* Last buffer is finished */
+	prtd->dma_cur += prtd->period_size;
+	if (prtd->dma_cur >= prtd->dma_buffer_end)
+		prtd->dma_cur = prtd->dma_buffer;
+
+	/* Tell audio system more buffer space is available */
+	snd_pcm_period_elapsed(substream);
+}
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+static void lpc313x_check_dmall(unsigned long data) {
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *) data;
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc313x_dma_data *prtd = rtd->private_data;
+
+	/* Determine buffer position from current DMA position. We don't need
+	   the exact address, just the last finished period */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mod_timer(&prtd->timer[0], jiffies + MINTICKINC);
+		prtd->dma_cur = (dma_addr_t) DMACH_SRC_ADDR(prtd->dmach - 1);
+	}
+	else {
+		mod_timer(&prtd->timer[1], jiffies + MINTICKINC);
+		prtd->dma_cur = (dma_addr_t) DMACH_DST_ADDR(prtd->dmach - 1);
+	}
+
+	/* Tell audio system more buffer space is available */
+	snd_pcm_period_elapsed(substream);
+}
+#endif
+
+static int lpc313x_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *dmabuf = &substream->dma_buffer;
+	size_t size = lpc313x_pcm_hardware.buffer_bytes_max;
+
+	dmabuf->dev.type = SNDRV_DMA_TYPE_DEV;
+	dmabuf->dev.dev = pcm->card->dev;
+	dmabuf->private_data = NULL;
+	dmabuf->area = dma_alloc_coherent(pcm->card->dev, size,
+					  &dmabuf->addr, GFP_KERNEL);
+
+	pr_debug("lpc313x-pcm:"
+		"preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
+		(void *) dmabuf->area,
+		(void *) dmabuf->addr,
+		size);
+
+	if (!dmabuf->area)
+		return -ENOMEM;
+
+	dmabuf->bytes = size;
+
+	return 0;
+}
+
+/*
+ * PCM operations
+ */
+static int lpc313x_pcm_hw_params(struct snd_pcm_substream *substream,
+			         struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc313x_dma_data *prtd = runtime->private_data;
+
+	/* this may get called several times by oss emulation
+	 * with different params
+	 */
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+
+	prtd->dma_buffer = runtime->dma_addr;
+	prtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;
+	prtd->period_size = params_period_bytes(params);
+	prtd->num_periods = params_periods(params);
+
+	return 0;
+}
+
+static int lpc313x_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+
+	/* Return the DMA channel */
+	if (prtd->dmach != -1) {
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+		dma_release_sg_channel(prtd->dmach);
+
+		/* Return the linked list area */
+		dma_free_coherent(substream->pcm->card->dev, 
+			DMA_LIST_SIZE, prtd->p_sg_cpu, (dma_addr_t)prtd->p_sg_dma);
+#else
+		dma_release_channel((unsigned int) prtd->dmach);
+#endif
+
+		prtd->dmach = -1;
+	}
+
+	return 0;
+}
+
+static int lpc313x_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+
+	/* Setup DMA channel */
+	if (prtd->dmach == -1) {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+			prtd->dmach = dma_request_sg_channel("I2STX",
+				lpc313x_pcm_dma_irq, substream, 0);
+			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
+				DMA_CFG_RD_SLV_NR(0) | DMA_CFG_CMP_CH_EN |
+				DMA_CFG_WR_SLV_NR(TX_DMA_CHCFG) |
+				DMA_CFG_CMP_CH_NR(prtd->dmach);
+
+#else
+			prtd->dmach = dma_request_channel("I2STX",
+				lpc313x_pcm_dma_irq, substream);
+			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
+				DMA_CFG_RD_SLV_NR(0) | DMA_CFG_CIRC_BUF |
+				DMA_CFG_WR_SLV_NR(TX_DMA_CHCFG);
+#endif
+		}
+		else {
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+			prtd->dmach = dma_request_sg_channel("I2SRX",
+				lpc313x_pcm_dma_irq, substream, 0);
+			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
+				DMA_CFG_WR_SLV_NR(0) | DMA_CFG_CMP_CH_EN |
+				DMA_CFG_RD_SLV_NR(RX_DMA_CHCFG) |
+				DMA_CFG_CMP_CH_NR(prtd->dmach);
+
+#else
+			prtd->dmach = dma_request_channel("I2SRX",
+				lpc313x_pcm_dma_irq, substream);
+			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
+				DMA_CFG_WR_SLV_NR(0) | DMA_CFG_CIRC_BUF |
+				DMA_CFG_RD_SLV_NR(RX_DMA_CHCFG);
+#endif
+		}
+
+		if (prtd->dmach < 0) {
+			pr_err("Error allocating DMA channel\n");
+			return prtd->dmach;
+		}
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+		/* Allocate space for a DMA linked list */
+		prtd->p_sg_cpu = (dma_sg_ll_t *) dma_alloc_coherent(
+			substream->pcm->card->dev, DMA_LIST_SIZE,
+			(dma_addr_t *) &prtd->p_sg_dma, GFP_KERNEL);
+
+		if (prtd->p_sg_cpu == NULL) {
+			pr_err("Error allocating DMA sg list\n");
+			dma_release_sg_channel(prtd->dmach);
+			prtd->dmach = -1;
+			return -ENOMEM;
+		}
+#endif
+	}
+
+	return 0;
+}
+
+int dma_stop_channel_sg (unsigned int chn);
+
+static int lpc313x_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc313x_dma_data *prtd = rtd->private_data;
+	int ret = 0;
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+	int i, tch;
+	u32 addr;
+	dma_sg_ll_t *p_sg_cpuw, *p_sg_dmaw;
+	unsigned long timeout;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		tch = 0;
+	}
+	else {
+		tch = 1;
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->dma_cur = prtd->dma_buffer;
+		p_sg_cpuw = prtd->p_sg_cpu;
+		p_sg_dmaw = prtd->p_sg_dma;
+
+		/* Build a linked list that wraps around */
+		addr = (u32) prtd->dma_buffer;
+		for (i = 0; i < prtd->num_periods; i++) {
+			p_sg_cpuw->setup.trans_length = (prtd->period_size / 4) - 1;
+			p_sg_cpuw->setup.cfg = prtd->dma_cfg_base;
+			p_sg_cpuw->next_entry = (u32) (p_sg_dmaw + 1);
+
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				p_sg_cpuw->setup.src_address = addr;
+				p_sg_cpuw->setup.dest_address = TX_FIFO_ADDR;
+			}
+			else {
+				p_sg_cpuw->setup.dest_address = addr;
+				p_sg_cpuw->setup.src_address = RX_FIFO_ADDR;
+			}
+
+			/* Wrap end of list back to start? */
+			if (i == (prtd->num_periods - 1))
+				p_sg_cpuw->next_entry = (u32) prtd->p_sg_dma;
+
+			p_sg_cpuw++;
+			p_sg_dmaw++;
+			addr += prtd->period_size;
+		}
+
+		/* Add and start audio data position timer */
+		init_timer(&prtd->timer[tch]);
+		prtd->timer[tch].data = (unsigned long) substream;
+		prtd->timer[tch].function = lpc313x_check_dmall;
+		prtd->timer[tch].expires = jiffies + MINTICKINC;
+		add_timer(&prtd->timer[tch]);
+
+		/* Program DMA channel and start it */
+		dma_prog_sg_channel(prtd->dmach, (u32) prtd->p_sg_dma);
+		dma_set_irq_mask(prtd->dmach, 1, 1);
+#else
+	dma_setup_t dmasetup;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->dma_cur = prtd->dma_buffer;
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			dmasetup.src_address = (u32) prtd->dma_buffer;
+			dmasetup.dest_address = TX_FIFO_ADDR;
+		}
+		else {
+			dmasetup.dest_address = (u32) prtd->dma_buffer;
+			dmasetup.src_address = RX_FIFO_ADDR;
+		}
+
+		dmasetup.cfg = prtd->dma_cfg_base;
+		dmasetup.trans_length = (2 * prtd->period_size / 4) - 1;
+
+		/* Program DMA channel and start it */
+		dma_prog_channel(prtd->dmach, &dmasetup);
+		dma_set_irq_mask(prtd->dmach, 0, 0);
+#endif
+		dma_start_channel(prtd->dmach);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+		del_timer_sync(&prtd->timer[tch]);
+#endif
+		/* Stop the companion channel and let the current DMA
+		   transfer finish */
+		dma_stop_channel_sg(prtd->dmach);
+		timeout = jiffies + (HZ / 20);
+		while ((dma_channel_enabled(prtd->dmach)) &&
+			(jiffies < timeout)) {
+			cpu_relax();
+		}
+
+//		dma_stop_channel(prtd->dmach);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		break;
+
+	default:
+		pr_warning("lpc313x_pcm_trigger: Unsupported cmd: %d\n",
+				cmd);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t lpc313x_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc313x_dma_data *prtd = runtime->private_data;
+	snd_pcm_uframes_t x;
+
+	/* Return an offset into the DMA buffer for the next data */
+	x = bytes_to_frames(runtime, (prtd->dma_cur - runtime->dma_addr));
+	if (x >= runtime->buffer_size)
+		x = 0;
+
+	return x;
+}
+
+static int lpc313x_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc313x_dma_data *prtd;
+	int ret = 0;
+
+	snd_soc_set_runtime_hwparams(substream, &lpc313x_pcm_hardware);
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+		SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	runtime->private_data = prtd;
+	prtd->dmach = -1;
+
+out:
+	return ret;
+}
+
+static int lpc313x_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+
+	kfree(prtd);
+	return 0;
+}
+
+static int lpc313x_pcm_mmap(struct snd_pcm_substream *substream,
+			    struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops lpc313x_pcm_ops = {
+	.open = lpc313x_pcm_open,
+	.close = lpc313x_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = lpc313x_pcm_hw_params,
+	.hw_free = lpc313x_pcm_hw_free,
+	.prepare = lpc313x_pcm_prepare,
+	.trigger = lpc313x_pcm_trigger,
+	.pointer = lpc313x_pcm_pointer,
+	.mmap = lpc313x_pcm_mmap,
+};
+
+/*
+ * ASoC platform driver
+ */
+static int lpc313x_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &lpc313x_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->driver->playback.channels_min) {
+		ret = lpc313x_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->driver->capture.channels_min) {
+		pr_debug("%s: Allocating PCM capture DMA buffer\n", SND_NAME);
+		ret = lpc313x_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void lpc313x_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (substream == NULL)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				  buf->area, buf->addr);
+
+		buf->area = NULL;
+	}
+}
+
+struct snd_soc_platform_driver lpc313x_asoc_platform = {
+	.ops = &lpc313x_pcm_ops,
+	.pcm_new = lpc313x_pcm_new,
+	.pcm_free = lpc313x_pcm_free_dma_buffers,
+};
+EXPORT_SYMBOL_GPL(lpc313x_asoc_platform);
+
+
+static int __devinit lpc313x_asoc_platform_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &lpc313x_asoc_platform);
+}
+
+static int __devexit lpc313x_asoc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver lpc313x_dma_driver = {
+	.driver = {
+		.name = SND_NAME,
+		.owner = THIS_MODULE,
+	},
+
+	.probe = lpc313x_asoc_platform_probe,
+	.remove = __devexit_p(lpc313x_asoc_platform_remove),
+};
+
+static int __init lpc313x_asoc_init(void)
+{
+	return platform_driver_register(&lpc313x_dma_driver);
+}
+module_init(lpc313x_asoc_init);
+
+static void __exit lpc313x_asoc_exit(void)
+{
+	platform_driver_unregister(&lpc313x_dma_driver);
+}
+module_exit(lpc313x_asoc_exit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("NXP LPC313X PCM module");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lpc323x-audio");
diff --git a/sound/soc/lpc313x/lpc313x-pcm.h b/sound/soc/lpc313x/lpc313x-pcm.h
new file mode 100644
index 0000000..0591a30
--- /dev/null
+++ b/sound/soc/lpc313x/lpc313x-pcm.h
@@ -0,0 +1,29 @@
+/*
+ * sound/soc/lpc313x/lpc313x-pcm.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __SOUND_SOC_LPC313X_PCM_H
+#define __SOUND_SOC_LPC313X_PCM_H
+
+extern struct snd_soc_platform_driver lpc313x_asoc_platform;
+
+#endif
+
diff --git a/sound/soc/lpc313x/lpc313x-uda1380.c b/sound/soc/lpc313x/lpc313x-uda1380.c
new file mode 100644
index 0000000..607d545
--- /dev/null
+++ b/sound/soc/lpc313x/lpc313x-uda1380.c
@@ -0,0 +1,250 @@
+/*
+ * sound/soc/lpc313x/lpc313x-uda1380.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/uda1380.h>
+
+#include "../codecs/uda1380.h"
+#include "lpc313x-pcm.h"
+#include "lpc313x-i2s.h"
+#include "lpc313x-i2s-clocking.h"
+
+#define SND_MODNAME "lpc313x_uda1380"
+
+static int ea3131_uda1380_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	const unsigned int fmt = (SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_CBS_CFS);
+	int ret;
+
+
+	/* Set the CPU I2S rate clock (first) */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params),
+					    SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set I2S clock (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	/* Set CPU and CODEC DAI format */
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CPU DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CODEC DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops ea3131_uda1380_ops = {
+	.hw_params = ea3131_uda1380_hw_params,
+};
+
+static const struct snd_soc_dapm_widget ea3131_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_LINE("Line Out", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* Headphone connected to VOUTRHP, VOUTLHP */
+	{"Headphone Jack", NULL, "VOUTRHP"},
+	{"Headphone Jack", NULL, "VOUTLHP"},
+
+	/* Line Out connected to VOUTR, VOUTL */
+	{"Line Out", NULL, "VOUTR"},
+	{"Line Out", NULL, "VOUTL"},
+
+	/* Mic connected to VINM */
+	{"VINM", NULL, "Mic Jack"},
+
+	/* Line In connected to VINR, VINL */
+	{"VINL", NULL, "Line In"},
+	{"VINR", NULL, "Line In"},
+};
+
+static int ea3131_uda1380_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	/* Add widgets */
+	snd_soc_dapm_new_controls(dapm, ea3131_dapm_widgets,
+				  ARRAY_SIZE(ea3131_dapm_widgets));
+
+	/* Set up audio path audio_map */
+	snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
+
+	/* Always connected pins */
+	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
+	snd_soc_dapm_enable_pin(dapm, "Line Out");
+	snd_soc_dapm_enable_pin(dapm, "Mic Jack");
+	snd_soc_dapm_enable_pin(dapm, "Line In");
+
+	snd_soc_dapm_sync(dapm);
+
+	return 0;
+}
+
+static struct snd_soc_dai_link ea3131_uda1380_dai[] = {
+	{
+		.name = "uda1380",
+		.stream_name = "uda1380",
+		.codec_name	= "uda1380-codec.1-001a",
+		.cpu_dai_name = "lpc313x-i2s.0",
+		.codec_dai_name = "uda1380-hifi",
+		.platform_name	= "lpc313x-audio.0",
+		.init = ea3131_uda1380_init,
+		.ops = &ea3131_uda1380_ops,
+	},
+};
+
+static struct snd_soc_card snd_soc_machine_ea3131 = {
+	.name = "lpc313x-i2s-uda1380",
+	.dai_link = &ea3131_uda1380_dai[0],
+	.num_links = ARRAY_SIZE(ea3131_uda1380_dai),
+};
+
+static struct uda1380_platform_data uda1380_info = {
+	.dac_clk    = UDA1380_DAC_CLK_SYSCLK,
+	.gpio_power = -1,
+	.gpio_reset = -1,
+};
+
+static struct i2c_board_info i2c_board_info[] = {
+	{
+		I2C_BOARD_INFO("uda1380", 0x1A),
+		.platform_data = &uda1380_info,
+	},
+};
+
+static struct platform_device *ea3131_snd_device;
+
+static int __devinit ea3131_asoc_probe(struct platform_device *pd)
+{
+	struct platform_device *snd_dev;
+	int ret = 0;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+
+	/*
+	 * Enable CODEC clock first or I2C will fail to the CODEC
+	 */
+	lpc313x_main_clk_rate(48000);
+
+#if defined (CONFIG_SND_I2C1_CHANNEL_UDA1380)
+	adapter = i2c_get_adapter(1);
+#else
+	adapter = i2c_get_adapter(0);
+#endif
+	if (!adapter)
+		return -ENODEV;
+	client = i2c_new_device(adapter, i2c_board_info);
+	i2c_put_adapter(adapter);
+	if (!client)
+		return -ENODEV;
+
+	snd_dev = platform_device_alloc("soc-audio", -1);
+	if (!snd_dev) {
+		dev_err(&pd->dev, "failed to alloc soc-audio devicec\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(snd_dev, &snd_soc_machine_ea3131);
+
+	ret = platform_device_add(snd_dev);
+	if (ret) {
+		dev_err(&pd->dev, "failed to add soc-audio dev\n");
+		return -ENODEV;
+	}
+
+	platform_set_drvdata(pd, snd_dev);
+	return ret;
+}
+
+static int __devexit ea3131_asoc_remove(struct platform_device *pdev)
+{
+	platform_device_unregister(ea3131_snd_device);
+	lpc313x_main_clk_rate(0);
+	ea3131_snd_device = NULL;
+	return 0;
+}
+
+static struct platform_driver ea3131_asoc_platdrv = {
+	.driver	= {
+		.owner	= THIS_MODULE,
+		.name	= "lpc313x-uda1380",
+		//.pm	= ea3131_asoc_pm,
+	},
+	.probe	= ea3131_asoc_probe,
+	.remove	= __devexit_p(ea3131_asoc_remove),
+};
+
+static int __init ea3131_asoc_modinit(void)
+{
+	return platform_driver_register(&ea3131_asoc_platdrv);
+}
+
+static void __exit ea3131_asoc_modexit(void)
+{
+	platform_driver_unregister(&ea3131_asoc_platdrv);
+}
+
+module_init(ea3131_asoc_modinit);
+module_exit(ea3131_asoc_modexit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC machine driver for LPC313X/UDA1380");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lpc313x-uda1380");
+
diff --git a/sound/soc/lpc313x/lpc315x-codec.c b/sound/soc/lpc313x/lpc315x-codec.c
new file mode 100644
index 0000000..63f7053
--- /dev/null
+++ b/sound/soc/lpc313x/lpc315x-codec.c
@@ -0,0 +1,217 @@
+/*
+ * sound/soc/lpc313x/lpc315x-codec.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "../codecs/lpc315x_codec.h"
+#include "lpc313x-pcm.h"
+#include "lpc313x-i2s.h"
+#include "lpc313x-i2s-clocking.h"
+
+#include <linux/io.h>
+#include <mach/cgu.h>
+#include <mach/board.h>
+#include <mach/registers.h>
+
+#define SND_MODNAME "lpc315x_machine"
+
+static int ea315x_lpc315x_codec_hw_params(struct snd_pcm_substream
+		*substream, struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	const unsigned int fmt = (SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_CBS_CFS);
+	int ret;
+
+	/* Set the CPU I2S rate clock (first) */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params),
+					    SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set I2S clock (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	/* Set CPU and CODEC DAI format */
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CPU DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CODEC DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops ea315x_lpc315x_codec_ops = {
+	.hw_params = ea315x_lpc315x_codec_hw_params,
+};
+
+static const struct snd_soc_dapm_widget ea315x_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* Headphone connected to HP_OUTR, HP_OUTL */
+	{"Headphone Jack", NULL, "HP_OUTR"},
+	{"Headphone Jack", NULL, "HP_OUTL"},
+
+	/* Mic connected to ADC_VINM */
+	{"ADC_MIC", NULL, "Mic Jack"},
+
+	/* Line In connected to ADC_VINR, ADC_VINL */
+	{"ADC_VINL", NULL, "Line In"},
+	{"ADC_VINR", NULL, "Line In"},
+
+	/* Line In connected to ADC_TINR, ADC_TINL */
+	{"ADC_TINL", NULL, "Line In"},
+	{"ADC_TINR", NULL, "Line In"},
+};
+
+static int ea315x_lpc315x_codec_init(struct snd_soc_codec *codec)
+{
+	/* Add widgets */
+	snd_soc_dapm_new_controls(codec, ea315x_dapm_widgets,
+				  ARRAY_SIZE(ea315x_dapm_widgets));
+
+	/* Set up audio path audio_map */
+	snd_soc_dapm_add_routes(codec, intercon, ARRAY_SIZE(intercon));
+
+	/* Always connected pins */
+	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+	snd_soc_dapm_enable_pin(codec, "Mic Jack");
+	snd_soc_dapm_enable_pin(codec, "Line In");
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static struct snd_soc_dai_link ea315x_lpc315x_codec_dai[] = {
+	{
+		.name = "LPC315X_CODEC",
+		.stream_name = "LPC315X_CODEC",
+		.cpu_dai = &lpc313x_i2s_dai,
+		.codec_dai = &lpc315x_codec_dais[0],
+		.init = ea315x_lpc315x_codec_init,
+		.ops = &ea315x_lpc315x_codec_ops,
+	},
+};
+
+static struct snd_soc_card snd_soc_machine_ea315x = {
+	.name = "LPC315X_CODEC",
+	.platform = &lpc313x_soc_platform,
+	.dai_link = &ea315x_lpc315x_codec_dai[0],
+	.num_links = ARRAY_SIZE(ea315x_lpc315x_codec_dai),
+};
+
+static struct snd_soc_device ea315x_lpc315x_codec_snd_dev = {
+	.card = &snd_soc_machine_ea315x,
+	.codec_dev = &soc_codec_lpc315x_dev,
+};
+
+static struct platform_device *ea315x_snd_device;
+
+/*
+ * EA315X Module init function
+ * */
+static int __init ea315x_asoc_init(void)
+{
+	int ret = 0;
+
+	/* Enable CODEC clock first or I2C will fail to the CODEC */
+	lpc313x_main_clk_rate(48000);
+
+	/* Analog Die is added as I2C device in EA3131 Board file.
+	 * So no need to add the I2C device again
+	 */
+	/* Create and register platform device */
+	ea315x_snd_device = platform_device_alloc("soc-audio", -1);
+	if (ea315x_snd_device == NULL) {
+		printk(KERN_ERR "Unable to register Audio device \r\n");
+		return -ENOMEM;
+	}
+
+	/* Store platform device info */
+	platform_set_drvdata(ea315x_snd_device,
+			&ea315x_lpc315x_codec_snd_dev);
+	ea315x_lpc315x_codec_snd_dev.dev = &ea315x_snd_device->dev;
+
+	/* Add Audio platform device */
+	ret = platform_device_add(ea315x_snd_device);
+	if (ret) {
+		pr_warning("%s: platform_device_add failed (%d)\n",
+			   SND_MODNAME, ret);
+		goto err_device_add;
+	}
+
+	return 0;
+
+err_device_add:
+	if (ea315x_snd_device != NULL) {
+		platform_device_put(ea315x_snd_device);
+		lpc313x_main_clk_rate(0);
+		ea315x_snd_device = NULL;
+	}
+
+	return ret;
+}
+
+static void __exit ea315x_asoc_exit(void)
+{
+	platform_device_unregister(ea315x_snd_device);
+	lpc313x_main_clk_rate(0);
+	ea315x_snd_device = NULL;
+}
+
+module_init(ea315x_asoc_init);
+module_exit(ea315x_asoc_exit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC machine driver for LPC315X/Analog Die Audio CODEC");
+MODULE_LICENSE("GPL");
+
